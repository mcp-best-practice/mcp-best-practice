{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe0 Home","text":""},{"location":"#mcp-best-practices-guide","title":"MCP Best Practices Guide","text":"<p>Work in Progress</p>"},{"location":"#welcome-to-the-model-context-protocol-best-practices-guide","title":"Welcome to the Model Context Protocol Best Practices Guide","text":"<p>This comprehensive guide provides best practices, patterns, and practical guidance for developing, deploying, and maintaining Model Context Protocol (MCP) servers in production environments.</p>"},{"location":"#what-is-mcp","title":"What is MCP?","text":"<p>The Model Context Protocol (MCP) is an open protocol that standardizes how applications provide context to large language models (LLMs). Think of MCP like a USB-C port for AI applications\u2014it provides a standardized way to connect AI models to different data sources and tools.</p>"},{"location":"#what-this-guide-covers","title":"What This Guide Covers","text":"<p>This guide is organized into practical sections that cover the entire MCP server lifecycle:</p>"},{"location":"#overview","title":"\ud83e\udded Overview","text":"<p>Start here for high-level concepts and decision points: - MCP at a Glance \u2014 executive summary and checklists - Architecture \u2014 system design and components - Core Concepts \u2014 tools, resources, prompts - Standards \u2014 protocol standards - Getting Started \u2014 your first server Get started with MCP fundamentals, architecture, and core concepts. Learn about the protocol standards and set up your first server.</p>"},{"location":"#best-practices","title":"\u2b50 Best Practices","text":"<p>Essential standards for robust MCP servers: - Best Practices Guide - Architecture, Security &amp; Operations</p>"},{"location":"#development","title":"\ud83d\udcbb Development","text":"<p>Language-specific guides for Python, JavaScript/TypeScript, and Go with real-world examples, patterns, and implementation details.</p>"},{"location":"#testing","title":"\ud83e\uddea Testing","text":"<p>Comprehensive testing strategies including unit, integration, and end-to-end testing approaches for MCP servers.</p>"},{"location":"#packaging","title":"\ud83d\udce6 Packaging","text":"<p>How to package and distribute MCP servers using language-specific package managers and container technologies.</p>"},{"location":"#deployment","title":"\ud83d\ude80 Deployment","text":"<p>Deployment strategies for cloud platforms, on-premise environments, Kubernetes, and CI/CD pipelines.</p>"},{"location":"#operations","title":"\u2699\ufe0f Operations","text":"<p>Production operations including monitoring, logging, performance optimization, scaling, and incident response.</p>"},{"location":"#management","title":"\ud83d\udd27 Management","text":"<p>Lifecycle management covering versioning, updates, rollbacks, and configuration management.</p>"},{"location":"#security","title":"\ud83d\udee1\ufe0f Security","text":"<p>Security best practices including authentication, authorization, secrets management, and vulnerability scanning.</p>"},{"location":"#integration","title":"\ud83d\udd0c Integration","text":"<p>How to integrate MCP servers with Claude Desktop, gateways, and other AI applications and platforms.</p>"},{"location":"#faq","title":"\u2753 FAQ","text":"<p>Common questions, troubleshooting guides, and migration assistance.</p>"},{"location":"#who-this-guide-is-for","title":"Who This Guide Is For","text":"<ul> <li>Developers building MCP servers and integrations</li> <li>DevOps Engineers deploying and operating MCP infrastructure</li> <li>Engineering Teams adopting MCP in production environments</li> <li>Technical Leaders evaluating MCP for their organizations</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If you're new to MCP, start with:</p> <ol> <li>Overview - Learn MCP fundamentals and architecture</li> <li>Getting Started - Build your first MCP server</li> <li>Best Practices - Understand essential standards</li> <li>Development Guide - Deep dive into implementation</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>This guide is community-driven. We welcome contributions, corrections, and improvements. The content reflects real-world experience and evolving best practices from the MCP community.</p>"},{"location":"#protocol-information","title":"Protocol Information","text":"<ul> <li>Current Protocol Version: 2025-06-18</li> <li>Transport Mechanisms: stdio, Streamable HTTP</li> <li>Message Format: JSON-RPC 2.0</li> <li>Official Specification: Model Context Protocol Specification</li> </ul> <p>Ready to build production-grade MCP servers? Let's get started! \ud83d\ude80</p>"},{"location":"best-practice/architecture-security-ops/","title":"Architecture, Security & Operations","text":""},{"location":"best-practice/architecture-security-ops/#mcp-architecture-security-and-operations-best-practices","title":"MCP Architecture, Security, and Operations Best Practices","text":"<p>This page summarizes practical, high\u2011value guidelines for building, securing, and operating MCP servers. It focuses on transports, gateway patterns, tool discipline, security controls, observability, and SLO\u2011driven operations.</p>"},{"location":"best-practice/architecture-security-ops/#architecture-and-deployment","title":"Architecture and Deployment","text":"<ul> <li>Transports: use <code>stdio</code> for local per\u2011user integrations; use Streamable HTTP for shared, remote services and scale\u2011out. Harden HTTP services as you would any production API.</li> <li>Topology: prefer simple direct connections for single\u2011server use; introduce a gateway when you need centralized authN/Z, routing, catalogs, rate limits/quotas, and policy enforcement across many servers/tenants.</li> <li>Gateway responsibilities: identity and scope brokering, routing and health checks, rate limiting/quotas, policy enforcement, audit/metrics correlation, and emergency kill switches.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Identity and access: enforce least privilege per tool and per action (read vs. write). Use fine\u2011grained authorization and require approvals for high\u2011risk operations.</li> <li>Input safety: validate inputs with strict schemas, types, ranges, and patterns; reject on first failure.</li> <li>Output safety: sanitize outputs to avoid injection in downstream systems; clearly label side effects and references.</li> <li>Secrets and transport: keep credentials in a secret manager, never inline. Use TLS everywhere, sign/verify containers and artifacts, and only trust vetted registries.</li> <li>Network policy: restrict egress/ingress; apply service\u2011to\u2011service authentication and explicit allowlists.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#tooling-discipline","title":"Tooling Discipline","text":"<ul> <li>Tool design: provide specific, actionable descriptions including constraints and side effects. Keep tools bounded (avoid \"kitchen\u2011sink\"). Version tool schemas; prefer additive changes; announce deprecations.</li> <li>Toolset management: support read\u2011only deployments; enable/disable tools by tenant, role, environment, or risk level. Filter destructive operations out of production or gate behind approvals/policies.</li> <li>State management: keep execution stateless by default. Externalize state (cache/DB) with clear TTLs and PII handling; avoid hidden server memory.</li> <li>Long\u2011running operations: use async patterns for operations that exceed request timeouts; return a handle + status tools. Require idempotency keys for create/update; provide compensating (rollback) actions where feasible.</li> <li>Async and concurrency: use async I/O for API\u2011bound tools; bound concurrency with semaphores; use worker/process pools for CPU tasks; reuse HTTP clients with keep\u2011alive, timeouts, retries with jitter.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#scalability-and-reliability","title":"Scalability and Reliability","text":"<ul> <li>Horizontal scale: prefer concurrent, short\u2011lived requests; design idempotent operations and safe retries.</li> <li>Limits and backpressure: apply per\u2011tenant and per\u2011tool rate limits; surface \"try later\" semantics; protect upstream systems.</li> <li>Health and circuit breakers: provide health/readiness endpoints; trip on dependency failures; shed load gracefully.</li> <li>Caching and batching: cache read\u2011heavy operations with appropriate TTLs; batch compatible requests to reduce API usage and cost.</li> <li>Compatibility and versioning: version the server, tool schemas, and side\u2011effect contracts; support feature detection and safe fallbacks.</li> <li>Performance practices: pre\u2011warm connections, cache tokens, and reuse clients; track token/API/compute budgets per tenant and shed non\u2011critical work under pressure.</li> <li>Load testing: establish budgets (p50/p95/p99 latency, throughput, error budgets). Test steady\u2011state, burst, and dependency failure modes; run soak tests to catch leaks.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#observability-and-governance","title":"Observability and Governance","text":"<ul> <li>Audit trails: capture who/what/when/why, including tool arguments (with redaction), decisions, and outcomes using structured logs.</li> <li>Metrics that matter: track tool success rate, latency, error classes, approval deferrals, and policy denials; correlate with cost and quota consumption.</li> <li>Policy as code: centralize guardrails and enforce consistently across environments (allow/deny lists, environment gating, approval requirements, sensitive\u2011data rules).</li> <li>Curated catalogs: maintain an approved server catalog with ownership, versions, capabilities, security review dates, and compliance tags.</li> <li>Runbooks and SLOs: define success rate, p95 latency, and error budgets per critical tool; document common failures, dependency outages, rate\u2011limit responses, and rollback steps with on\u2011call routing and escalation.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#versioning-and-promotion","title":"Versioning and Promotion","text":"<ul> <li>Pin versions: pin SDKs, dependencies, tool schemas, and configuration. Record environment and decoding profiles used in validation.</li> <li>SBOMs and signing: publish SBOMs for servers and dependencies; sign artifacts; store alongside releases.</li> <li>Promotion gates: require passing tests and budget checks; support canary/shadow rollout with clear rollback plans.</li> <li>Deprecations: announce timelines; support dual\u2011run or feature detection where feasible.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#testing-and-quality","title":"Testing and Quality","text":"<ul> <li>Cross\u2011model validation: test tool discovery/execution across hosted and local models; monitor behavioral drift.</li> <li>Golden sets: maintain deterministic test fixtures for tool contracts and side\u2011effects; validate schema changes.</li> <li>CI quality gates: static analysis, security scanning, unit/integration tests, and contract tests on every change.</li> </ul> <p>For a deeper dive into design principles and when to use MCP, see: - Best Practices Guide - Design Principles - When to Use MCP</p>"},{"location":"best-practice/architecture-security-ops/#environment-separation-and-tenancy","title":"Environment Separation and Tenancy","text":"<ul> <li>Isolate dev/stage/prod with distinct credentials, routes, policies, and quotas. Prevent cross\u2011environment data leakage.</li> <li>For multi\u2011tenant servers, partition configuration, logs, metrics, and rate limits per tenant; enforce strict tenant\u2011aware authorization.</li> <li>Provide tenancy selectors in discovery responses when capabilities differ by tenant/environment.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#quotas-budgets-and-cost-governance","title":"Quotas, Budgets, and Cost Governance","text":"<ul> <li>Define per\u2011tenant and per\u2011tool quotas (request rate, concurrency, data volume). Alert on nearing limits; provide soft/hard caps.</li> <li>Track cost drivers (API calls, egress, compute) per tenant. Expose budgets and consumption metrics; auto\u2011degrade non\u2011critical work when exceeding budget.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#dependency-protection","title":"Dependency Protection","text":"<ul> <li>Bound concurrency per dependency; implement client\u2011side backoff with jitter; maintain allowlists per destination.</li> <li>Validate third\u2011party responses (schemas, sizes, content types); protect downstreams from malformed or adversarial payloads.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#compatibility-and-feature-detection","title":"Compatibility and Feature Detection","text":"<ul> <li>Expose server, tool, and schema versions; include feature flags in discovery to allow clients to adapt.</li> <li>Maintain backward\u2011compatible changes where possible; sunset schedules for breaking changes.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#operational-readiness-checklist","title":"Operational Readiness Checklist","text":"<ul> <li>Health/readiness endpoints; dependency checks with timeouts and fallbacks.</li> <li>Structured logs with correlation IDs; metrics and traces hooked to dashboards and alerts.</li> <li>Runbooks for common failures; on\u2011call rotation and escalation defined.</li> <li>Disaster recovery basics: backups for critical state; restore drills; capacity reserves for failover.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#incident-taxonomy-and-response","title":"Incident Taxonomy and Response","text":"<ul> <li>Categories: availability, latency, correctness (tool contract failures), security (authZ/policy denials), quota/budget breaches.</li> <li>Response: detect \u2192 triage (blast radius) \u2192 mitigate (degrade/circuit break) \u2192 RCA \u2192 fix forward or rollback \u2192 learnings to catalog.</li> </ul>"},{"location":"best-practice/architecture-security-ops/#example-slo-baselines-tune-to-your-context","title":"Example SLO Baselines (tune to your context)","text":"<ul> <li>Tool success rate \u2265 99.0% monthly; p95 latency \u2264 400 ms; error budget \u2264 1%.</li> <li>Discovery p95 \u2264 150 ms; health/readiness p95 \u2264 50 ms.</li> <li>Approval workflow p95 \u2264 2 s; policy engine p95 \u2264 100 ms.</li> </ul>"},{"location":"best-practice/mcp-best-practices/","title":"Best Practices Guide","text":""},{"location":"best-practice/mcp-best-practices/#mcp-server-best-practices-overview","title":"MCP Server Best Practices Overview","text":""},{"location":"best-practice/mcp-best-practices/#picking-the-right-sdk","title":"Picking the Right SDK","text":""},{"location":"best-practice/mcp-best-practices/#sdk-selection-criteria","title":"SDK Selection Criteria","text":"<p>Use an official SDK when possible as it is most likely to stay current and spec\u2011compliant. Official SDKs are listed at the official SDK page. TypeScript and Python SDKs are currently further ahead in development than the others.</p> <p>The official Go SDK (modelcontextprotocol/go-sdk) is under heavy development. Meanwhile, mark3labs/mcp-go is a good alternative choice.</p> <p>FastMCP is another well-maintained SDK in Python.</p>"},{"location":"best-practice/mcp-best-practices/#mcp-server-features-and-capabilities","title":"MCP Server Features and Capabilities","text":"<p>An MCP server should include the following capabilities. SDK support varies; verify each requirement for your chosen language SDK or implement in your server.</p>"},{"location":"best-practice/mcp-best-practices/#read-only-mode-support","title":"Read-Only Mode Support","text":"<p>Ensure that your MCP Server can be deployed with just read-only tools.</p> <p>Provide options to enable write/edit tools but pair them with sufficient authn/authz.</p> <ul> <li>Hosting providers: Use SDK support for read-only mode restrictions</li> <li>Granular control: Select SDKs with fine-grained permission controls</li> </ul>"},{"location":"best-practice/mcp-best-practices/#staticdynamic-toolset-selection","title":"Static/Dynamic Toolset Selection","text":"<p>Effective context management is essential to ensure large language models (LLMs) perform well. Avoid overloading them with too many tools. Design MCP servers so toolsets can be enabled or disabled statically or dynamically.</p> <ul> <li>Runtime configuration: SDKs that support tool registration at runtime</li> <li>Conditional tools: Ability to enable/disable tools based on permissions</li> <li>Context-aware tools: Tools that adapt based on user authentication</li> </ul>"},{"location":"best-practice/mcp-best-practices/#authenticationauthorization-support","title":"Authentication/Authorization Support","text":"<p>Implement the OAuth 2.0 authorization flows defined in the MCP specification.</p> <ul> <li>OAuth 2.0: Built-in OAuth flow handling</li> <li>API key management: Secure credential storage and rotation</li> <li>Scope management: Granular permission scopes per tool</li> <li>Token exchange: Support for token refresh and exchange patterns</li> </ul>"},{"location":"best-practice/mcp-best-practices/#tool-and-prompt-description-guidance","title":"Tool and Prompt Description Guidance","text":""},{"location":"best-practice/mcp-best-practices/#writing-effective-tool-descriptions","title":"Writing Effective Tool Descriptions","text":"<p>Follow these principles for tool descriptions:</p>"},{"location":"best-practice/mcp-best-practices/#be-specific-and-actionable","title":"Be Specific and Actionable","text":"<pre><code>// \u274c Bad: Vague description\n{\n  \"name\": \"manage_files\",\n  \"description\": \"Handle files\"\n}\n\n// \u2705 Good: Specific and clear\n{\n  \"name\": \"read_text_file\",\n  \"description\": \"Read the contents of a text file from the local filesystem. Returns the file content as plain text. Maximum file size: 10MB.\"\n}\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#include-context-and-constraints","title":"Include Context and Constraints","text":"<pre><code>{\n  \"name\": \"create_github_issue\",\n  \"description\": \"Create a new issue in a GitHub repository. Requires 'issues:write' permission. The issue will be created with the authenticated user as the author.\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"repository\": {\n        \"type\": \"string\",\n        \"description\": \"Repository in format 'owner/repo' (e.g., 'microsoft/vscode')\",\n        \"pattern\": \"^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$\"\n      },\n      \"title\": {\n        \"type\": \"string\",\n        \"description\": \"Issue title (1-256 characters)\",\n        \"minLength\": 1,\n        \"maxLength\": 256\n      },\n      \"body\": {\n        \"type\": \"string\",\n        \"description\": \"Issue description in GitHub Markdown format\",\n        \"maxLength\": 65536\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#design-tool-descriptions-to-suggest-next-steps","title":"Design Tool Descriptions to Suggest Next Steps","text":"<pre><code>// \u274c Bad: Vague description\n{\n  \"name\": \"start_pod\",\n  \"description\": \"Start a Kubernetes pod.\"\n}\n\n// \u2705 Good: Specific and clear\n{\n  \"name\": \"pod_start\",\n  \"description\": \"Start a Kubernetes pod. You can run pod_status tool to check if it started successfully.\"\n}\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#reference-existing-documentation","title":"Reference Existing Documentation","text":"<p>For tool descriptions, refer to:</p> <ul> <li>Anthropic's MCP documentation</li> <li>Tool design patterns</li> <li>Industry-specific API documentation</li> </ul>"},{"location":"best-practice/mcp-best-practices/#managing-state-in-mcp-servers","title":"Managing State in MCP Servers","text":""},{"location":"best-practice/mcp-best-practices/#stateless-by-default","title":"Stateless by Default","text":"<pre><code># \u2705 Good: Stateless operation\n@server.call_tool()\nasync def get_user_profile(name: str, arguments: dict):\n    user_id = arguments[\"user_id\"]\n    # Fetch from external system\n    profile = await api_client.get_user(user_id)\n    return [TextContent(type=\"text\", text=json.dumps(profile))]\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#external-state-management","title":"External State Management","text":"<pre><code># \u2705 Good: External state storage\nclass StatefulMCPServer:\n    def __init__(self, redis_client):\n        self.cache = redis_client\n    \n    async def process_with_cache(self, key: str, data: dict):\n        # Check cache first\n        cached = await self.cache.get(key)\n        if cached:\n            return json.loads(cached)\n        \n        # Process and cache result\n        result = await process_data(data)\n        await self.cache.setex(key, 300, json.dumps(result))  # 5 min TTL\n        return result\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#testing-strategy","title":"Testing Strategy","text":""},{"location":"best-practice/mcp-best-practices/#evaluation-with-models","title":"Evaluation with Models","text":"<p>Test your MCP server with both hosted and local models:</p> <pre><code># Automated testing with different models\nasync def test_with_models():\n    models = [\n        (\"claude-3-sonnet\", \"hosted\"),\n        (\"llama2\", \"local\"),\n        (\"gpt-4\", \"hosted\")\n    ]\n    \n    for model_name, deployment in models:\n        client = get_model_client(model_name, deployment)\n        \n        # Test tool discovery\n        tools = await client.list_tools()\n        assert len(tools) &gt; 0\n        \n        # Test tool execution\n        result = await client.call_tool(\"echo\", {\"text\": \"test\"})\n        assert \"test\" in str(result)\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#evaluation-frameworks","title":"Evaluation Frameworks","text":"<p>Use evaluation platforms such as MCP Evals to measure and track the performance of your MCP server and its tools with LLMs over time.</p>"},{"location":"best-practice/mcp-best-practices/#linting-and-static-analysis","title":"Linting and Static Analysis","text":"<p>Implement comprehensive code quality checks:</p> <pre><code># .github/workflows/quality.yml\nname: Code Quality\non: [push, pull_request]\njobs:\n  quality:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n    - name: Static Analysis Security Testing (SAST)\n      run: |\n        # Python\n        bandit -r src/\n        semgrep --config=auto src/\n        \n        # JavaScript\n        npm audit\n        eslint --ext .js,.ts src/\n        \n        # Go\n        gosec ./...\n        staticcheck ./...\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#curated-catalog","title":"Curated Catalog","text":""},{"location":"best-practice/mcp-best-practices/#what-is-a-curated-catalog","title":"What is a Curated Catalog?","text":"<p>A curated catalog is a vetted collection of MCP servers approved for organizational use.</p>"},{"location":"best-practice/mcp-best-practices/#internal-catalogs","title":"Internal Catalogs","text":"<ul> <li>Company-specific: Internal MCP servers for organizational tools</li> <li>Security reviewed: All servers undergo security assessment</li> <li>Compliance checked: Servers meet regulatory requirements</li> <li>Usage tracked: Monitor adoption and performance</li> </ul>"},{"location":"best-practice/mcp-best-practices/#external-catalogs","title":"External Catalogs","text":"<ul> <li>Public repositories: Community-maintained MCP server collections</li> <li>Vendor catalogs: Official servers from service providers</li> <li>Industry-specific: Specialized servers for specific domains</li> </ul>"},{"location":"best-practice/mcp-best-practices/#example-catalog-structure","title":"Example Catalog Structure","text":"<pre><code># catalog.yaml\nservers:\n  github-mcp:\n    name: \"GitHub Integration Server\"\n    repository: \"https://github.com/company/github-mcp\"\n    version: \"1.2.0\"\n    security_review: \"2024-01-15\"\n    compliance: [\"SOC2\", \"GDPR\"]\n    tags: [\"git\", \"development\", \"issues\"]\n    \n  database-mcp:\n    name: \"Database Query Server\"\n    repository: \"https://github.com/company/database-mcp\"\n    version: \"2.1.0\"\n    security_review: \"2024-02-01\"\n    compliance: [\"SOC2\", \"HIPAA\"]\n    tags: [\"database\", \"sql\", \"reporting\"]\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#tool-filtering-and-guardrails","title":"Tool Filtering and Guardrails","text":""},{"location":"best-practice/mcp-best-practices/#production-tool-filtering","title":"Production Tool Filtering","text":"<p>Never provide agents with tools that can cause irreversible changes in production:</p> <pre><code>class ProductionToolFilter:\n    DANGEROUS_PATTERNS = [\n        \"delete_\",\n        \"drop_\",\n        \"truncate_\",\n        \"destroy_\",\n        \"_production\"\n    ]\n    \n    def filter_tools(self, tools: List[Tool], environment: str) -&gt; List[Tool]:\n        if environment == \"production\":\n            return [\n                tool for tool in tools \n                if not any(pattern in tool.name.lower() \n                          for pattern in self.DANGEROUS_PATTERNS)\n            ]\n        return tools\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#sequencing-tools-with-guardrails","title":"Sequencing Tools with Guardrails","text":"<p>Implement approval workflows for sensitive operations:</p> <pre><code>async def execute_with_guardrails(tool_name: str, arguments: dict):\n    # Check if tool requires approval\n    if tool_name in REQUIRES_APPROVAL:\n        approval = await request_approval(tool_name, arguments)\n        if not approval.granted:\n            raise PermissionError(f\"Tool execution not approved: {approval.reason}\")\n    \n    # Execute with monitoring\n    with execution_monitor(tool_name):\n        result = await execute_tool(tool_name, arguments)\n    \n    return result\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#model-selection-and-experience","title":"Model Selection and Experience","text":""},{"location":"best-practice/mcp-best-practices/#model-performance-by-task-type","title":"Model Performance by Task Type","text":"<p>Different models excel at different MCP operations:</p> Task Type Best Models Notes Code generation Claude-3.5 Sonnet, GPT-4 Strong reasoning for complex tools Data analysis Claude-3 Sonnet, GPT-4 Good at structured data manipulation Text processing Claude-3 Haiku, GPT-3.5 Fast for simple text operations API integration Claude-3.5 Sonnet Excellent at following API specifications"},{"location":"best-practice/mcp-best-practices/#context-size-considerations","title":"Context Size Considerations","text":"<ul> <li>Large context models: Better for complex multi-step operations</li> <li>Small context models: Suitable for simple, focused tasks</li> <li>Context management: Implement context window optimization</li> </ul> <pre><code># Context optimization\ndef optimize_context(messages: List[Message], max_tokens: int) -&gt; List[Message]:\n    if total_tokens(messages) &lt;= max_tokens:\n        return messages\n    \n    # Keep system message and recent context\n    system_msg = messages[0]\n    recent_msgs = messages[-10:]  # Keep last 10 messages\n    \n    return [system_msg] + recent_msgs\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#product-support-lifecycle","title":"Product Support Lifecycle","text":""},{"location":"best-practice/mcp-best-practices/#managing-spec-evolution","title":"Managing Spec Evolution","text":"<p>The MCP specification evolves rapidly while product lifecycles are long:</p>"},{"location":"best-practice/mcp-best-practices/#version-strategy","title":"Version Strategy","text":"<pre><code>mcp_compatibility:\n  supported_versions: [\"2024-11-05\", \"2025-06-18\"]\n  deprecated_versions: [\"2024-06-01\"]\n  migration_timeline: \"6 months\"\n  \nproduct_lifecycle:\n  support_duration: \"3 years\"\n  update_frequency: \"quarterly\"\n  lts_versions: [\"1.0\", \"2.0\"]\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#adaptation-strategies","title":"Adaptation Strategies","text":"<ul> <li>Graceful degradation: Handle unknown protocol features</li> <li>Feature detection: Test for capability support at runtime</li> <li>Backward compatibility: Support multiple protocol versions</li> <li>Regular updates: Plan quarterly compatibility updates</li> </ul>"},{"location":"best-practice/mcp-best-practices/#developer-preview-recommendations","title":"Developer Preview Recommendations","text":"<p>Given the evolving nature of MCP:</p> <ul> <li>Community support only: Don't provide enterprise SLA during preview</li> <li>Regular updates required: Plan for frequent protocol updates</li> <li>Feedback collection: Actively gather user experience feedback</li> <li>Migration tooling: Provide tools for spec updates</li> </ul> <pre><code># Feature detection pattern\nasync def check_server_capabilities():\n    try:\n        # Try new protocol feature\n        result = await server.call(\"new_method\", {})\n        return {\"supports_new_method\": True}\n    except MethodNotFoundError:\n        # Fallback to older approach\n        return {\"supports_new_method\": False}\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#the-mcp-host-application","title":"The MCP Host Application","text":""},{"location":"best-practice/mcp-best-practices/#key-security-features-for-client-applications","title":"Key Security Features for Client Applications","text":"<p>Host applications must implement these security features:</p>"},{"location":"best-practice/mcp-best-practices/#tool-description-transparency","title":"Tool Description Transparency","text":"<p>Always show complete tool descriptions to users to prevent rug pulls and shadowing:</p> <pre><code># Show full tool schema before execution\ndef display_tool_info(tool: Tool):\n    print(f\"Tool: {tool.name}\")\n    print(f\"Description: {tool.description}\")\n    print(f\"Required permissions: {get_required_permissions(tool)}\")\n    print(f\"Potential side effects: {analyze_side_effects(tool)}\")\n    \n    # Show input schema clearly\n    for param, schema in tool.inputSchema.get(\"properties\", {}).items():\n        required = param in tool.inputSchema.get(\"required\", [])\n        print(f\"  {param} ({'required' if required else 'optional'}): {schema.get('description', '')}\")\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#request-approval-for-tool-use","title":"Request Approval for Tool Use","text":"<p>Implement user approval workflows for sensitive operations:</p> <pre><code>class ToolApprovalSystem:\n    def __init__(self):\n        self.high_risk_patterns = [\"delete\", \"drop\", \"remove\", \"destroy\"]\n        self.auto_approve_patterns = [\"read\", \"get\", \"list\", \"show\"]\n    \n    async def request_approval(self, tool_name: str, arguments: dict) -&gt; bool:\n        risk_level = self.assess_risk(tool_name, arguments)\n        \n        if risk_level == \"low\":\n            return True  # Auto-approve safe operations\n        \n        # Show detailed information and request approval\n        print(f\"\\n\ud83d\udd27 Tool Execution Request\")\n        print(f\"Tool: {tool_name}\")\n        print(f\"Arguments: {json.dumps(arguments, indent=2)}\")\n        print(f\"Risk Level: {risk_level}\")\n        \n        return await self.get_user_confirmation()\n    \n    def assess_risk(self, tool_name: str, arguments: dict) -&gt; str:\n        if any(pattern in tool_name.lower() for pattern in self.high_risk_patterns):\n            return \"high\"\n        \n        # Check for production environment\n        if any(\"production\" in str(v).lower() for v in arguments.values()):\n            return \"high\"\n        \n        return \"low\"\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#tool-shadowing-prevention","title":"Tool Shadowing Prevention","text":"<p>Detect and prevent malicious tools that mimic safe operations:</p> <pre><code>def detect_tool_shadowing(new_tool: Tool, existing_tools: List[Tool]) -&gt; List[str]:\n    warnings = []\n    \n    for existing in existing_tools:\n        # Check for name similarity\n        similarity = calculate_similarity(new_tool.name, existing.name)\n        if similarity &gt; 0.8 and new_tool.name != existing.name:\n            warnings.append(f\"Tool name '{new_tool.name}' is similar to existing '{existing.name}'\")\n        \n        # Check for description overlap with different behavior\n        if (similar_descriptions(new_tool.description, existing.description) and\n            different_schemas(new_tool.inputSchema, existing.inputSchema)):\n            warnings.append(f\"Tool '{new_tool.name}' has similar description but different schema than '{existing.name}'\")\n    \n    return warnings\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#input-and-output-sanitization","title":"Input and Output Sanitization","text":"<p>Ensure your inputs and outputs are sanitized. In Python, we recommend using Pydantic V2.</p>"},{"location":"best-practice/mcp-best-practices/#self-containment","title":"\ud83d\udce6 Self-Containment","text":"<p>Each MCP server must be a standalone repository that includes all necessary code and documentation. Example: <code>git clone; make serve</code></p>"},{"location":"best-practice/mcp-best-practices/#makefile-requirements","title":"\ud83d\udee0 Makefile Requirements","text":"<p>All MCP repositories must include a <code>Makefile</code> with the following standard targets. These targets ensure consistency, enable automation, and support local development and containerization.</p>"},{"location":"best-practice/mcp-best-practices/#required-make-targets","title":"\u2705 Required Make Targets","text":"<p>Make targets are grouped by functionality. Use <code>make help</code> to see them all in your terminal.</p>"},{"location":"best-practice/mcp-best-practices/#virtual-environment-installation","title":"\ud83c\udf31 VIRTUAL ENVIRONMENT &amp; INSTALLATION","text":"Target Description <code>make venv</code> Create a new Python virtual environment in <code>~/.venv/&lt;project&gt;</code>. <code>make activate</code> Output the command to activate the virtual environment. <code>make install</code> Install all dependencies using <code>uv</code> from <code>pyproject.toml</code>. <code>make clean</code> Remove virtualenv, Python artifacts, build files, and containers."},{"location":"best-practice/mcp-best-practices/#run-server-testing","title":"\u25b6\ufe0f RUN SERVER &amp; TESTING","text":"Target Description <code>make serve</code> Run the MCP server locally (e.g., <code>mcp-time-server</code>). <code>make test</code> Run all unit and integration tests with <code>pytest</code>. <code>make test-curl</code> Run public API integration tests using a <code>curl</code> script."},{"location":"best-practice/mcp-best-practices/#documentation-sbom","title":"\ud83d\udcda DOCUMENTATION &amp; SBOM","text":"Target Description <code>make docs</code> Generate project documentation and SBOM using <code>handsdown</code>. <code>make sbom</code> Create a software bill of materials (SBOM) and scan dependencies."},{"location":"best-practice/mcp-best-practices/#linting-static-analysis","title":"\ud83d\udd0d LINTING &amp; STATIC ANALYSIS","text":"Target Description <code>make lint</code> Run all linters (e.g., <code>ruff check</code>, <code>ruff format</code>)."},{"location":"best-practice/mcp-best-practices/#container-build-run","title":"\ud83d\udc33 CONTAINER BUILD &amp; RUN","text":"Target Description <code>make podman</code> Build a production-ready container image with Podman. <code>make podman-run</code> Run the container locally and expose it on port 8080. <code>make podman-stop</code> Stop and remove the running container. <code>make podman-test</code> Test the container with a <code>curl</code> script."},{"location":"best-practice/mcp-best-practices/#security-package-scanning","title":"\ud83d\udee1\ufe0f SECURITY &amp; PACKAGE SCANNING","text":"Target Description <code>make trivy</code> Scan the container image for vulnerabilities using Trivy. <p>Tip: These commands should work out-of-the-box after cloning a repo and running <code>make venv install serve</code>.</p>"},{"location":"best-practice/mcp-best-practices/#containerfile","title":"\ud83d\udc33 Containerfile","text":"<p>Each repo must include a <code>Containerfile</code> (Podman-compatible, Docker-compatible) to support containerized execution.</p>"},{"location":"best-practice/mcp-best-practices/#containerfile-requirements","title":"Containerfile Requirements","text":"<ul> <li>Must start from a secure base (e.g., latest Red Hat UBI9 minimal image <code>registry.access.redhat.com/ubi9-minimal:9.5-1741850109</code>)</li> <li>Should use <code>uv</code> or <code>pdm</code> to install dependencies via <code>pyproject.toml</code></li> <li>Must run the server using the same entry point as <code>make serve</code></li> <li>Should expose relevant ports (<code>EXPOSE 8080</code>)</li> <li>Should define a non-root user for runtime</li> </ul>"},{"location":"best-practice/mcp-best-practices/#dependency-management","title":"\ud83d\udcda Dependency Management","text":"<ul> <li>All Python projects must use <code>pyproject.toml</code> and follow PEP standards.</li> <li>Dependencies must either be:</li> <li>Included in the repo</li> <li>Pulled from PyPI (no external links)</li> </ul>"},{"location":"best-practice/mcp-best-practices/#clear-role-definition","title":"\ud83c\udfaf Clear Role Definition","text":"<ul> <li>State the specific role of the server (e.g., GitHub tools).</li> <li>Group related tools together.</li> <li>Do not mix roles (e.g., GitHub \u2260 Jira \u2260 GitLab).</li> </ul>"},{"location":"best-practice/mcp-best-practices/#standardized-tools","title":"\ud83e\uddf0 Standardized Tools","text":"<p>Each MCP server should expose tools that follow the MCP conventions, e.g.:</p> <ul> <li><code>create_ticket</code></li> <li><code>create_pr</code></li> <li><code>read_file</code></li> </ul>"},{"location":"best-practice/mcp-best-practices/#consistent-structure","title":"\ud83d\udcc1 Consistent Structure","text":"<p>Repos must follow a common structure. For example, from the time_server</p> <pre><code>time_server/\n\u251c\u2500\u2500 Containerfile                  # Container build definition (Podman/Docker compatible)\n\u251c\u2500\u2500 Makefile                       # Build, run, test, and container automation targets\n\u251c\u2500\u2500 pyproject.toml                 # Python project and dependency configuration (PEP 621)\n\u251c\u2500\u2500 README.md                      # Main documentation: overview, setup, usage, env vars\n\u251c\u2500\u2500 CONTRIBUTING.md                # Guidelines for contributing, PRs, and issue management\n\u251c\u2500\u2500 .gitignore                     # Exclude venvs, artifacts, and secrets from Git\n\u251c\u2500\u2500 docs/                          # (Optional) Diagrams, specs, and additional documentation\n\u251c\u2500\u2500 tests/                         # Unit and integration tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_main.py               # Tests for main entrypoint behavior\n\u2502   \u2514\u2500\u2500 test_tools.py              # Tests for core tool functionality\n\u2514\u2500\u2500 src/                           # Application source code\n    \u2514\u2500\u2500 mcp_time_server/           # Main package named after your server\n        \u251c\u2500\u2500 __init__.py            # Marks this directory as a Python package\n        \u251c\u2500\u2500 main.py                # Entrypoint that wires everything together\n        \u251c\u2500\u2500 mcp_server_base.py     # Optional base class for shared server behavior\n        \u251c\u2500\u2500 server.py              # Server logic (e.g., tool registration, lifecycle hooks)\n        \u2514\u2500\u2500 tools/                 # Directory for all MCP tool implementations\n            \u251c\u2500\u2500 __init__.py\n            \u251c\u2500\u2500 tools.py           # Tool business logic (e.g., `get_time`, `format_time`)\n            \u2514\u2500\u2500 tools_registration.py # Registers tools into the MCP framework\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#documentation","title":"\ud83d\udcdd Documentation","text":"<p>Each repo must include:</p> <ul> <li>A comprehensive <code>README.md</code></li> <li>Setup and usage instructions</li> <li>Environment variable documentation</li> </ul>"},{"location":"best-practice/mcp-best-practices/#modular-design","title":"\ud83e\udde9 Modular Design","text":"<p>Code should be cleanly separated into modules for easier maintenance and scaling.</p>"},{"location":"best-practice/mcp-best-practices/#testing","title":"\u2705 Testing","text":"<p>Include unit and integration tests to validate functionality.</p>"},{"location":"best-practice/mcp-best-practices/#contribution-guidelines","title":"\ud83e\udd1d Contribution Guidelines","text":"<p>Add a <code>CONTRIBUTING.md</code> with:</p> <ul> <li>How to file issues</li> <li>How to submit pull requests</li> <li>Review and merge process</li> </ul>"},{"location":"best-practice/mcp-best-practices/#versioning-and-releases","title":"\ud83c\udff7 Versioning and Releases","text":"<p>Use semantic versioning. Include release notes for all changes.</p>"},{"location":"best-practice/mcp-best-practices/#pull-request-process","title":"\ud83d\udd04 Pull Request Process","text":"<p>Submit new MCP servers via pull request to the org's main repo. PR must:</p> <ul> <li>Follow all standards</li> <li>Include all documentation</li> </ul>"},{"location":"best-practice/mcp-best-practices/#environment-variables-and-secrets","title":"\ud83d\udd10 Environment Variables and Secrets","text":"<ul> <li>Use environment variables for secrets</li> <li>Use a clear, role-based prefix (e.g., <code>MCP_GITHUB_</code>)</li> </ul> <p>Example:</p> <pre><code>MCP_GITHUB_ACCESS_TOKEN=...\nMCP_GITHUB_BASE_URL=...\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#required-capabilities-readme-metadata-tags","title":"\ud83c\udff7 Required Capabilities (README Metadata Tags)","text":"<p>Add tags at the top of <code>README.md</code> between YAML markers to declare your server's required capabilities.</p>"},{"location":"best-practice/mcp-best-practices/#available-tags","title":"Available Tags","text":"<ul> <li> <p><code>needs_filesystem_access</code>   Indicates the server requires access to the local filesystem (e.g., for reading/writing files).</p> </li> <li> <p><code>needs_api_key_user</code>   Requires a user-specific API key to interact with external services on behalf of the user.</p> </li> <li> <p><code>needs_api_key_central</code>   Requires a centrally managed API key, typically provisioned and stored by the platform.</p> </li> <li> <p><code>needs_database</code>   The server interacts with a persistent database (e.g., PostgreSQL, MongoDB).</p> </li> <li> <p><code>needs_network_access_inbound</code>   The server expects to receive inbound network requests (e.g., runs a web server or webhook listener).</p> </li> <li> <p><code>needs_network_access_outbound</code>   The server needs to make outbound network requests (e.g., calling external APIs or services).</p> </li> </ul>"},{"location":"best-practice/mcp-best-practices/#example","title":"Example","text":"<pre><code>---\ntags:\n  - needs_filesystem_access\n  - needs_api_key_user\n---\n</code></pre>"},{"location":"best-practice/mcp-best-practices/#defensive-programming","title":"\ud83d\udee1 Defensive Programming","text":"<p>MCP Server logic should be developed defensively, particularly when the MCP server enables write operations and destructive actions. This can be even more important if the MCP Server wraps another API. The Kubernetes API is a good example, as it is common for there to be few guardrails in front of destructive actions.</p> <p>Example: If you have a Kubernetes API and a controller for managing ingress Gateways, and you want to enable modification or deletion of Gateways (and the controller does not have guardrails, it simply moves towards the declared state) through an MCP Server, you should add defensive logic to your MCP Server (e.g. \"check if the Gateway has active routes serving production traffic\").</p> <p>Take advantage of feedback mechanisms (today, elicitation is one such mechanism) to increase the safety and reduce accidental destructive actions from agents. In general: Keep in mind when developing MCP Server logic which enables write ops and destructive actions, that the Agents which will utilize them do not possess human judgement.</p>"},{"location":"best-practice/principles/","title":"Design Principles","text":""},{"location":"best-practice/principles/#mcp-design-principles","title":"MCP Design Principles","text":""},{"location":"best-practice/principles/#core-principles","title":"Core Principles","text":"<p>These fundamental principles guide the design and implementation of effective MCP servers and should inform all development decisions.</p>"},{"location":"best-practice/principles/#1-single-responsibility-principle","title":"1. Single Responsibility Principle","text":""},{"location":"best-practice/principles/#definition","title":"Definition","text":"<p>Each MCP server should have one clear, well-defined purpose and focus on a specific problem area and authentication domain.</p>"},{"location":"best-practice/principles/#guidelines","title":"Guidelines","text":"<ul> <li>One Domain Per Server: GitHub server, Database server, Email server</li> <li>Single Auth Domain: All tools should use the same authentication mechanism</li> <li>Cohesive Functionality: All tools within a server should be related</li> <li>Clear Boundaries: Easy to explain what the server does in one sentence</li> </ul>"},{"location":"best-practice/principles/#size-and-scope-guidelines","title":"Size and Scope Guidelines","text":"<ul> <li>Problem Area Focus: Restrict to one problem area (e.g., file management, API integration)</li> <li>Authentication Boundary: Tools should share the same authentication requirements</li> <li>Single Tool Scope: Each tool should have a focused, single purpose</li> <li>Avoid Mega-Servers: Don't create \"everything\" servers that handle multiple domains</li> </ul>"},{"location":"best-practice/principles/#good-examples","title":"\u2705 Good Examples","text":"<pre><code>\u2705 GitHub MCP Server\n   Tools: create_issue, get_pull_request, merge_branch, list_repositories\n\n\u2705 Database MCP Server  \n   Tools: query_table, insert_record, update_record, get_schema\n\n\u2705 Email MCP Server\n   Tools: send_email, list_inbox, search_messages, create_draft\n</code></pre>"},{"location":"best-practice/principles/#anti-patterns","title":"\u274c Anti-Patterns","text":"<pre><code>\u274c \"Everything\" MCP Server\n   Tools: create_github_issue, send_email, query_database, upload_file\n   Problem: Mixed responsibilities, hard to maintain and test\n\n\u274c Over-Specific Server\n   Tools: create_urgent_bug_report_for_frontend_team\n   Problem: Too narrow, not reusable\n</code></pre>"},{"location":"best-practice/principles/#benefits","title":"Benefits","text":"<ul> <li>Easier testing and debugging</li> <li>Clearer ownership and responsibilities  </li> <li>Better reusability across applications</li> <li>Simpler deployment and scaling</li> </ul>"},{"location":"best-practice/principles/#2-stateless-design","title":"2. Stateless Design","text":""},{"location":"best-practice/principles/#definition_1","title":"Definition","text":"<p>MCP servers should avoid storing state between requests and be designed for stateless operation.</p>"},{"location":"best-practice/principles/#guidelines_1","title":"Guidelines","text":"<ul> <li>No Persistent State: Don't store request data between calls</li> <li>Idempotent Operations: Same input produces same output</li> <li>External State Only: Use databases, APIs, or files for persistence</li> <li>Session Independence: Each request is self-contained</li> </ul>"},{"location":"best-practice/principles/#implementation","title":"Implementation","text":"<pre><code># \u2705 Good: Stateless operation\n@server.call_tool()\nasync def get_user_data(name: str, arguments: dict):\n    user_id = arguments[\"user_id\"]\n    # Fetch from external system\n    user = await database.get_user(user_id)\n    return [TextContent(type=\"text\", text=str(user))]\n\n# \u274c Bad: Storing state\nclass BadServer:\n    def __init__(self):\n        self.user_cache = {}  # Problematic state storage\n    \n    async def get_user_data(self, user_id):\n        if user_id in self.user_cache:  # Relies on internal state\n            return self.user_cache[user_id]\n</code></pre>"},{"location":"best-practice/principles/#benefits_1","title":"Benefits","text":"<ul> <li>Better scalability and load balancing</li> <li>Easier debugging and testing</li> <li>More reliable under high load</li> <li>Simpler deployment patterns</li> </ul>"},{"location":"best-practice/principles/#3-fail-fast-and-explicit","title":"3. Fail Fast and Explicit","text":""},{"location":"best-practice/principles/#definition_2","title":"Definition","text":"<p>Detect and report errors as early as possible with clear, actionable error messages.</p>"},{"location":"best-practice/principles/#guidelines_2","title":"Guidelines","text":"<ul> <li>Input Validation: Validate parameters before processing</li> <li>Clear Error Messages: Specific, actionable error descriptions  </li> <li>Structured Errors: Use consistent error formats</li> <li>Early Detection: Check preconditions before expensive operations</li> </ul>"},{"location":"best-practice/principles/#implementation_1","title":"Implementation","text":"<pre><code>@server.call_tool()\nasync def process_file(name: str, arguments: dict):\n    file_path = arguments.get(\"file_path\")\n    \n    # \u2705 Validate early and explicitly\n    if not file_path:\n        raise ValueError(\"file_path parameter is required\")\n    \n    if not file_path.endswith('.json'):\n        raise ValueError(\"Only JSON files are supported\")\n    \n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n    \n    # Continue with processing...\n</code></pre>"},{"location":"best-practice/principles/#error-response-format","title":"Error Response Format","text":"<pre><code># Use structured error responses\n{\n    \"error\": {\n        \"code\": -32602,  # JSON-RPC error code\n        \"message\": \"Invalid file format\",\n        \"data\": {\n            \"parameter\": \"file_path\",\n            \"expected\": \"*.json\",\n            \"received\": \"document.txt\"\n        }\n    }\n}\n</code></pre>"},{"location":"best-practice/principles/#4-self-documenting-apis","title":"4. Self-Documenting APIs","text":""},{"location":"best-practice/principles/#definition_3","title":"Definition","text":"<p>Tools, resources, and prompts should be self-describing through comprehensive metadata.</p>"},{"location":"best-practice/principles/#guidelines_3","title":"Guidelines","text":"<ul> <li>Descriptive Names: Clear, unambiguous tool and parameter names</li> <li>Comprehensive Descriptions: Explain purpose, behavior, and side effects</li> <li>Rich Schemas: Detailed input/output specifications</li> <li>Usage Examples: Include examples in descriptions when helpful</li> </ul>"},{"location":"best-practice/principles/#implementation_2","title":"Implementation","text":"<pre><code>Tool(\n    name=\"search_github_issues\",\n    description=\"Search for GitHub issues using flexible query criteria. Supports text search, labels, assignees, and state filters.\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"repository\": {\n                \"type\": \"string\", \n                \"description\": \"Repository in format 'owner/repo' (e.g., 'microsoft/vscode')\"\n            },\n            \"query\": {\n                \"type\": \"string\",\n                \"description\": \"Search query text. Supports GitHub search syntax.\"\n            },\n            \"state\": {\n                \"type\": \"string\",\n                \"enum\": [\"open\", \"closed\", \"all\"],\n                \"default\": \"open\",\n                \"description\": \"Issue state to filter by\"\n            },\n            \"labels\": {\n                \"type\": \"array\",\n                \"items\": {\"type\": \"string\"},\n                \"description\": \"Array of label names to filter by (AND logic)\"\n            }\n        },\n        \"required\": [\"repository\"]\n    }\n)\n</code></pre>"},{"location":"best-practice/principles/#5-graceful-degradation","title":"5. Graceful Degradation","text":""},{"location":"best-practice/principles/#definition_4","title":"Definition","text":"<p>Servers should handle errors and edge cases gracefully, providing partial results when possible.</p>"},{"location":"best-practice/principles/#guidelines_4","title":"Guidelines","text":"<ul> <li>Partial Success: Return available data even if some operations fail</li> <li>Timeout Handling: Set reasonable timeouts and handle them gracefully</li> <li>Rate Limiting: Respect API limits and retry appropriately</li> <li>Circuit Breaker: Fail fast when external services are unavailable</li> </ul>"},{"location":"best-practice/principles/#implementation_3","title":"Implementation","text":"<pre><code>@server.call_tool()\nasync def get_user_profiles(name: str, arguments: dict):\n    user_ids = arguments[\"user_ids\"]\n    results = []\n    errors = []\n    \n    for user_id in user_ids:\n        try:\n            profile = await api_client.get_profile(user_id)\n            results.append(profile)\n        except APIError as e:\n            errors.append(f\"Failed to fetch user {user_id}: {e}\")\n            continue  # Continue with other users\n    \n    # Return partial results with error summary\n    response = {\n        \"profiles\": results,\n        \"successful_count\": len(results),\n        \"total_count\": len(user_ids)\n    }\n    \n    if errors:\n        response[\"errors\"] = errors\n    \n    return [TextContent(type=\"text\", text=json.dumps(response))]\n</code></pre>"},{"location":"best-practice/principles/#6-security-by-default","title":"6. Security by Default","text":""},{"location":"best-practice/principles/#definition_5","title":"Definition","text":"<p>Implement security best practices as the default behavior, not as an optional feature.</p>"},{"location":"best-practice/principles/#guidelines_5","title":"Guidelines","text":"<ul> <li>Input Sanitization: Always validate and sanitize inputs</li> <li>Least Privilege: Request minimal necessary permissions</li> <li>No Secrets in Logs: Never log sensitive information</li> <li>Secure Defaults: Err on the side of being more restrictive</li> <li>Read-Only First: For hosting providers, default to read-only mode when possible</li> <li>Tool Filtering: Never provide tools that can cause irreversible changes in production</li> </ul>"},{"location":"best-practice/principles/#implementation_4","title":"Implementation","text":"<pre><code>import re\nfrom pathlib import Path\n\n@server.call_tool()\nasync def read_file(name: str, arguments: dict):\n    file_path = arguments[\"file_path\"]\n    \n    # \u2705 Security validations\n    # Prevent path traversal\n    if \"..\" in file_path or file_path.startswith(\"/\"):\n        raise ValueError(\"Invalid file path: path traversal not allowed\")\n    \n    # Restrict to allowed directories\n    allowed_dirs = [\"/app/data\", \"/app/uploads\"]\n    abs_path = Path(file_path).resolve()\n    \n    if not any(str(abs_path).startswith(allowed) for allowed in allowed_dirs):\n        raise ValueError(\"File access outside allowed directories\")\n    \n    # Check file size before reading\n    if abs_path.stat().st_size &gt; 10_000_000:  # 10MB limit\n        raise ValueError(\"File too large to process\")\n</code></pre>"},{"location":"best-practice/principles/#7-observable-operations","title":"7. Observable Operations","text":""},{"location":"best-practice/principles/#definition_6","title":"Definition","text":"<p>Provide visibility into server operations through structured logging, metrics, and health checks.</p>"},{"location":"best-practice/principles/#guidelines_6","title":"Guidelines","text":"<ul> <li>Structured Logging: Use consistent, machine-readable log formats</li> <li>Operation Tracing: Log request lifecycle events</li> <li>Health Endpoints: Provide health and readiness checks</li> <li>Performance Metrics: Track response times and error rates</li> </ul>"},{"location":"best-practice/principles/#implementation_5","title":"Implementation","text":"<pre><code>import logging\nimport time\nfrom contextvars import ContextVar\n\n# Set up structured logging\nlogger = logging.getLogger(__name__)\nrequest_id: ContextVar[str] = ContextVar('request_id')\n\n@server.call_tool()\nasync def process_request(name: str, arguments: dict):\n    req_id = f\"req_{int(time.time() * 1000)}\"\n    request_id.set(req_id)\n    \n    logger.info(\"tool_execution_started\", extra={\n        \"tool\": name,\n        \"request_id\": req_id,\n        \"args_size\": len(str(arguments))\n    })\n    \n    start_time = time.time()\n    try:\n        result = await execute_tool(name, arguments)\n        \n        logger.info(\"tool_execution_completed\", extra={\n            \"tool\": name,\n            \"request_id\": req_id,\n            \"duration_ms\": int((time.time() - start_time) * 1000),\n            \"success\": True\n        })\n        \n        return result\n        \n    except Exception as e:\n        logger.error(\"tool_execution_failed\", extra={\n            \"tool\": name,\n            \"request_id\": req_id,\n            \"duration_ms\": int((time.time() - start_time) * 1000),\n            \"error\": str(e),\n            \"error_type\": type(e).__name__\n        })\n        raise\n</code></pre>"},{"location":"best-practice/principles/#8-protocol-and-transport-selection","title":"8. Protocol and Transport Selection","text":""},{"location":"best-practice/principles/#definition_7","title":"Definition","text":"<p>Choose appropriate transport mechanisms based on deployment patterns and security requirements.</p>"},{"location":"best-practice/principles/#transport-recommendations","title":"Transport Recommendations","text":"<ul> <li>Recommended: Streamable HTTP: Best for production deployments and remote servers</li> <li>Use STDIO with Wrapper: For local deployments, wrap STDIO to support Streamable HTTP</li> <li>Avoid SSE: Server-Sent Events transport is deprecated</li> </ul>"},{"location":"best-practice/principles/#protocol-guidelines","title":"Protocol Guidelines","text":"<ul> <li>Remote Deployments: Always use Streamable HTTP for network accessibility</li> <li>Local Deployments: STDIO acceptable but consider HTTP wrapper for consistency</li> <li>Security: HTTP transport enables better security controls (TLS, CORS)</li> <li>Scalability: HTTP transport supports load balancing and proxying</li> </ul>"},{"location":"best-practice/principles/#implementation-considerations","title":"Implementation Considerations","text":"<pre><code># Support both transports with HTTP as primary\nclass MCPServer:\n    def __init__(self, transport_type=\"http\"):\n        self.transport_type = transport_type\n    \n    async def run(self, port=8000):\n        if self.transport_type == \"http\":\n            # Streamable HTTP transport (recommended)\n            await self.run_http_server(port)\n        elif self.transport_type == \"stdio\":\n            # STDIO with HTTP wrapper for compatibility\n            await self.run_stdio_with_http_wrapper()\n</code></pre>"},{"location":"best-practice/principles/#9-resource-efficiency","title":"9. Resource Efficiency","text":""},{"location":"best-practice/principles/#definition_8","title":"Definition","text":"<p>Use system resources responsibly and implement appropriate limits and cleanup.</p>"},{"location":"best-practice/principles/#guidelines_7","title":"Guidelines","text":"<ul> <li>Memory Limits: Set bounds on memory usage</li> <li>Connection Pooling: Reuse connections to external services</li> <li>Cleanup Resources: Properly close files, connections, and handles</li> <li>Timeout Operations: Don't let operations run indefinitely</li> </ul>"},{"location":"best-practice/principles/#implementation_6","title":"Implementation","text":"<pre><code>import asyncio\nimport aiofiles\nfrom contextlib import asynccontextmanager\n\nclass ResourceManager:\n    def __init__(self):\n        self.connection_pool = None\n        self.max_concurrent = 10\n        self.semaphore = asyncio.Semaphore(self.max_concurrent)\n    \n    @asynccontextmanager\n    async def get_connection(self):\n        async with self.semaphore:  # Limit concurrent connections\n            conn = await self.connection_pool.acquire()\n            try:\n                yield conn\n            finally:\n                await self.connection_pool.release(conn)\n    \n    async def process_file(self, file_path: str):\n        # Use async file handling with automatic cleanup\n        async with aiofiles.open(file_path, 'r') as f:\n            # Process file with memory-efficient streaming\n            async for line in f:\n                if len(line) &gt; 10000:  # Skip overly long lines\n                    continue\n                yield line.strip()\n</code></pre>"},{"location":"best-practice/principles/#applying-these-principles","title":"Applying These Principles","text":""},{"location":"best-practice/principles/#during-design","title":"During Design","text":"<ul> <li>Principle-First Design: Consider these principles when designing your MCP server</li> <li>Trade-off Decisions: When principles conflict, document your reasoning</li> <li>Regular Review: Revisit designs against these principles as requirements evolve</li> </ul>"},{"location":"best-practice/principles/#during-implementation","title":"During Implementation","text":"<ul> <li>Code Reviews: Check implementations against these principles</li> <li>Testing Strategy: Test for principle adherence (security, error handling, etc.)</li> <li>Documentation: Document how your server follows these principles</li> </ul>"},{"location":"best-practice/principles/#during-operation","title":"During Operation","text":"<ul> <li>Monitoring: Track metrics that validate principle adherence</li> <li>Incident Analysis: Review incidents for principle violations</li> <li>Continuous Improvement: Refactor when principles are violated</li> </ul>"},{"location":"best-practice/principles/#principle-trade-offs","title":"Principle Trade-offs","text":"<p>Sometimes principles conflict. Here's how to handle common tensions:</p>"},{"location":"best-practice/principles/#performance-vs-security","title":"Performance vs. Security","text":"<ul> <li>Default: Choose security, optimize later</li> <li>Exception: When performance is critical and risks are well understood</li> </ul>"},{"location":"best-practice/principles/#simplicity-vs-flexibility","title":"Simplicity vs. Flexibility","text":"<ul> <li>Default: Start simple, add flexibility when needed</li> <li>Exception: When future requirements are well known</li> </ul>"},{"location":"best-practice/principles/#stateless-vs-performance","title":"Stateless vs. Performance","text":"<ul> <li>Default: Choose stateless design</li> <li>Exception: When caching provides significant benefits and complexity is manageable</li> </ul> <p>Remember: principles guide decisions but shouldn't be followed blindly. Use judgment and document your reasoning when deviating from these principles.</p>"},{"location":"best-practice/when-to-use-mcp/","title":"When to Use MCP","text":""},{"location":"best-practice/when-to-use-mcp/#when-to-use-mcp","title":"When to Use MCP","text":""},{"location":"best-practice/when-to-use-mcp/#overview","title":"Overview","text":"<p>The Model Context Protocol (MCP) is a powerful tool for connecting AI applications with external systems, but it's not always the right solution. This guide helps you determine when MCP is the best choice for your use case.</p>"},{"location":"best-practice/when-to-use-mcp/#ideal-use-cases-for-mcp","title":"Ideal Use Cases for MCP","text":""},{"location":"best-practice/when-to-use-mcp/#tool-integration","title":"\ud83d\udd0c Tool Integration","text":"<p>Use MCP when you need to provide AI applications with executable functions:</p> <ul> <li>Database Operations: Query, insert, update database records</li> <li>File System Access: Read, write, search files and directories  </li> <li>API Integrations: Call external REST APIs, web services</li> <li>System Commands: Execute shell commands, system utilities</li> <li>Custom Business Logic: Domain-specific operations and workflows</li> </ul> <p>Example: A customer service AI that can look up order information, update tickets, and send notifications.</p>"},{"location":"best-practice/when-to-use-mcp/#contextual-data-access","title":"\ud83d\udcca Contextual Data Access","text":"<p>Use MCP when AI applications need access to rich contextual information:</p> <ul> <li>Configuration Data: Application settings, feature flags</li> <li>Reference Information: Documentation, knowledge bases, schemas</li> <li>Real-time Data: Status dashboards, metrics, live feeds</li> <li>Historical Data: Logs, analytics, audit trails</li> <li>User-specific Data: Preferences, history, personalized content</li> </ul> <p>Example: A coding assistant that can access project documentation, code standards, and deployment configurations.</p>"},{"location":"best-practice/when-to-use-mcp/#prompt-templates","title":"\ud83c\udfaf Prompt Templates","text":"<p>Use MCP when you have reusable interaction patterns:</p> <ul> <li>Domain-specific Prompts: Industry or business-specific templates</li> <li>Multi-step Workflows: Complex interaction sequences</li> <li>Few-shot Examples: Standardized example sets</li> <li>Role-based Prompts: Different prompts for different user types</li> <li>Parameterized Templates: Dynamic prompts with variables</li> </ul> <p>Example: A legal AI with templates for contract review, compliance checks, and document generation.</p>"},{"location":"best-practice/when-to-use-mcp/#when-mcp-is-the-right-choice","title":"When MCP Is the Right Choice","text":""},{"location":"best-practice/when-to-use-mcp/#you-should-use-mcp-when","title":"\u2705 You Should Use MCP When:","text":""},{"location":"best-practice/when-to-use-mcp/#standardization-matters","title":"Standardization Matters","text":"<ul> <li>You want consistent integration patterns across multiple AI applications</li> <li>You're building for an ecosystem where interoperability is important</li> <li>You need to support multiple AI models or clients</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#security-and-control-are-important","title":"Security and Control Are Important","text":"<ul> <li>You need fine-grained access control to external resources</li> <li>You want to audit and monitor AI system interactions</li> <li>You need to implement rate limiting or usage quotas</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#you-have-multiple-integrations","title":"You Have Multiple Integrations","text":"<ul> <li>You're connecting AI to 3+ external systems</li> <li>Different teams will build and maintain different integrations</li> <li>You want to avoid tight coupling between AI and external systems</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#future-flexibility-is-valued","title":"Future Flexibility Is Valued","text":"<ul> <li>You might switch AI models or providers</li> <li>You want to reuse integrations across different applications</li> <li>You need to support both local and remote deployments</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#you-might-not-need-mcp-when","title":"\u274c You Might Not Need MCP When:","text":""},{"location":"best-practice/when-to-use-mcp/#simple-direct-integrations","title":"Simple, Direct Integrations","text":"<ul> <li>Single AI application with 1-2 external systems</li> <li>Direct API calls are sufficient and straightforward</li> <li>No need for standardized patterns</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#prototype-or-proof-of-concept","title":"Prototype or Proof of Concept","text":"<ul> <li>Quick experimentation with AI capabilities</li> <li>Short-term projects with no long-term maintenance</li> <li>Learning or educational purposes</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#existing-integration-patterns","title":"Existing Integration Patterns","text":"<ul> <li>You already have robust, well-tested integration systems</li> <li>Significant investment in current architecture</li> <li>Current solution meets all requirements</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#decision-framework","title":"Decision Framework","text":""},{"location":"best-practice/when-to-use-mcp/#questions-to-ask","title":"Questions to Ask","text":"<ol> <li>Scale: Will you have more than 2-3 external integrations?</li> <li>Reusability: Will multiple AI applications use the same integrations?</li> <li>Longevity: Is this a long-term, production system?</li> <li>Team Size: Will multiple teams work on different integrations?</li> <li>Security: Do you need granular access control and auditing?</li> <li>Flexibility: Might you change AI models or deployment patterns?</li> </ol>"},{"location":"best-practice/when-to-use-mcp/#decision-matrix","title":"Decision Matrix","text":"Factor Direct Integration MCP Integration Development Speed Fast (1-2 integrations) Moderate setup, fast scaling Maintenance Overhead Low (simple cases) Moderate but standardized Flexibility Low High Reusability Low High Standardization Low High Learning Curve Low Moderate"},{"location":"best-practice/when-to-use-mcp/#common-patterns","title":"Common Patterns","text":""},{"location":"best-practice/when-to-use-mcp/#start-simple-migrate-to-mcp","title":"Start Simple, Migrate to MCP","text":"<p>Many successful projects start with direct integrations and migrate to MCP as they scale:</p> <ol> <li>Phase 1: Direct API calls for initial functionality</li> <li>Phase 2: Extract reusable components  </li> <li>Phase 3: Implement MCP servers for standardization</li> <li>Phase 4: Full MCP ecosystem with multiple servers</li> </ol>"},{"location":"best-practice/when-to-use-mcp/#hybrid-approaches","title":"Hybrid Approaches","text":"<p>You don't have to choose all-or-nothing:</p> <ul> <li>Core Functions: Use MCP for frequently used, standardized operations</li> <li>Specialized Cases: Direct integration for unique, one-off requirements</li> <li>Legacy Systems: Gradual migration as systems are updated</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#architecture-considerations","title":"Architecture Considerations","text":""},{"location":"best-practice/when-to-use-mcp/#when-mcp-adds-value","title":"When MCP Adds Value","text":"<ul> <li>Microservices Architecture: MCP servers as service adapters</li> <li>Multi-tenant Systems: Shared MCP servers with tenant isolation  </li> <li>Edge Deployments: Local MCP servers for reduced latency</li> <li>Compliance Environments: Centralized audit and control</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#when-direct-integration-is-simpler","title":"When Direct Integration Is Simpler","text":"<ul> <li>Monolithic Applications: Single codebase with embedded logic</li> <li>Simple CRUD Operations: Basic database or API interactions</li> <li>Temporary Implementations: Short-term or experimental features</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#migration-path","title":"Migration Path","text":""},{"location":"best-practice/when-to-use-mcp/#from-direct-integration-to-mcp","title":"From Direct Integration to MCP","text":"<ol> <li>Identify Patterns: Look for repeated integration code</li> <li>Extract Functions: Create standalone functions for common operations</li> <li>Implement MCP Server: Wrap functions in MCP protocol</li> <li>Gradual Migration: Move one integration at a time</li> <li>Deprecate Direct Calls: Remove old integration code</li> </ol>"},{"location":"best-practice/when-to-use-mcp/#migration-checklist","title":"Migration Checklist","text":"<ul> <li> Document existing integrations and their usage patterns</li> <li> Identify common operations that could be standardized</li> <li> Create MCP servers for high-value integrations first</li> <li> Implement side-by-side testing</li> <li> Plan rollback strategy for each migration step</li> <li> Update documentation and team training</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#success-metrics","title":"Success Metrics","text":""},{"location":"best-practice/when-to-use-mcp/#indicators-mcp-is-working-well","title":"Indicators MCP Is Working Well","text":"<ul> <li>Reduced time to add new AI integrations</li> <li>Consistent patterns across different applications</li> <li>Easier testing and debugging of AI interactions</li> <li>Improved security and compliance posture</li> <li>Higher developer satisfaction with integration development</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#warning-signs","title":"Warning Signs","text":"<ul> <li>MCP servers becoming overly complex or monolithic</li> <li>Significant performance overhead from protocol layer</li> <li>Team struggling with MCP concepts and implementation</li> <li>More time spent on MCP infrastructure than business value</li> </ul>"},{"location":"best-practice/when-to-use-mcp/#conclusion","title":"Conclusion","text":"<p>MCP shines when you need standardization, flexibility, and long-term maintainability for AI integrations. It's particularly valuable in:</p> <ul> <li>Enterprise environments with multiple AI applications</li> <li>Teams building AI ecosystems rather than single applications  </li> <li>Organizations prioritizing security and auditability</li> <li>Projects expecting significant growth in integration complexity</li> </ul> <p>Choose MCP when the long-term benefits of standardization outweigh the initial learning curve and setup overhead. For simple, short-term, or highly specialized use cases, direct integration might be more appropriate.</p> <p>Remember: you can always start simple and migrate to MCP as your needs evolve. The key is making an informed decision based on your specific context and requirements.</p>"},{"location":"deploy/","title":"Deployment Guide","text":""},{"location":"deploy/#deployment-guide","title":"Deployment Guide","text":""},{"location":"deploy/#deploying-mcp-servers-to-production","title":"Deploying MCP Servers to Production","text":"<p>This guide covers deployment strategies, platforms, and best practices for running MCP servers in production environments.</p>"},{"location":"deploy/#deployment-patterns","title":"Deployment Patterns","text":""},{"location":"deploy/#local-vs-remote-deployment","title":"Local vs Remote Deployment","text":""},{"location":"deploy/#local-deployment","title":"Local Deployment","text":"<ul> <li>Use Cases: Development, testing, trusted environments</li> <li>Transport: STDIO with optional HTTP wrapper</li> <li>Security: Container isolation, syscall restrictions</li> <li>Benefits: Lower latency, offline capability</li> </ul>"},{"location":"deploy/#remote-deployment","title":"Remote Deployment","text":"<ul> <li>Use Cases: Production, shared services, untrusted environments</li> <li>Transport: Streamable HTTP (recommended)</li> <li>Security: TLS, authentication, network isolation</li> <li>Benefits: Scalability, centralized management</li> </ul>"},{"location":"deploy/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"deploy/#rainbow-rollout-strategy","title":"Rainbow Rollout Strategy","text":"<p>Gradual deployment across multiple environments: </p><pre><code>environments:\n  development:\n    percentage: 100%\n    duration: immediate\n    validation: basic_tests\n    \n  staging:\n    percentage: 100% \n    duration: 2h\n    validation: integration_tests\n    \n  canary:\n    percentage: 5%\n    duration: 4h\n    validation: performance_monitoring\n    \n  production:\n    percentage: 100%\n    duration: 24h\n    validation: full_monitoring\n</code></pre><p></p>"},{"location":"deploy/#high-availability-deployment","title":"High Availability Deployment","text":"<pre><code>high_availability:\n  replicas: 3\n  anti_affinity: true\n  zones: [\"us-east-1a\", \"us-east-1b\", \"us-east-1c\"]\n  load_balancing: round_robin\n  health_checks:\n    enabled: true\n    interval: 30s\n    failure_threshold: 3\n</code></pre>"},{"location":"deploy/#blue-green-deployment","title":"Blue-Green Deployment","text":"<p>Switch between two identical production environments: </p><pre><code># Blue environment (current)\nblue:\n  version: 1.0.0\n  status: active\n  health: healthy\n\n# Green environment (new)\ngreen:\n  version: 1.1.0\n  status: standby\n  health: testing\n\n# Switch traffic to green after validation\n</code></pre><p></p>"},{"location":"deploy/#canary-deployment","title":"Canary Deployment","text":"<p>Gradually roll out changes to a subset of users: </p><pre><code>deployment:\n  strategy: canary\n  stages:\n    - traffic: 5%\n      duration: 1h\n    - traffic: 25%\n      duration: 2h\n    - traffic: 50%\n      duration: 4h\n    - traffic: 100%\n</code></pre><p></p>"},{"location":"deploy/#rolling-deployment","title":"Rolling Deployment","text":"<p>Update instances one at a time: </p><pre><code>deployment:\n  strategy: rolling\n  max_surge: 1\n  max_unavailable: 0\n</code></pre><p></p>"},{"location":"deploy/#container-packaging","title":"Container Packaging","text":""},{"location":"deploy/#signed-container-images","title":"Signed Container Images","text":"<p>Always use containers signed by trusted providers:</p> <pre><code># Sign container with cosign\ncosign sign --key cosign.key mcp-server:latest\n\n# Verify container signature\ncosign verify --key cosign.pub mcp-server:latest\n\n# Use admission controllers to enforce signature verification\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Policy\nmetadata:\n  name: require-signed-images\nspec:\n  rules:\n  - apiGroups: [\"\"]\n    resources: [\"pods\"]\n    verbs: [\"create\"]\n  admissionReviewVersions: [\"v1\", \"v1beta1\"]\n  sideEffects: None\n  rules:\n  - operations: [\"CREATE\"]\n    resources: [\"pods\"]\n    admissionReviewVersions: [\"v1\"]\nEOF\n</code></pre>"},{"location":"deploy/#trusted-repositories","title":"Trusted Repositories","text":"<p>Download MCP servers only from verified sources:</p> <ul> <li>Official registries: Docker Hub, ECR, GCR with verified publishers</li> <li>Organization registries: Internal container registries with signing</li> <li>Curated catalogs: Company-approved MCP server collections</li> </ul>"},{"location":"deploy/#container-security","title":"Container Security","text":"<pre><code># Multi-stage build for minimal attack surface\nFROM golang:1.21-alpine AS builder\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\nCOPY . .\nRUN CGO_ENABLED=0 GOOS=linux go build -o server\n\n# Minimal runtime image\nFROM scratch\nCOPY --from=builder /app/server /server\nCOPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/\nUSER 10001:10001\nEXPOSE 8000\nENTRYPOINT [\"/server\"]\n</code></pre>"},{"location":"deploy/#deployment-platforms","title":"Deployment Platforms","text":""},{"location":"deploy/#container-orchestration","title":"Container Orchestration","text":"<ul> <li>Kubernetes: Enterprise-grade orchestration</li> <li>Docker Swarm: Simple orchestration</li> <li>Nomad: Flexible workload orchestration</li> <li>ECS/Fargate: AWS managed containers</li> </ul>"},{"location":"deploy/#serverless","title":"Serverless","text":"<ul> <li>AWS Lambda: Event-driven compute</li> <li>Google Cloud Functions: Auto-scaling functions</li> <li>Azure Functions: Serverless compute</li> <li>Vercel/Netlify: Edge functions</li> </ul>"},{"location":"deploy/#traditional","title":"Traditional","text":"<ul> <li>VMs: Full control, higher overhead</li> <li>Bare Metal: Maximum performance</li> <li>PaaS: Heroku, Railway, Render</li> </ul>"},{"location":"deploy/#pre-deployment-checklist","title":"Pre-Deployment Checklist","text":""},{"location":"deploy/#code-readiness","title":"Code Readiness","text":"<ul> <li> All tests passing</li> <li> Security scan completed</li> <li> Dependencies updated</li> <li> Documentation current</li> <li> Version tagged</li> </ul>"},{"location":"deploy/#infrastructure","title":"Infrastructure","text":"<ul> <li> Resources provisioned</li> <li> Network configured</li> <li> SSL certificates ready</li> <li> DNS configured</li> <li> Monitoring setup</li> </ul>"},{"location":"deploy/#configuration","title":"Configuration","text":"<ul> <li> Environment variables set</li> <li> Secrets stored securely</li> <li> Feature flags configured</li> <li> Rate limits defined</li> <li> Backup configured</li> </ul>"},{"location":"deploy/#kubernetes-deployment","title":"Kubernetes Deployment","text":""},{"location":"deploy/#deployment-manifest","title":"Deployment Manifest","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mcp-server\n  labels:\n    app: mcp-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: mcp-server\n  template:\n    metadata:\n      labels:\n        app: mcp-server\n    spec:\n      containers:\n      - name: mcp-server\n        image: mcp-server:1.0.0\n        ports:\n        - containerPort: 8000\n        env:\n        - name: MCP_ENV\n          value: production\n        - name: MCP_API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: mcp-secrets\n              key: api-key\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n</code></pre>"},{"location":"deploy/#service-configuration","title":"Service Configuration","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: mcp-server-service\nspec:\n  selector:\n    app: mcp-server\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8000\n  type: LoadBalancer\n</code></pre>"},{"location":"deploy/#docker-compose-deployment","title":"Docker Compose Deployment","text":""},{"location":"deploy/#docker-composeyml","title":"docker-compose.yml","text":"<pre><code>version: '3.8'\n\nservices:\n  mcp-server:\n    image: mcp-server:latest\n    ports:\n      - \"8000:8000\"\n    environment:\n      - MCP_ENV=production\n      - MCP_DB_HOST=postgres\n    depends_on:\n      - postgres\n      - redis\n    deploy:\n      replicas: 3\n      restart_policy:\n        condition: on-failure\n        delay: 5s\n        max_attempts: 3\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 3s\n      retries: 3\n\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: mcp\n      POSTGRES_USER: mcp\n      POSTGRES_PASSWORD_FILE: /run/secrets/db_password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    secrets:\n      - db_password\n\n  redis:\n    image: redis:7-alpine\n    command: redis-server --appendonly yes\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  postgres_data:\n  redis_data:\n\nsecrets:\n  db_password:\n    file: ./secrets/db_password.txt\n</code></pre>"},{"location":"deploy/#cloud-deployment","title":"Cloud Deployment","text":""},{"location":"deploy/#aws-deployment","title":"AWS Deployment","text":"<pre><code># Build and push to ECR\naws ecr get-login-password --region us-east-1 | \\\n  docker login --username AWS --password-stdin $ECR_URI\n\ndocker build -t mcp-server .\ndocker tag mcp-server:latest $ECR_URI/mcp-server:latest\ndocker push $ECR_URI/mcp-server:latest\n\n# Deploy with ECS\naws ecs update-service \\\n  --cluster mcp-cluster \\\n  --service mcp-server \\\n  --force-new-deployment\n</code></pre>"},{"location":"deploy/#google-cloud-deployment","title":"Google Cloud Deployment","text":"<pre><code># Build and push to GCR\ngcloud builds submit --tag gcr.io/$PROJECT_ID/mcp-server\n\n# Deploy to Cloud Run\ngcloud run deploy mcp-server \\\n  --image gcr.io/$PROJECT_ID/mcp-server \\\n  --platform managed \\\n  --region us-central1 \\\n  --allow-unauthenticated\n</code></pre>"},{"location":"deploy/#azure-deployment","title":"Azure Deployment","text":"<pre><code># Build and push to ACR\naz acr build --registry $ACR_NAME --image mcp-server .\n\n# Deploy to Container Instances\naz container create \\\n  --resource-group mcp-rg \\\n  --name mcp-server \\\n  --image $ACR_NAME.azurecr.io/mcp-server:latest \\\n  --dns-name-label mcp-server \\\n  --ports 8000\n</code></pre>"},{"location":"deploy/#environment-configuration","title":"Environment Configuration","text":""},{"location":"deploy/#production-settings","title":"Production Settings","text":"<pre><code># config/production.py\nimport os\n\nclass ProductionConfig:\n    DEBUG = False\n    TESTING = False\n    \n    # Server\n    HOST = '0.0.0.0'\n    PORT = int(os.getenv('PORT', 8000))\n    WORKERS = int(os.getenv('WORKERS', 4))\n    \n    # Security\n    SECRET_KEY = os.getenv('SECRET_KEY')\n    SSL_REDIRECT = True\n    SESSION_COOKIE_SECURE = True\n    \n    # Database\n    DATABASE_URL = os.getenv('DATABASE_URL')\n    DATABASE_POOL_SIZE = 20\n    \n    # Caching\n    REDIS_URL = os.getenv('REDIS_URL')\n    CACHE_TTL = 3600\n    \n    # Monitoring\n    SENTRY_DSN = os.getenv('SENTRY_DSN')\n    LOG_LEVEL = 'INFO'\n</code></pre>"},{"location":"deploy/#load-balancing","title":"Load Balancing","text":""},{"location":"deploy/#nginx-configuration","title":"NGINX Configuration","text":"<pre><code>upstream mcp_servers {\n    least_conn;\n    server mcp1.example.com:8000 weight=3;\n    server mcp2.example.com:8000 weight=2;\n    server mcp3.example.com:8000 weight=1;\n    \n    keepalive 32;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name api.example.com;\n    \n    ssl_certificate /etc/ssl/certs/api.crt;\n    ssl_certificate_key /etc/ssl/private/api.key;\n    \n    location / {\n        proxy_pass http://mcp_servers;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        \n        # Timeouts\n        proxy_connect_timeout 60s;\n        proxy_send_timeout 60s;\n        proxy_read_timeout 60s;\n    }\n}\n</code></pre>"},{"location":"deploy/#monitoring-setup","title":"Monitoring Setup","text":""},{"location":"deploy/#prometheus-configuration","title":"Prometheus Configuration","text":"<pre><code># prometheus.yml\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'mcp-server'\n    static_configs:\n      - targets: ['mcp1:8000', 'mcp2:8000', 'mcp3:8000']\n    metrics_path: '/metrics'\n</code></pre>"},{"location":"deploy/#grafana-dashboard","title":"Grafana Dashboard","text":"<pre><code>{\n  \"dashboard\": {\n    \"title\": \"MCP Server Monitoring\",\n    \"panels\": [\n      {\n        \"title\": \"Request Rate\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(mcp_requests_total[5m])\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Error Rate\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(mcp_errors_total[5m])\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Response Time\",\n        \"targets\": [\n          {\n            \"expr\": \"histogram_quantile(0.95, mcp_request_duration_seconds)\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"deploy/#post-deployment","title":"Post-Deployment","text":""},{"location":"deploy/#smoke-tests","title":"Smoke Tests","text":"<pre><code>#!/bin/bash\n# smoke_test.sh\n\nset -e\n\nURL=\"${1:-http://localhost:8000}\"\n\necho \"Running smoke tests for $URL\"\n\n# Health check\ncurl -f \"$URL/health\" || exit 1\n\n# Tool listing\ncurl -f \"$URL/mcp\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}' || exit 1\n\n# Sample tool execution\ncurl -f \"$URL/mcp\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"echo\",\"arguments\":{\"text\":\"test\"}},\"id\":2}' || exit 1\n\necho \"Smoke tests passed!\"\n</code></pre>"},{"location":"deploy/#rollback-procedure","title":"Rollback Procedure","text":"<pre><code>#!/bin/bash\n# rollback.sh\n\nPREVIOUS_VERSION=\"${1:-1.0.0}\"\n\necho \"Rolling back to version $PREVIOUS_VERSION\"\n\n# Kubernetes rollback\nkubectl rollout undo deployment/mcp-server\n\n# Docker rollback\ndocker service update --image mcp-server:$PREVIOUS_VERSION mcp-server\n\n# Verify rollback\n./smoke_test.sh\n</code></pre>"},{"location":"deploy/#next-steps","title":"Next Steps","text":"<ul> <li>\u2601\ufe0f Cloud Deployment Details</li> <li>\ud83c\udfed On-Premise Deployment</li> <li>\u2638\ufe0f Kubernetes Deep Dive</li> <li>\ud83d\udd04 CI/CD Pipelines</li> <li>\ud83c\udf10 Edge Deployment</li> </ul>"},{"location":"develop/","title":"Development Guide","text":""},{"location":"develop/#development-guide","title":"Development Guide","text":""},{"location":"develop/#building-mcp-servers","title":"Building MCP Servers","text":"<p>This guide covers development best practices for creating MCP servers in various programming languages.</p>"},{"location":"develop/#language-support","title":"Language Support","text":"<p>MCP has official SDKs and community support for multiple languages:</p>"},{"location":"develop/#official-sdks","title":"Official SDKs","text":"<ul> <li>\ud83d\udc0d Python - Full-featured SDK with FastMCP framework</li> <li>\ud83d\udcdc JavaScript/TypeScript - Node.js and browser support</li> <li>\ud83d\udc39 Go - High-performance native implementation</li> </ul>"},{"location":"develop/#community-sdks","title":"Community SDKs","text":"<ul> <li>\ud83e\udd80 Rust - Systems programming with safety</li> <li>\u2615 Java - Enterprise applications</li> <li>\ud83d\udc8e Ruby - Web applications</li> </ul>"},{"location":"develop/#development-workflow","title":"Development Workflow","text":""},{"location":"develop/#1-setup-environment","title":"1. Setup Environment","text":"<pre><code># Create project directory\nmkdir my-mcp-server\ncd my-mcp-server\n\n# Initialize version control\ngit init\n\n# Setup language-specific environment\nmake venv  # Python\nnpm init   # JavaScript\ngo mod init # Go\n</code></pre>"},{"location":"develop/#2-project-structure","title":"2. Project Structure","text":"<pre><code>my-mcp-server/\n\u251c\u2500\u2500 src/              # Source code\n\u251c\u2500\u2500 tests/            # Test files\n\u251c\u2500\u2500 docs/             # Documentation\n\u251c\u2500\u2500 Makefile          # Build automation\n\u251c\u2500\u2500 Containerfile     # Container definition\n\u251c\u2500\u2500 README.md         # Project documentation\n\u2514\u2500\u2500 pyproject.toml    # Dependencies (Python)\n</code></pre>"},{"location":"develop/#3-development-cycle","title":"3. Development Cycle","text":"<ol> <li>Write code with type hints/annotations</li> <li>Add comprehensive tests</li> <li>Document with docstrings</li> <li>Run linters and formatters</li> <li>Build and test locally</li> <li>Container testing</li> <li>Integration testing</li> </ol>"},{"location":"develop/#core-development-principles","title":"Core Development Principles","text":""},{"location":"develop/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Each MCP server should have a clear, focused purpose: - \u2705 GitHub integration server - \u2705 Database connector server - \u274c GitHub + Jira + Database server</p>"},{"location":"develop/#2-type-safety","title":"2. Type Safety","text":"<p>Use strong typing for all interfaces: </p><pre><code>def process_data(input: str, count: int) -&gt; dict[str, Any]:\n    \"\"\"Process input data with type hints\"\"\"\n</code></pre><p></p>"},{"location":"develop/#3-error-handling","title":"3. Error Handling","text":"<p>Implement comprehensive error handling: </p><pre><code>try:\n    result = risky_operation()\nexcept SpecificError as e:\n    logger.error(f\"Operation failed: {e}\")\n    raise McpError(\"User-friendly error message\")\n</code></pre><p></p>"},{"location":"develop/#4-input-validation","title":"4. Input Validation","text":"<p>Always validate and sanitize inputs: </p><pre><code>from pydantic import BaseModel, validator\n\nclass ToolInput(BaseModel):\n    text: str\n    \n    @validator('text')\n    def validate_text(cls, v):\n        if not v.strip():\n            raise ValueError(\"Text cannot be empty\")\n        return v\n</code></pre><p></p>"},{"location":"develop/#testing-strategy","title":"Testing Strategy","text":""},{"location":"develop/#unit-tests","title":"Unit Tests","text":"<p>Test individual functions and methods: </p><pre><code>def test_tool_function():\n    result = my_tool(\"input\")\n    assert result == \"expected\"\n</code></pre><p></p>"},{"location":"develop/#integration-tests","title":"Integration Tests","text":"<p>Test server endpoints and protocols: </p><pre><code>curl -X POST http://localhost:8000/mcp \\\n  -d '{\"method\": \"tools/call\", ...}'\n</code></pre><p></p>"},{"location":"develop/#end-to-end-tests","title":"End-to-End Tests","text":"<p>Test complete workflows through gateway: </p><pre><code>mcp-cli cmd --server my-server \\\n  --tool my_tool --tool-args '{...}'\n</code></pre><p></p>"},{"location":"develop/#performance-considerations","title":"Performance Considerations","text":""},{"location":"develop/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Async Operations: Use async/await for I/O operations</li> <li>Connection Pooling: Reuse database/API connections</li> <li>Caching: Cache frequently accessed data</li> <li>Batch Processing: Group operations when possible</li> <li>Resource Limits: Set timeouts and memory limits</li> </ol>"},{"location":"develop/#monitoring","title":"Monitoring","text":"<ul> <li>Request/response times</li> <li>Error rates</li> <li>Resource usage</li> <li>Concurrent connections</li> </ul>"},{"location":"develop/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Never hardcode secrets</li> <li>Validate all inputs</li> <li>Use environment variables</li> <li>Implement rate limiting</li> <li>Log security events</li> <li>Regular dependency updates</li> </ol>"},{"location":"develop/#documentation-requirements","title":"Documentation Requirements","text":"<p>Every MCP server must include: - README with setup instructions - API documentation - Environment variable reference - Example usage - Troubleshooting guide</p>"},{"location":"develop/#quick-links","title":"Quick Links","text":"<ul> <li>\ud83c\udfaf Common Patterns</li> <li>\ud83d\udd27 Development Tools</li> <li>\ud83d\udcda Tutorials</li> <li>\ud83e\uddea Testing Guide</li> <li>\ud83d\udce6 Packaging Guide</li> </ul>"},{"location":"develop/patterns/","title":"Patterns","text":""},{"location":"develop/patterns/#development-patterns","title":"Development Patterns","text":""},{"location":"develop/patterns/#common-mcp-development-patterns-and-practices","title":"Common MCP Development Patterns and Practices","text":"<p>This guide covers reusable patterns, architectural approaches, and design strategies for building robust MCP servers and clients.</p>"},{"location":"develop/patterns/#architectural-patterns","title":"Architectural Patterns","text":""},{"location":"develop/patterns/#layered-architecture","title":"Layered Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Presentation Layer     \u2502  MCP Protocol Handlers\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          Business Logic Layer   \u2502  Tool Implementations\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          Service Layer          \u2502  External API Integrations  \n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          Data Access Layer      \u2502  Database, Cache, Storage\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"develop/patterns/#implementation-example","title":"Implementation Example","text":"<pre><code># Presentation Layer - MCP Protocol Handlers\nclass MCPHandlers:\n    def __init__(self, tool_service: ToolService):\n        self.tool_service = tool_service\n    \n    async def handle_list_tools(self) -&gt; List[Tool]:\n        return await self.tool_service.list_available_tools()\n    \n    async def handle_call_tool(self, name: str, args: dict) -&gt; List[TextContent]:\n        return await self.tool_service.execute_tool(name, args)\n\n# Business Logic Layer - Tool Orchestration\nclass ToolService:\n    def __init__(self, tool_registry: ToolRegistry, validator: InputValidator):\n        self.registry = tool_registry\n        self.validator = validator\n    \n    async def execute_tool(self, name: str, args: dict) -&gt; List[TextContent]:\n        # Validate inputs\n        await self.validator.validate(name, args)\n        \n        # Get tool implementation\n        tool = await self.registry.get_tool(name)\n        \n        # Execute with error handling\n        return await self.safe_execute(tool, args)\n\n# Service Layer - External Integrations\nclass GitHubService:\n    def __init__(self, client: HTTPClient, auth: AuthProvider):\n        self.client = client\n        self.auth = auth\n    \n    async def create_issue(self, repo: str, title: str, body: str) -&gt; dict:\n        headers = await self.auth.get_headers()\n        return await self.client.post(f\"/repos/{repo}/issues\", {\n            \"title\": title,\n            \"body\": body\n        }, headers=headers)\n\n# Data Access Layer - Storage Abstraction\nclass IssueRepository:\n    def __init__(self, db: Database):\n        self.db = db\n    \n    async def store_issue_ref(self, tool_call_id: str, issue_url: str):\n        await self.db.execute(\n            \"INSERT INTO issue_refs (tool_call_id, issue_url) VALUES (?, ?)\",\n            tool_call_id, issue_url\n        )\n</code></pre>"},{"location":"develop/patterns/#plugin-architecture","title":"Plugin Architecture","text":"<pre><code># Plugin interface\nclass MCPPlugin(ABC):\n    @abstractmethod\n    def get_name(self) -&gt; str:\n        pass\n    \n    @abstractmethod\n    def get_tools(self) -&gt; List[Tool]:\n        pass\n    \n    @abstractmethod\n    async def initialize(self, config: dict) -&gt; None:\n        pass\n    \n    @abstractmethod\n    async def cleanup(self) -&gt; None:\n        pass\n\n# Plugin manager\nclass PluginManager:\n    def __init__(self):\n        self.plugins: Dict[str, MCPPlugin] = {}\n        self.tools: Dict[str, Tool] = {}\n    \n    async def load_plugin(self, plugin_class: Type[MCPPlugin], config: dict):\n        plugin = plugin_class()\n        await plugin.initialize(config)\n        \n        self.plugins[plugin.get_name()] = plugin\n        \n        # Register plugin tools\n        for tool in plugin.get_tools():\n            self.tools[tool.name] = tool\n    \n    async def unload_plugin(self, name: str):\n        if name in self.plugins:\n            plugin = self.plugins[name]\n            \n            # Unregister tools\n            for tool in plugin.get_tools():\n                self.tools.pop(tool.name, None)\n            \n            await plugin.cleanup()\n            del self.plugins[name]\n    \n    def get_available_tools(self) -&gt; List[Tool]:\n        return list(self.tools.values())\n\n# Example plugin implementation\nclass GitHubPlugin(MCPPlugin):\n    def get_name(self) -&gt; str:\n        return \"github\"\n    \n    def get_tools(self) -&gt; List[Tool]:\n        return [\n            CreateIssueTool(self.github_client),\n            SearchRepositoriesTool(self.github_client),\n            GetPullRequestTool(self.github_client)\n        ]\n    \n    async def initialize(self, config: dict) -&gt; None:\n        self.github_client = GitHubClient(\n            token=config[\"token\"],\n            base_url=config.get(\"base_url\", \"https://api.github.com\")\n        )\n        await self.github_client.verify_auth()\n    \n    async def cleanup(self) -&gt; None:\n        await self.github_client.close()\n</code></pre>"},{"location":"develop/patterns/#tool-design-patterns","title":"Tool Design Patterns","text":""},{"location":"develop/patterns/#command-pattern","title":"Command Pattern","text":"<pre><code>class Command(ABC):\n    @abstractmethod\n    async def execute(self) -&gt; Any:\n        pass\n    \n    @abstractmethod\n    async def undo(self) -&gt; Any:\n        pass\n    \n    @abstractmethod\n    def get_description(self) -&gt; str:\n        pass\n\nclass CreateFileCommand(Command):\n    def __init__(self, file_path: str, content: str):\n        self.file_path = file_path\n        self.content = content\n        self.existed_before = False\n        self.previous_content = None\n    \n    async def execute(self) -&gt; Any:\n        self.existed_before = Path(self.file_path).exists()\n        if self.existed_before:\n            self.previous_content = Path(self.file_path).read_text()\n        \n        Path(self.file_path).write_text(self.content)\n        return f\"File created: {self.file_path}\"\n    \n    async def undo(self) -&gt; Any:\n        if self.existed_before and self.previous_content is not None:\n            Path(self.file_path).write_text(self.previous_content)\n            return f\"File restored: {self.file_path}\"\n        elif Path(self.file_path).exists():\n            Path(self.file_path).unlink()\n            return f\"File deleted: {self.file_path}\"\n    \n    def get_description(self) -&gt; str:\n        return f\"Create file {self.file_path}\"\n\nclass CommandExecutor:\n    def __init__(self):\n        self.history: List[Command] = []\n    \n    async def execute(self, command: Command) -&gt; Any:\n        result = await command.execute()\n        self.history.append(command)\n        return result\n    \n    async def undo_last(self) -&gt; Any:\n        if not self.history:\n            raise ValueError(\"No commands to undo\")\n        \n        command = self.history.pop()\n        return await command.undo()\n</code></pre>"},{"location":"develop/patterns/#factory-pattern-for-tool-creation","title":"Factory Pattern for Tool Creation","text":"<pre><code>class ToolFactory:\n    _registry: Dict[str, Callable[..., Tool]] = {}\n    \n    @classmethod\n    def register(cls, tool_type: str):\n        def decorator(tool_class: Type[Tool]):\n            cls._registry[tool_type] = tool_class\n            return tool_class\n        return decorator\n    \n    @classmethod\n    def create_tool(cls, tool_type: str, **kwargs) -&gt; Tool:\n        if tool_type not in cls._registry:\n            raise ValueError(f\"Unknown tool type: {tool_type}\")\n        \n        tool_class = cls._registry[tool_type]\n        return tool_class(**kwargs)\n    \n    @classmethod\n    def list_available_types(cls) -&gt; List[str]:\n        return list(cls._registry.keys())\n\n# Usage\n@ToolFactory.register(\"github_issue\")\nclass GitHubIssueTool(Tool):\n    def __init__(self, github_client: GitHubClient):\n        self.github_client = github_client\n\n@ToolFactory.register(\"file_read\")\nclass FileReadTool(Tool):\n    def __init__(self, allowed_paths: List[str]):\n        self.allowed_paths = allowed_paths\n\n# Create tools dynamically\ngithub_tool = ToolFactory.create_tool(\"github_issue\", github_client=client)\nfile_tool = ToolFactory.create_tool(\"file_read\", allowed_paths=[\"/tmp\", \"/var/data\"])\n</code></pre>"},{"location":"develop/patterns/#strategy-pattern-for-different-execution-modes","title":"Strategy Pattern for Different Execution Modes","text":"<pre><code>class ExecutionStrategy(ABC):\n    @abstractmethod\n    async def execute(self, tool: Tool, arguments: dict) -&gt; List[Content]:\n        pass\n\nclass SynchronousExecution(ExecutionStrategy):\n    async def execute(self, tool: Tool, arguments: dict) -&gt; List[Content]:\n        return await tool.execute(arguments)\n\nclass AsynchronousExecution(ExecutionStrategy):\n    def __init__(self, task_queue: TaskQueue):\n        self.task_queue = task_queue\n    \n    async def execute(self, tool: Tool, arguments: dict) -&gt; List[Content]:\n        task_id = await self.task_queue.enqueue(tool, arguments)\n        return [TextContent(\n            type=\"text\",\n            text=f\"Task queued with ID: {task_id}\"\n        )]\n\nclass RetryExecution(ExecutionStrategy):\n    def __init__(self, base_strategy: ExecutionStrategy, max_retries: int = 3):\n        self.base_strategy = base_strategy\n        self.max_retries = max_retries\n    \n    async def execute(self, tool: Tool, arguments: dict) -&gt; List[Content]:\n        last_error = None\n        \n        for attempt in range(self.max_retries + 1):\n            try:\n                return await self.base_strategy.execute(tool, arguments)\n            except Exception as e:\n                last_error = e\n                if attempt &lt; self.max_retries:\n                    await asyncio.sleep(2 ** attempt)  # Exponential backoff\n                continue\n        \n        raise last_error\n\nclass ToolExecutor:\n    def __init__(self, strategy: ExecutionStrategy):\n        self.strategy = strategy\n    \n    async def execute_tool(self, tool: Tool, arguments: dict) -&gt; List[Content]:\n        return await self.strategy.execute(tool, arguments)\n    \n    def set_strategy(self, strategy: ExecutionStrategy):\n        self.strategy = strategy\n</code></pre>"},{"location":"develop/patterns/#resource-management-patterns","title":"Resource Management Patterns","text":""},{"location":"develop/patterns/#resource-pool-pattern","title":"Resource Pool Pattern","text":"<pre><code>class ResourcePool(Generic[T]):\n    def __init__(self, factory: Callable[[], T], max_size: int = 10):\n        self.factory = factory\n        self.max_size = max_size\n        self._pool: List[T] = []\n        self._in_use: Set[T] = set()\n        self._lock = asyncio.Lock()\n    \n    async def acquire(self) -&gt; T:\n        async with self._lock:\n            if self._pool:\n                resource = self._pool.pop()\n            elif len(self._in_use) &lt; self.max_size:\n                resource = self.factory()\n            else:\n                # Wait for resource to become available\n                while not self._pool:\n                    await asyncio.sleep(0.1)\n                resource = self._pool.pop()\n            \n            self._in_use.add(resource)\n            return resource\n    \n    async def release(self, resource: T):\n        async with self._lock:\n            if resource in self._in_use:\n                self._in_use.remove(resource)\n                self._pool.append(resource)\n    \n    @asynccontextmanager\n    async def get_resource(self) -&gt; AsyncGenerator[T, None]:\n        resource = await self.acquire()\n        try:\n            yield resource\n        finally:\n            await self.release(resource)\n\n# Usage with database connections\nclass DatabaseConnectionPool(ResourcePool[Database]):\n    def __init__(self, connection_string: str, max_size: int = 10):\n        super().__init__(\n            factory=lambda: Database(connection_string),\n            max_size=max_size\n        )\n\n# Tool using connection pool\nclass DatabaseQueryTool(Tool):\n    def __init__(self, db_pool: DatabaseConnectionPool):\n        self.db_pool = db_pool\n    \n    async def execute(self, arguments: dict) -&gt; List[Content]:\n        query = arguments[\"query\"]\n        \n        async with self.db_pool.get_resource() as db:\n            results = await db.execute(query)\n            return [TextContent(\n                type=\"text\",\n                text=json.dumps(results, indent=2)\n            )]\n</code></pre>"},{"location":"develop/patterns/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>from enum import Enum\nfrom datetime import datetime, timedelta\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    def __init__(\n        self,\n        failure_threshold: int = 5,\n        recovery_timeout: int = 60,\n        expected_exception: Type[Exception] = Exception\n    ):\n        self.failure_threshold = failure_threshold\n        self.recovery_timeout = recovery_timeout\n        self.expected_exception = expected_exception\n        \n        self.failure_count = 0\n        self.last_failure_time: Optional[datetime] = None\n        self.state = CircuitState.CLOSED\n    \n    async def call(self, func: Callable, *args, **kwargs):\n        if self.state == CircuitState.OPEN:\n            if self._should_attempt_reset():\n                self.state = CircuitState.HALF_OPEN\n            else:\n                raise Exception(\"Circuit breaker is OPEN\")\n        \n        try:\n            result = await func(*args, **kwargs)\n            self._on_success()\n            return result\n        except self.expected_exception as e:\n            self._on_failure()\n            raise e\n    \n    def _should_attempt_reset(self) -&gt; bool:\n        return (\n            self.last_failure_time is not None and\n            datetime.now() - self.last_failure_time &gt;= timedelta(seconds=self.recovery_timeout)\n        )\n    \n    def _on_success(self):\n        self.failure_count = 0\n        self.state = CircuitState.CLOSED\n    \n    def _on_failure(self):\n        self.failure_count += 1\n        self.last_failure_time = datetime.now()\n        \n        if self.failure_count &gt;= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\n# Tool with circuit breaker\nclass ResilientAPITool(Tool):\n    def __init__(self, api_client: APIClient):\n        self.api_client = api_client\n        self.circuit_breaker = CircuitBreaker(\n            failure_threshold=3,\n            recovery_timeout=30,\n            expected_exception=APIError\n        )\n    \n    async def execute(self, arguments: dict) -&gt; List[Content]:\n        try:\n            result = await self.circuit_breaker.call(\n                self.api_client.make_request,\n                arguments[\"endpoint\"],\n                arguments.get(\"data\")\n            )\n            return [TextContent(type=\"text\", text=str(result))]\n        except Exception as e:\n            return [TextContent(\n                type=\"text\",\n                text=f\"Service temporarily unavailable: {str(e)}\"\n            )]\n</code></pre>"},{"location":"develop/patterns/#event-driven-patterns","title":"Event-Driven Patterns","text":""},{"location":"develop/patterns/#observer-pattern-for-tool-execution-events","title":"Observer Pattern for Tool Execution Events","text":"<pre><code>class ToolExecutionEvent:\n    def __init__(self, tool_name: str, arguments: dict, result: Optional[Any] = None, error: Optional[Exception] = None):\n        self.tool_name = tool_name\n        self.arguments = arguments\n        self.result = result\n        self.error = error\n        self.timestamp = datetime.utcnow()\n\nclass ToolEventObserver(ABC):\n    @abstractmethod\n    async def on_tool_started(self, event: ToolExecutionEvent):\n        pass\n    \n    @abstractmethod\n    async def on_tool_completed(self, event: ToolExecutionEvent):\n        pass\n    \n    @abstractmethod\n    async def on_tool_failed(self, event: ToolExecutionEvent):\n        pass\n\nclass MetricsObserver(ToolEventObserver):\n    def __init__(self):\n        self.execution_counts: Dict[str, int] = defaultdict(int)\n        self.error_counts: Dict[str, int] = defaultdict(int)\n    \n    async def on_tool_started(self, event: ToolExecutionEvent):\n        self.execution_counts[event.tool_name] += 1\n    \n    async def on_tool_completed(self, event: ToolExecutionEvent):\n        # Log successful completion metrics\n        pass\n    \n    async def on_tool_failed(self, event: ToolExecutionEvent):\n        self.error_counts[event.tool_name] += 1\n\nclass LoggingObserver(ToolEventObserver):\n    def __init__(self, logger: logging.Logger):\n        self.logger = logger\n    \n    async def on_tool_started(self, event: ToolExecutionEvent):\n        self.logger.info(f\"Tool {event.tool_name} started with args: {event.arguments}\")\n    \n    async def on_tool_completed(self, event: ToolExecutionEvent):\n        self.logger.info(f\"Tool {event.tool_name} completed successfully\")\n    \n    async def on_tool_failed(self, event: ToolExecutionEvent):\n        self.logger.error(f\"Tool {event.tool_name} failed: {event.error}\")\n\nclass ObservableToolExecutor:\n    def __init__(self):\n        self.observers: List[ToolEventObserver] = []\n    \n    def add_observer(self, observer: ToolEventObserver):\n        self.observers.append(observer)\n    \n    def remove_observer(self, observer: ToolEventObserver):\n        self.observers.remove(observer)\n    \n    async def execute_tool(self, tool: Tool, arguments: dict) -&gt; List[Content]:\n        event = ToolExecutionEvent(tool.name, arguments)\n        \n        # Notify start\n        await self._notify_observers('on_tool_started', event)\n        \n        try:\n            result = await tool.execute(arguments)\n            event.result = result\n            \n            # Notify completion\n            await self._notify_observers('on_tool_completed', event)\n            \n            return result\n        except Exception as e:\n            event.error = e\n            \n            # Notify failure\n            await self._notify_observers('on_tool_failed', event)\n            \n            raise e\n    \n    async def _notify_observers(self, method_name: str, event: ToolExecutionEvent):\n        for observer in self.observers:\n            try:\n                method = getattr(observer, method_name)\n                await method(event)\n            except Exception as e:\n                # Don't let observer errors break tool execution\n                logging.error(f\"Observer error: {e}\")\n</code></pre>"},{"location":"develop/patterns/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"develop/patterns/#configuration-builder-pattern","title":"Configuration Builder Pattern","text":"<pre><code>class ServerConfigBuilder:\n    def __init__(self):\n        self.config = {\n            \"server\": {},\n            \"tools\": {},\n            \"logging\": {},\n            \"security\": {}\n        }\n    \n    def with_server_name(self, name: str):\n        self.config[\"server\"][\"name\"] = name\n        return self\n    \n    def with_transport(self, transport: str, **options):\n        self.config[\"server\"][\"transport\"] = {\n            \"type\": transport,\n            **options\n        }\n        return self\n    \n    def with_tool(self, tool_name: str, **tool_config):\n        self.config[\"tools\"][tool_name] = tool_config\n        return self\n    \n    def with_logging(self, level: str = \"INFO\", format: str = \"json\"):\n        self.config[\"logging\"] = {\n            \"level\": level,\n            \"format\": format\n        }\n        return self\n    \n    def with_security(self, **security_config):\n        self.config[\"security\"].update(security_config)\n        return self\n    \n    def build(self) -&gt; dict:\n        # Validate required fields\n        if \"name\" not in self.config[\"server\"]:\n            raise ValueError(\"Server name is required\")\n        \n        return self.config.copy()\n\n# Usage\nconfig = (ServerConfigBuilder()\n    .with_server_name(\"my-mcp-server\")\n    .with_transport(\"http\", port=8000, host=\"0.0.0.0\")\n    .with_tool(\"github\", token=\"ghp_xxx\", base_url=\"https://api.github.com\")\n    .with_logging(\"DEBUG\", \"text\")\n    .with_security(require_auth=True, max_requests_per_minute=60)\n    .build())\n</code></pre> <p>These patterns provide proven solutions for common challenges in MCP server development, promoting code reusability, maintainability, and scalability.</p>"},{"location":"develop/tools/","title":"Tools","text":""},{"location":"develop/tools/#development-tools","title":"Development Tools","text":""},{"location":"develop/tools/#mcp-development-tools-and-utilities","title":"MCP Development Tools and Utilities","text":"<p>Essential tools, libraries, and utilities for efficient MCP server development across different languages and platforms.</p>"},{"location":"develop/tools/#code-editors-and-ides","title":"Code Editors and IDEs","text":""},{"location":"develop/tools/#vs-code-extensions","title":"VS Code Extensions","text":"<pre><code>// .vscode/extensions.json\n{\n  \"recommendations\": [\n    \"ms-vscode.vscode-json\",\n    \"ms-python.python\",\n    \"ms-python.pylint\",\n    \"ms-python.black-formatter\",\n    \"golang.go\",\n    \"rust-lang.rust-analyzer\",\n    \"bradlc.vscode-tailwindcss\",\n    \"ms-vscode.vscode-typescript-next\",\n    \"formulahendry.auto-rename-tag\",\n    \"esbenp.prettier-vscode\",\n    \"redhat.vscode-yaml\"\n  ]\n}\n</code></pre>"},{"location":"develop/tools/#vs-code-settings","title":"VS Code Settings","text":"<pre><code>// .vscode/settings.json\n{\n  \"python.defaultInterpreterPath\": \"./venv/bin/python\",\n  \"python.linting.enabled\": true,\n  \"python.linting.pylintEnabled\": true,\n  \"python.formatting.provider\": \"black\",\n  \"go.formatTool\": \"goimports\",\n  \"go.lintTool\": \"golangci-lint\",\n  \"rust-analyzer.checkOnSave.command\": \"clippy\",\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true,\n    \"source.fixAll\": true\n  }\n}\n</code></pre>"},{"location":"develop/tools/#intellijpycharm-configuration","title":"IntelliJ/PyCharm Configuration","text":"<pre><code>&lt;!-- .idea/inspectionProfiles/Project_Default.xml --&gt;\n&lt;component name=\"InspectionProjectProfileManager\"&gt;\n  &lt;profile version=\"1.0\"&gt;\n    &lt;option name=\"myName\" value=\"Project Default\" /&gt;\n    &lt;inspection_tool class=\"PyPackageRequirementsInspection\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\"&gt;\n      &lt;option name=\"ignoredPackages\"&gt;\n        &lt;value&gt;\n          &lt;list size=\"0\" /&gt;\n        &lt;/value&gt;\n      &lt;/option&gt;\n    &lt;/inspection_tool&gt;\n  &lt;/profile&gt;\n&lt;/component&gt;\n</code></pre>"},{"location":"develop/tools/#language-specific-tools","title":"Language-Specific Tools","text":""},{"location":"develop/tools/#python-development","title":"Python Development","text":"<pre><code># Install development tools\npip install black pylint mypy pytest pytest-cov\npip install pre-commit bandit safety\n\n# pyproject.toml configuration\n[tool.black]\nline-length = 100\ntarget-version = ['py38', 'py39', 'py310', 'py311']\n\n[tool.pylint.messages_control]\ndisable = [\"C0111\", \"R0903\"]\n\n[tool.mypy]\npython_version = \"3.8\"\nstrict = true\nignore_missing_imports = true\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\naddopts = \"-ra -q --strict-markers --strict-config\"\ntestpaths = [\"tests\"]\n</code></pre>"},{"location":"develop/tools/#go-development-tools","title":"Go Development Tools","text":"<pre><code># Install Go tools\ngo install golang.org/x/tools/cmd/goimports@latest\ngo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\ngo install github.com/securecodewarrior/sast-scan@latest\ngo install honnef.co/go/tools/cmd/staticcheck@latest\n\n# Install testing tools\ngo install github.com/golang/mock/mockgen@latest\ngo install gotest.tools/gotestsum@latest\n</code></pre>"},{"location":"develop/tools/#javascripttypescript-tools","title":"JavaScript/TypeScript Tools","text":"<pre><code># Install development dependencies\nnpm install -D typescript @types/node\nnpm install -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin\nnpm install -D prettier\nnpm install -D jest @types/jest ts-jest\nnpm install -D nodemon ts-node\n\n# Package.json scripts\n\"scripts\": {\n  \"dev\": \"nodemon src/index.ts\",\n  \"build\": \"tsc\",\n  \"test\": \"jest\",\n  \"test:watch\": \"jest --watch\",\n  \"lint\": \"eslint src/**/*.ts\",\n  \"lint:fix\": \"eslint src/**/*.ts --fix\",\n  \"format\": \"prettier --write src/**/*.ts\"\n}\n</code></pre>"},{"location":"develop/tools/#rust-development","title":"Rust Development","text":"<pre><code># Install Rust tools\nrustup component add rustfmt clippy\ncargo install cargo-watch\ncargo install cargo-audit\ncargo install cargo-outdated\n\n# Cargo.toml configuration\n[profile.dev]\ndebug = true\n\n[profile.release]\nlto = true\ncodegen-units = 1\npanic = \"abort\"\n</code></pre>"},{"location":"develop/tools/#testing-tools","title":"Testing Tools","text":""},{"location":"develop/tools/#unit-testing-frameworks","title":"Unit Testing Frameworks","text":"<pre><code># Python - pytest configuration\n# tests/conftest.py\nimport pytest\nfrom mcp_server import create_server\n\n@pytest.fixture\ndef test_client():\n    server = create_server(test_mode=True)\n    return server.test_client()\n\n@pytest.fixture\ndef mock_database():\n    \"\"\"Mock database for testing.\"\"\"\n    return MockDatabase()\n</code></pre>"},{"location":"develop/tools/#integration-testing","title":"Integration Testing","text":"<pre><code>// JavaScript/TypeScript - Jest configuration\n// jest.config.js\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['&lt;rootDir&gt;/src', '&lt;rootDir&gt;/tests'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n  ],\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n};\n</code></pre>"},{"location":"develop/tools/#load-testing-tools","title":"Load Testing Tools","text":"<pre><code># k6 load testing script\n# scripts/load-test.js\nimport http from 'k6/http';\nimport { check, sleep } from 'k6';\n\nexport let options = {\n  stages: [\n    { duration: '2m', target: 100 },\n    { duration: '5m', target: 100 },\n    { duration: '2m', target: 200 },\n    { duration: '5m', target: 200 },\n    { duration: '2m', target: 0 },\n  ],\n};\n\nexport default function() {\n  let response = http.get('http://localhost:8000/health');\n  check(response, {\n    'status is 200': (r) =&gt; r.status === 200,\n    'response time &lt; 500ms': (r) =&gt; r.timings.duration &lt; 500,\n  });\n  sleep(1);\n}\n</code></pre>"},{"location":"develop/tools/#development-utilities","title":"Development Utilities","text":""},{"location":"develop/tools/#docker-development-environment","title":"Docker Development Environment","text":"<pre><code># docker/dev.Dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Install development dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    git \\\n    curl \\\n    vim \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install Python dev tools\nCOPY requirements-dev.txt .\nRUN pip install -r requirements-dev.txt\n\n# Set up development environment\nENV PYTHONPATH=/app\nENV MCP_ENV=development\n\nEXPOSE 8000\nCMD [\"python\", \"-m\", \"debugpy\", \"--listen\", \"0.0.0.0:5678\", \"--wait-for-client\", \"-m\", \"mcp_server\"]\n</code></pre>"},{"location":"develop/tools/#docker-compose-for-development","title":"Docker Compose for Development","text":"<pre><code># docker-compose.dev.yml\nversion: '3.8'\n\nservices:\n  mcp-server:\n    build:\n      context: .\n      dockerfile: docker/dev.Dockerfile\n    volumes:\n      - .:/app\n      - /app/__pycache__\n    ports:\n      - \"8000:8000\"\n      - \"5678:5678\"  # debugpy\n    environment:\n      - MCP_LOG_LEVEL=debug\n      - MCP_DATABASE_URL=postgresql://user:pass@postgres:5432/mcpdev\n    depends_on:\n      - postgres\n      - redis\n\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: mcpdev\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: pass\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n\nvolumes:\n  postgres_data:\n</code></pre>"},{"location":"develop/tools/#debugging-tools","title":"Debugging Tools","text":""},{"location":"develop/tools/#python-debugging","title":"Python Debugging","text":"<pre><code># Debug configuration\nimport logging\nimport debugpy\n\n# Enable debugger\nif os.getenv('MCP_DEBUG'):\n    debugpy.listen(5678)\n    debugpy.wait_for_client()\n\n# Logging setup\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('debug.log'),\n        logging.StreamHandler()\n    ]\n)\n</code></pre>"},{"location":"develop/tools/#go-debugging-with-delve","title":"Go Debugging with Delve","text":"<pre><code># Install delve\ngo install github.com/go-delve/delve/cmd/dlv@latest\n\n# Debug with delve\ndlv debug ./cmd/server -- --config config.yaml\n\n# Remote debugging\ndlv debug --headless --listen=:2345 --api-version=2 ./cmd/server\n</code></pre>"},{"location":"develop/tools/#javascript-debugging","title":"JavaScript Debugging","text":"<pre><code>// .vscode/launch.json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Debug MCP Server\",\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"program\": \"${workspaceFolder}/src/index.ts\",\n      \"outFiles\": [\"${workspaceFolder}/dist/**/*.js\"],\n      \"runtimeArgs\": [\"--nolazy\", \"-r\", \"ts-node/register\"],\n      \"env\": {\n        \"NODE_ENV\": \"development\",\n        \"MCP_LOG_LEVEL\": \"debug\"\n      },\n      \"console\": \"integratedTerminal\",\n      \"internalConsoleOptions\": \"neverOpen\"\n    }\n  ]\n}\n</code></pre>"},{"location":"develop/tools/#code-quality-tools","title":"Code Quality Tools","text":""},{"location":"develop/tools/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-json\n      - id: check-added-large-files\n\n  - repo: https://github.com/psf/black\n    rev: 23.3.0\n    hooks:\n      - id: black\n\n  - repo: https://github.com/PyCQA/pylint\n    rev: v2.17.4\n    hooks:\n      - id: pylint\n\n  - repo: https://github.com/PyCQA/bandit\n    rev: 1.7.5\n    hooks:\n      - id: bandit\n        args: ['-f', 'json', '-o', 'bandit-report.json']\n</code></pre>"},{"location":"develop/tools/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<pre><code># .github/workflows/ci.yml\nname: CI\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.8', '3.9', '3.10', '3.11']\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements-dev.txt\n\n    - name: Run tests\n      run: |\n        pytest --cov=mcp_server --cov-report=xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage.xml\n</code></pre>"},{"location":"develop/tools/#monitoring-and-profiling","title":"Monitoring and Profiling","text":""},{"location":"develop/tools/#performance-profiling","title":"Performance Profiling","text":"<pre><code># Python profiling\nimport cProfile\nimport pstats\nfrom pstats import SortKey\n\ndef profile_tool_execution(tool_name, arguments):\n    profiler = cProfile.Profile()\n    profiler.enable()\n    \n    # Execute tool\n    result = execute_tool(tool_name, arguments)\n    \n    profiler.disable()\n    stats = pstats.Stats(profiler)\n    stats.sort_stats(SortKey.TIME)\n    stats.print_stats(10)\n    \n    return result\n</code></pre>"},{"location":"develop/tools/#memory-profiling","title":"Memory Profiling","text":"<pre><code># Python memory profiling with memory_profiler\nfrom memory_profiler import profile\n\n@profile\ndef memory_intensive_tool():\n    # Tool implementation\n    pass\n</code></pre>"},{"location":"develop/tools/#go-profiling","title":"Go Profiling","text":"<pre><code>// Go profiling\nimport (\n    _ \"net/http/pprof\"\n    \"net/http\"\n    \"log\"\n)\n\nfunc init() {\n    go func() {\n        log.Println(http.ListenAndServe(\"localhost:6060\", nil))\n    }()\n}\n</code></pre>"},{"location":"develop/tools/#database-tools","title":"Database Tools","text":""},{"location":"develop/tools/#database-migrations","title":"Database Migrations","text":"<pre><code># Python - Alembic migration\nfrom alembic import op\nimport sqlalchemy as sa\n\ndef upgrade():\n    op.create_table(\n        'tool_executions',\n        sa.Column('id', sa.Integer, primary_key=True),\n        sa.Column('tool_name', sa.String(100), nullable=False),\n        sa.Column('arguments', sa.JSON),\n        sa.Column('result', sa.JSON),\n        sa.Column('executed_at', sa.DateTime, default=sa.func.now())\n    )\n\ndef downgrade():\n    op.drop_table('tool_executions')\n</code></pre>"},{"location":"develop/tools/#database-seeding","title":"Database Seeding","text":"<pre><code>-- SQL seed data\nINSERT INTO tool_configurations (name, config) VALUES\n('github', '{\"token\": \"${GITHUB_TOKEN}\", \"base_url\": \"https://api.github.com\"}'),\n('database', '{\"connection_string\": \"${DATABASE_URL}\", \"read_only\": true}'),\n('filesystem', '{\"allowed_paths\": [\"/tmp\", \"/var/data\"], \"max_file_size\": 1048576}');\n</code></pre>"},{"location":"develop/tools/#documentation-tools","title":"Documentation Tools","text":""},{"location":"develop/tools/#api-documentation-generation","title":"API Documentation Generation","text":"<pre><code># Python - Generate OpenAPI spec\nfrom apispec import APISpec\nfrom apispec.ext.marshmallow import MarshmallowPlugin\n\nspec = APISpec(\n    title=\"MCP Server API\",\n    version=\"1.0.0\",\n    openapi_version=\"3.0.2\",\n    plugins=[MarshmallowPlugin()],\n)\n\n# Add tool schemas\nfor tool in registered_tools:\n    spec.components.schema(tool.name, schema=tool.input_schema)\n</code></pre>"},{"location":"develop/tools/#code-documentation","title":"Code Documentation","text":"<pre><code>// Go documentation with godoc\n// Package tools provides MCP tool implementations.\n//\n// This package contains various tool implementations for the MCP server,\n// including database queries, HTTP requests, and file system operations.\n//\n// Example usage:\n//   registry := tools.NewRegistry()\n//   registry.Register(&amp;tools.DatabaseTool{})\n//   result, err := registry.CallTool(ctx, \"database\", args)\npackage tools\n</code></pre>"},{"location":"develop/tools/#security-tools","title":"Security Tools","text":""},{"location":"develop/tools/#static-analysis","title":"Static Analysis","text":"<pre><code># Security scanning tools\npip install bandit safety semgrep\n\n# Run security scans\nbandit -r src/\nsafety check\nsemgrep --config=auto src/\n</code></pre>"},{"location":"develop/tools/#dependency-scanning","title":"Dependency Scanning","text":"<pre><code># GitHub Security Advisory scanning\nname: Security Scan\non: [push, pull_request]\n\njobs:\n  security:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n    - name: Run Trivy vulnerability scanner\n      uses: aquasecurity/trivy-action@master\n      with:\n        scan-type: 'fs'\n        scan-ref: '.'\n</code></pre> <p>These development tools provide a comprehensive foundation for building, testing, debugging, and maintaining MCP servers across different programming languages and environments.</p>"},{"location":"develop/go/","title":"Go Overview","text":""},{"location":"develop/go/#go-development","title":"Go Development","text":""},{"location":"develop/go/#mcp-server-development-with-go","title":"MCP Server Development with Go","text":"<p>Go provides excellent performance and concurrency for MCP servers, making it ideal for high-throughput applications.</p>"},{"location":"develop/go/#quick-start","title":"Quick Start","text":""},{"location":"develop/go/#installation","title":"Installation","text":"<pre><code>go get github.com/modelcontextprotocol/go-mcp\n</code></pre>"},{"location":"develop/go/#basic-server","title":"Basic Server","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"log\"\n    \n    \"github.com/modelcontextprotocol/go-mcp/server\"\n    \"github.com/modelcontextprotocol/go-mcp/types\"\n)\n\nfunc main() {\n    // Create server\n    srv := server.New(\"my-go-server\", \"1.0.0\")\n    \n    // Register tool\n    srv.RegisterTool(\"greet\", types.Tool{\n        Description: \"Greet someone\",\n        Parameters: types.Parameters{\n            Type: \"object\",\n            Properties: map[string]types.Property{\n                \"name\": {Type: \"string\", Description: \"Name to greet\"},\n            },\n            Required: []string{\"name\"},\n        },\n    }, greetHandler)\n    \n    // Start server\n    if err := srv.Start(\":8000\"); err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc greetHandler(ctx context.Context, params map[string]interface{}) (interface{}, error) {\n    name, ok := params[\"name\"].(string)\n    if !ok {\n        return nil, fmt.Errorf(\"name must be a string\")\n    }\n    \n    return fmt.Sprintf(\"Hello, %s!\", name), nil\n}\n</code></pre>"},{"location":"develop/go/#project-structure","title":"Project Structure","text":""},{"location":"develop/go/#standard-layout","title":"Standard Layout","text":"<pre><code>my-go-server/\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 server/\n\u2502       \u2514\u2500\u2500 main.go\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 handlers/\n\u2502   \u2502   \u2514\u2500\u2500 tools.go\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u2514\u2500\u2500 types.go\n\u2502   \u2514\u2500\u2500 service/\n\u2502       \u2514\u2500\u2500 service.go\n\u251c\u2500\u2500 pkg/\n\u2502   \u2514\u2500\u2500 client/\n\u2502       \u2514\u2500\u2500 client.go\n\u251c\u2500\u2500 configs/\n\u2502   \u2514\u2500\u2500 config.yaml\n\u251c\u2500\u2500 scripts/\n\u2502   \u2514\u2500\u2500 build.sh\n\u251c\u2500\u2500 go.mod\n\u251c\u2500\u2500 go.sum\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"develop/go/#go-module","title":"Go Module","text":"<pre><code>// go.mod\nmodule github.com/yourusername/my-mcp-server\n\ngo 1.21\n\nrequire (\n    github.com/modelcontextprotocol/go-mcp v1.0.0\n    github.com/gorilla/mux v1.8.0\n    github.com/spf13/viper v1.16.0\n)\n</code></pre>"},{"location":"develop/go/#advanced-implementation","title":"Advanced Implementation","text":""},{"location":"develop/go/#structured-tools","title":"Structured Tools","text":"<pre><code>type GreetRequest struct {\n    Name     string `json:\"name\" validate:\"required\"`\n    Greeting string `json:\"greeting,omitempty\"`\n}\n\ntype GreetResponse struct {\n    Message   string    `json:\"message\"`\n    Timestamp time.Time `json:\"timestamp\"`\n}\n\nfunc (s *Server) RegisterTools() {\n    s.mcp.RegisterTool(\"greet\", types.Tool{\n        Description: \"Greet someone with timestamp\",\n        Parameters:  generateSchema(GreetRequest{}),\n    }, s.handleGreet)\n}\n\nfunc (s *Server) handleGreet(ctx context.Context, params json.RawMessage) (interface{}, error) {\n    var req GreetRequest\n    if err := json.Unmarshal(params, &amp;req); err != nil {\n        return nil, fmt.Errorf(\"invalid parameters: %w\", err)\n    }\n    \n    if err := s.validator.Struct(req); err != nil {\n        return nil, fmt.Errorf(\"validation failed: %w\", err)\n    }\n    \n    greeting := \"Hello\"\n    if req.Greeting != \"\" {\n        greeting = req.Greeting\n    }\n    \n    return GreetResponse{\n        Message:   fmt.Sprintf(\"%s, %s!\", greeting, req.Name),\n        Timestamp: time.Now(),\n    }, nil\n}\n</code></pre>"},{"location":"develop/go/#concurrent-operations","title":"Concurrent Operations","text":"<pre><code>func (s *Server) handleBatchProcess(ctx context.Context, items []string) ([]Result, error) {\n    results := make([]Result, len(items))\n    errChan := make(chan error, len(items))\n    \n    var wg sync.WaitGroup\n    for i, item := range items {\n        wg.Add(1)\n        go func(index int, data string) {\n            defer wg.Done()\n            \n            result, err := s.processItem(ctx, data)\n            if err != nil {\n                errChan &lt;- err\n                return\n            }\n            results[index] = result\n        }(i, item)\n    }\n    \n    wg.Wait()\n    close(errChan)\n    \n    // Check for errors\n    for err := range errChan {\n        if err != nil {\n            return nil, fmt.Errorf(\"batch processing failed: %w\", err)\n        }\n    }\n    \n    return results, nil\n}\n</code></pre>"},{"location":"develop/go/#resource-management","title":"Resource Management","text":"<pre><code>type ResourceManager struct {\n    pool *sql.DB\n    cache *cache.Cache\n    mu    sync.RWMutex\n}\n\nfunc NewResourceManager(config *Config) (*ResourceManager, error) {\n    db, err := sql.Open(\"postgres\", config.DatabaseURL)\n    if err != nil {\n        return nil, err\n    }\n    \n    db.SetMaxOpenConns(25)\n    db.SetMaxIdleConns(5)\n    db.SetConnMaxLifetime(5 * time.Minute)\n    \n    return &amp;ResourceManager{\n        pool:  db,\n        cache: cache.New(5*time.Minute, 10*time.Minute),\n    }, nil\n}\n\nfunc (rm *ResourceManager) Get(ctx context.Context, key string) (interface{}, error) {\n    // Check cache first\n    if val, found := rm.cache.Get(key); found {\n        return val, nil\n    }\n    \n    // Query database\n    var result interface{}\n    err := rm.pool.QueryRowContext(ctx, \n        \"SELECT data FROM resources WHERE key = $1\", key).Scan(&amp;result)\n    \n    if err == nil {\n        rm.cache.Set(key, result, cache.DefaultExpiration)\n    }\n    \n    return result, err\n}\n</code></pre>"},{"location":"develop/go/#error-handling","title":"Error Handling","text":""},{"location":"develop/go/#custom-error-types","title":"Custom Error Types","text":"<pre><code>type McpError struct {\n    Code    int    `json:\"code\"`\n    Message string `json:\"message\"`\n    Details any    `json:\"details,omitempty\"`\n}\n\nfunc (e *McpError) Error() string {\n    return fmt.Sprintf(\"MCP Error %d: %s\", e.Code, e.Message)\n}\n\nfunc NewMcpError(code int, message string, details ...any) *McpError {\n    err := &amp;McpError{\n        Code:    code,\n        Message: message,\n    }\n    if len(details) &gt; 0 {\n        err.Details = details[0]\n    }\n    return err\n}\n\n// Error codes\nconst (\n    ErrInvalidParams = -32602\n    ErrInternal      = -32603\n    ErrTimeout       = -32001\n    ErrRateLimit     = -32002\n)\n</code></pre>"},{"location":"develop/go/#error-middleware","title":"Error Middleware","text":"<pre><code>func ErrorMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        defer func() {\n            if err := recover(); err != nil {\n                log.Printf(\"Panic recovered: %v\", err)\n                \n                mcpErr := NewMcpError(ErrInternal, \"Internal server error\")\n                respondWithError(w, mcpErr)\n            }\n        }()\n        \n        next.ServeHTTP(w, r)\n    })\n}\n</code></pre>"},{"location":"develop/go/#testing","title":"Testing","text":""},{"location":"develop/go/#unit-tests","title":"Unit Tests","text":"<pre><code>func TestGreetHandler(t *testing.T) {\n    tests := []struct {\n        name    string\n        params  map[string]interface{}\n        want    string\n        wantErr bool\n    }{\n        {\n            name:    \"valid name\",\n            params:  map[string]interface{}{\"name\": \"Alice\"},\n            want:    \"Hello, Alice!\",\n            wantErr: false,\n        },\n        {\n            name:    \"missing name\",\n            params:  map[string]interface{}{},\n            want:    \"\",\n            wantErr: true,\n        },\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            got, err := greetHandler(context.Background(), tt.params)\n            \n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"greetHandler() error = %v, wantErr %v\", err, tt.wantErr)\n                return\n            }\n            \n            if !tt.wantErr &amp;&amp; got != tt.want {\n                t.Errorf(\"greetHandler() = %v, want %v\", got, tt.want)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"develop/go/#integration-tests","title":"Integration Tests","text":"<pre><code>func TestServerIntegration(t *testing.T) {\n    // Start test server\n    srv := NewTestServer(t)\n    defer srv.Close()\n    \n    // Test tool invocation\n    resp, err := srv.CallTool(\"greet\", map[string]interface{}{\n        \"name\": \"Test\",\n    })\n    \n    require.NoError(t, err)\n    assert.Equal(t, \"Hello, Test!\", resp)\n}\n</code></pre>"},{"location":"develop/go/#performance","title":"Performance","text":""},{"location":"develop/go/#benchmarking","title":"Benchmarking","text":"<pre><code>func BenchmarkGreetHandler(b *testing.B) {\n    params := map[string]interface{}{\"name\": \"Benchmark\"}\n    ctx := context.Background()\n    \n    b.ResetTimer()\n    for i := 0; i &lt; b.N; i++ {\n        _, _ = greetHandler(ctx, params)\n    }\n}\n</code></pre>"},{"location":"develop/go/#profiling","title":"Profiling","text":"<pre><code>import _ \"net/http/pprof\"\n\nfunc main() {\n    // Enable profiling\n    go func() {\n        log.Println(http.ListenAndServe(\"localhost:6060\", nil))\n    }()\n    \n    // Start MCP server\n    startServer()\n}\n</code></pre>"},{"location":"develop/go/#configuration","title":"Configuration","text":""},{"location":"develop/go/#using-viper","title":"Using Viper","text":"<pre><code>type Config struct {\n    Server   ServerConfig   `mapstructure:\"server\"`\n    Database DatabaseConfig `mapstructure:\"database\"`\n    MCP      MCPConfig      `mapstructure:\"mcp\"`\n}\n\nfunc LoadConfig(path string) (*Config, error) {\n    viper.SetConfigFile(path)\n    viper.SetEnvPrefix(\"MCP\")\n    viper.AutomaticEnv()\n    \n    if err := viper.ReadInConfig(); err != nil {\n        return nil, err\n    }\n    \n    var config Config\n    if err := viper.Unmarshal(&amp;config); err != nil {\n        return nil, err\n    }\n    \n    return &amp;config, nil\n}\n</code></pre>"},{"location":"develop/go/#build-and-deploy","title":"Build and Deploy","text":""},{"location":"develop/go/#makefile","title":"Makefile","text":"<pre><code>.PHONY: build test run\n\nbuild:\n\tgo build -o bin/server cmd/server/main.go\n\ntest:\n\tgo test -v -cover ./...\n\nrun:\n\tgo run cmd/server/main.go\n\ndocker:\n\tdocker build -t my-mcp-server .\n\nclean:\n\trm -rf bin/\n</code></pre>"},{"location":"develop/go/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83c\udfd7\ufe0f Project Structure</li> <li>\ud83d\udd27 Implementation Details</li> <li>\ud83e\uddea Testing Strategies</li> <li>\ud83d\udce6 Building &amp; Packaging</li> <li>\ud83c\udfaf Go Best Practices</li> </ul>"},{"location":"develop/go/best-practices/","title":"Best Practices","text":""},{"location":"develop/go/best-practices/#go-best-practices-for-mcp-servers","title":"Go Best Practices for MCP Servers","text":""},{"location":"develop/go/best-practices/#go-specific-best-practices","title":"Go-Specific Best Practices","text":"<p>This guide covers Go-specific best practices, patterns, and conventions for building robust, maintainable, and performant MCP servers.</p>"},{"location":"develop/go/best-practices/#code-organization-and-structure","title":"Code Organization and Structure","text":""},{"location":"develop/go/best-practices/#package-design-principles","title":"Package Design Principles","text":"<pre><code>// \u2705 Good: Clear, focused packages\npackage tools      // Contains tool implementations\npackage server     // Contains server logic  \npackage config     // Contains configuration management\npackage storage    // Contains data storage abstractions\n\n// \u274c Bad: Generic, unfocused packages\npackage utils      // Too generic, unclear purpose\npackage helpers    // Vague, could contain anything\npackage stuff      // Meaningless name\n</code></pre>"},{"location":"develop/go/best-practices/#interface-design","title":"Interface Design","text":"<pre><code>// \u2705 Good: Small, focused interfaces\ntype Tool interface {\n    Name() string\n    Description() string\n    Execute(context.Context, map[string]interface{}) ([]Content, error)\n}\n\ntype Storage interface {\n    Store(ctx context.Context, key string, value []byte) error\n    Retrieve(ctx context.Context, key string) ([]byte, error)\n}\n\n// \u274c Bad: Large, monolithic interface\ntype Everything interface {\n    Name() string\n    Description() string\n    Execute(context.Context, map[string]interface{}) ([]Content, error)\n    Store(ctx context.Context, key string, value []byte) error\n    Retrieve(ctx context.Context, key string) ([]byte, error)\n    Connect() error\n    Disconnect() error\n    Validate() error\n}\n</code></pre>"},{"location":"develop/go/best-practices/#dependency-injection","title":"Dependency Injection","text":"<pre><code>// \u2705 Good: Constructor injection with interfaces\ntype Server struct {\n    tools    ToolRegistry\n    storage  Storage\n    logger   Logger\n    config   *Config\n}\n\nfunc NewServer(tools ToolRegistry, storage Storage, logger Logger, config *Config) *Server {\n    return &amp;Server{\n        tools:   tools,\n        storage: storage,\n        logger:  logger,\n        config:  config,\n    }\n}\n\n// \u274c Bad: Global variables and tight coupling\nvar (\n    globalDB     *sql.DB\n    globalLogger *log.Logger\n    globalConfig *Config\n)\n\nfunc (s *Server) doSomething() {\n    // Using global variables makes testing difficult\n    result := globalDB.Query(\"SELECT * FROM users\")\n    globalLogger.Println(\"Query executed\")\n}\n</code></pre>"},{"location":"develop/go/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"develop/go/best-practices/#structured-error-types","title":"Structured Error Types","text":"<pre><code>// Define custom error types with context\ntype ValidationError struct {\n    Field   string\n    Value   interface{}\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for field %s: %s\", e.Field, e.Message)\n}\n\ntype ToolExecutionError struct {\n    ToolName string\n    Cause    error\n    Context  map[string]interface{}\n}\n\nfunc (e *ToolExecutionError) Error() string {\n    return fmt.Sprintf(\"tool %s execution failed: %v\", e.ToolName, e.Cause)\n}\n\nfunc (e *ToolExecutionError) Unwrap() error {\n    return e.Cause\n}\n</code></pre>"},{"location":"develop/go/best-practices/#error-wrapping-and-context","title":"Error Wrapping and Context","text":"<pre><code>// \u2705 Good: Wrap errors with context\nfunc (t *DatabaseTool) Execute(ctx context.Context, args map[string]interface{}) ([]Content, error) {\n    query, err := t.validateQuery(args)\n    if err != nil {\n        return nil, fmt.Errorf(\"query validation failed: %w\", err)\n    }\n\n    results, err := t.executeQuery(ctx, query)\n    if err != nil {\n        return nil, fmt.Errorf(\"query execution failed for tool %s: %w\", t.Name(), err)\n    }\n\n    return results, nil\n}\n\n// \u274c Bad: Losing error context\nfunc (t *DatabaseTool) Execute(ctx context.Context, args map[string]interface{}) ([]Content, error) {\n    query, err := t.validateQuery(args)\n    if err != nil {\n        return nil, err // Lost context about where this failed\n    }\n\n    results, err := t.executeQuery(ctx, query)\n    if err != nil {\n        return nil, errors.New(\"query failed\") // Lost original error information\n    }\n\n    return results, nil\n}\n</code></pre>"},{"location":"develop/go/best-practices/#sentinel-errors-and-error-checking","title":"Sentinel Errors and Error Checking","text":"<pre><code>// Define sentinel errors for common conditions\nvar (\n    ErrToolNotFound      = errors.New(\"tool not found\")\n    ErrInvalidArguments  = errors.New(\"invalid arguments\")\n    ErrResourceNotFound  = errors.New(\"resource not found\")\n    ErrUnauthorized      = errors.New(\"unauthorized access\")\n)\n\n// \u2705 Good: Use errors.Is for checking\nfunc (r *ToolRegistry) GetTool(name string) (Tool, error) {\n    tool, exists := r.tools[name]\n    if !exists {\n        return nil, fmt.Errorf(\"tool %s: %w\", name, ErrToolNotFound)\n    }\n    return tool, nil\n}\n\nfunc handleToolCall(registry *ToolRegistry, name string) {\n    tool, err := registry.GetTool(name)\n    if errors.Is(err, ErrToolNotFound) {\n        // Handle tool not found specifically\n        log.Printf(\"Tool %s not available\", name)\n        return\n    }\n    if err != nil {\n        // Handle other errors\n        log.Printf(\"Error getting tool: %v\", err)\n        return\n    }\n    // Use tool...\n}\n</code></pre>"},{"location":"develop/go/best-practices/#concurrency-patterns","title":"Concurrency Patterns","text":""},{"location":"develop/go/best-practices/#context-usage","title":"Context Usage","text":"<pre><code>// \u2705 Good: Proper context usage\nfunc (s *Server) handleRequest(ctx context.Context, req *Request) (*Response, error) {\n    // Set timeout for the entire operation\n    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)\n    defer cancel()\n\n    // Pass context through all operations\n    result, err := s.processRequest(ctx, req)\n    if err != nil {\n        if errors.Is(err, context.Canceled) {\n            return nil, fmt.Errorf(\"request canceled: %w\", err)\n        }\n        if errors.Is(err, context.DeadlineExceeded) {\n            return nil, fmt.Errorf(\"request timed out: %w\", err)\n        }\n        return nil, fmt.Errorf(\"request processing failed: %w\", err)\n    }\n\n    return result, nil\n}\n\nfunc (s *Server) processRequest(ctx context.Context, req *Request) (*Response, error) {\n    // Check context before expensive operations\n    select {\n    case &lt;-ctx.Done():\n        return nil, ctx.Err()\n    default:\n    }\n\n    // Pass context to database operations\n    return s.db.QueryContext(ctx, req.Query)\n}\n</code></pre>"},{"location":"develop/go/best-practices/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>func (s *Server) Run(ctx context.Context) error {\n    // Create server\n    server := &amp;http.Server{\n        Addr:    s.config.HTTPAddr,\n        Handler: s.router,\n    }\n\n    // Start server in goroutine\n    go func() {\n        if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed {\n            s.logger.Error(\"Server failed to start\", \"error\", err)\n        }\n    }()\n\n    s.logger.Info(\"Server started\", \"addr\", s.config.HTTPAddr)\n\n    // Wait for context cancellation\n    &lt;-ctx.Done()\n\n    s.logger.Info(\"Shutting down server...\")\n\n    // Graceful shutdown with timeout\n    shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n    defer cancel()\n\n    if err := server.Shutdown(shutdownCtx); err != nil {\n        s.logger.Error(\"Server shutdown failed\", \"error\", err)\n        return err\n    }\n\n    s.logger.Info(\"Server stopped\")\n    return nil\n}\n</code></pre>"},{"location":"develop/go/best-practices/#worker-pools","title":"Worker Pools","text":"<pre><code>// Worker pool for concurrent tool execution\ntype ToolWorkerPool struct {\n    workers    int\n    jobChan    chan *ToolJob\n    resultChan chan *ToolResult\n    ctx        context.Context\n    cancel     context.CancelFunc\n    wg         sync.WaitGroup\n}\n\ntype ToolJob struct {\n    ID        string\n    Tool      Tool\n    Arguments map[string]interface{}\n    Context   context.Context\n}\n\ntype ToolResult struct {\n    ID      string\n    Content []Content\n    Error   error\n}\n\nfunc NewToolWorkerPool(workers int) *ToolWorkerPool {\n    ctx, cancel := context.WithCancel(context.Background())\n    \n    pool := &amp;ToolWorkerPool{\n        workers:    workers,\n        jobChan:    make(chan *ToolJob, workers*2),\n        resultChan: make(chan *ToolResult, workers*2),\n        ctx:        ctx,\n        cancel:     cancel,\n    }\n\n    // Start workers\n    for i := 0; i &lt; workers; i++ {\n        pool.wg.Add(1)\n        go pool.worker(i)\n    }\n\n    return pool\n}\n\nfunc (p *ToolWorkerPool) worker(id int) {\n    defer p.wg.Done()\n    \n    for {\n        select {\n        case job := &lt;-p.jobChan:\n            content, err := job.Tool.Execute(job.Context, job.Arguments)\n            \n            result := &amp;ToolResult{\n                ID:      job.ID,\n                Content: content,\n                Error:   err,\n            }\n            \n            select {\n            case p.resultChan &lt;- result:\n            case &lt;-p.ctx.Done():\n                return\n            case &lt;-job.Context.Done():\n                result.Error = job.Context.Err()\n                select {\n                case p.resultChan &lt;- result:\n                case &lt;-p.ctx.Done():\n                    return\n                }\n            }\n            \n        case &lt;-p.ctx.Done():\n            return\n        }\n    }\n}\n\nfunc (p *ToolWorkerPool) Submit(job *ToolJob) {\n    select {\n    case p.jobChan &lt;- job:\n    case &lt;-p.ctx.Done():\n    case &lt;-job.Context.Done():\n    }\n}\n\nfunc (p *ToolWorkerPool) GetResult() *ToolResult {\n    select {\n    case result := &lt;-p.resultChan:\n        return result\n    case &lt;-p.ctx.Done():\n        return nil\n    }\n}\n\nfunc (p *ToolWorkerPool) Close() {\n    p.cancel()\n    p.wg.Wait()\n    close(p.jobChan)\n    close(p.resultChan)\n}\n</code></pre>"},{"location":"develop/go/best-practices/#performance-optimization","title":"Performance Optimization","text":""},{"location":"develop/go/best-practices/#memory-management","title":"Memory Management","text":"<pre><code>// \u2705 Good: Reuse buffers and minimize allocations\ntype BufferPool struct {\n    pool sync.Pool\n}\n\nfunc NewBufferPool() *BufferPool {\n    return &amp;BufferPool{\n        pool: sync.Pool{\n            New: func() interface{} {\n                return make([]byte, 0, 1024)\n            },\n        },\n    }\n}\n\nfunc (p *BufferPool) Get() []byte {\n    return p.pool.Get().([]byte)\n}\n\nfunc (p *BufferPool) Put(buf []byte) {\n    if cap(buf) &gt; 64*1024 { // Don't pool very large buffers\n        return\n    }\n    p.pool.Put(buf[:0]) // Reset length but keep capacity\n}\n\n// Usage in tool execution\nfunc (t *JSONTool) Execute(ctx context.Context, args map[string]interface{}) ([]Content, error) {\n    buf := t.bufferPool.Get()\n    defer t.bufferPool.Put(buf)\n\n    // Use buf for JSON marshaling...\n    result := json.Marshal(data) // This would use the pooled buffer\n    \n    return []Content{{Type: \"text\", Text: string(result)}}, nil\n}\n</code></pre>"},{"location":"develop/go/best-practices/#efficient-string-building","title":"Efficient String Building","text":"<pre><code>// \u2705 Good: Use strings.Builder for string concatenation\nfunc buildResponse(data []Record) string {\n    var builder strings.Builder\n    builder.Grow(len(data) * 100) // Pre-allocate capacity\n\n    builder.WriteString(\"Results:\\n\")\n    for i, record := range data {\n        builder.WriteString(fmt.Sprintf(\"%d. %s: %s\\n\", i+1, record.Key, record.Value))\n    }\n\n    return builder.String()\n}\n\n// \u274c Bad: String concatenation in loops\nfunc buildResponseBad(data []Record) string {\n    result := \"Results:\\n\"\n    for i, record := range data {\n        result += fmt.Sprintf(\"%d. %s: %s\\n\", i+1, record.Key, record.Value) // Creates new string each iteration\n    }\n    return result\n}\n</code></pre>"},{"location":"develop/go/best-practices/#caching-patterns","title":"Caching Patterns","text":"<pre><code>// LRU Cache with expiration\ntype CacheItem struct {\n    Value      interface{}\n    Expiration time.Time\n}\n\ntype LRUCache struct {\n    mu       sync.RWMutex\n    items    map[string]*list.Element\n    lru      *list.List\n    maxItems int\n    ttl      time.Duration\n}\n\ntype cacheEntry struct {\n    key   string\n    value CacheItem\n}\n\nfunc NewLRUCache(maxItems int, ttl time.Duration) *LRUCache {\n    return &amp;LRUCache{\n        items:    make(map[string]*list.Element),\n        lru:      list.New(),\n        maxItems: maxItems,\n        ttl:      ttl,\n    }\n}\n\nfunc (c *LRUCache) Get(key string) (interface{}, bool) {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n\n    elem, exists := c.items[key]\n    if !exists {\n        return nil, false\n    }\n\n    entry := elem.Value.(*cacheEntry)\n    \n    // Check expiration\n    if time.Now().After(entry.value.Expiration) {\n        c.mu.RUnlock()\n        c.mu.Lock()\n        c.removeElement(elem)\n        c.mu.Unlock()\n        c.mu.RLock()\n        return nil, false\n    }\n\n    // Move to front (most recently used)\n    c.lru.MoveToFront(elem)\n    \n    return entry.value.Value, true\n}\n\nfunc (c *LRUCache) Set(key string, value interface{}) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    now := time.Now()\n    expiration := now.Add(c.ttl)\n\n    if elem, exists := c.items[key]; exists {\n        // Update existing item\n        entry := elem.Value.(*cacheEntry)\n        entry.value.Value = value\n        entry.value.Expiration = expiration\n        c.lru.MoveToFront(elem)\n        return\n    }\n\n    // Add new item\n    entry := &amp;cacheEntry{\n        key: key,\n        value: CacheItem{\n            Value:      value,\n            Expiration: expiration,\n        },\n    }\n\n    elem := c.lru.PushFront(entry)\n    c.items[key] = elem\n\n    // Evict if over capacity\n    if len(c.items) &gt; c.maxItems {\n        oldest := c.lru.Back()\n        if oldest != nil {\n            c.removeElement(oldest)\n        }\n    }\n}\n\nfunc (c *LRUCache) removeElement(elem *list.Element) {\n    entry := elem.Value.(*cacheEntry)\n    delete(c.items, entry.key)\n    c.lru.Remove(elem)\n}\n</code></pre>"},{"location":"develop/go/best-practices/#security-best-practices","title":"Security Best Practices","text":""},{"location":"develop/go/best-practices/#input-validation","title":"Input Validation","text":"<pre><code>import (\n    \"net/url\"\n    \"regexp\"\n    \"unicode/utf8\"\n)\n\n// Validation functions\nfunc validateEmail(email string) error {\n    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`)\n    if !emailRegex.MatchString(email) {\n        return fmt.Errorf(\"invalid email format\")\n    }\n    return nil\n}\n\nfunc validateURL(urlStr string) error {\n    u, err := url.Parse(urlStr)\n    if err != nil {\n        return fmt.Errorf(\"invalid URL: %w\", err)\n    }\n    \n    if u.Scheme != \"http\" &amp;&amp; u.Scheme != \"https\" {\n        return fmt.Errorf(\"unsupported URL scheme: %s\", u.Scheme)\n    }\n    \n    return nil\n}\n\nfunc validateStringLength(s string, maxLength int) error {\n    if !utf8.ValidString(s) {\n        return fmt.Errorf(\"invalid UTF-8 string\")\n    }\n    \n    if utf8.RuneCountInString(s) &gt; maxLength {\n        return fmt.Errorf(\"string too long: max %d characters\", maxLength)\n    }\n    \n    return nil\n}\n\n// Tool with comprehensive validation\ntype ValidatedTool struct {\n    name string\n}\n\nfunc (t *ValidatedTool) Execute(ctx context.Context, args map[string]interface{}) ([]Content, error) {\n    // Validate each argument type and content\n    email, ok := args[\"email\"].(string)\n    if !ok {\n        return nil, &amp;ValidationError{Field: \"email\", Message: \"must be a string\"}\n    }\n    \n    if err := validateEmail(email); err != nil {\n        return nil, &amp;ValidationError{Field: \"email\", Message: err.Error()}\n    }\n    \n    urlStr, ok := args[\"url\"].(string)\n    if !ok {\n        return nil, &amp;ValidationError{Field: \"url\", Message: \"must be a string\"}\n    }\n    \n    if err := validateURL(urlStr); err != nil {\n        return nil, &amp;ValidationError{Field: \"url\", Message: err.Error()}\n    }\n    \n    // Continue with validated inputs...\n    return nil, nil\n}\n</code></pre>"},{"location":"develop/go/best-practices/#secure-file-operations","title":"Secure File Operations","text":"<pre><code>import (\n    \"path/filepath\"\n    \"strings\"\n)\n\ntype SecureFileHandler struct {\n    allowedDirs []string\n    maxSize     int64\n}\n\nfunc (h *SecureFileHandler) validatePath(filePath string) error {\n    // Prevent path traversal\n    if strings.Contains(filePath, \"..\") {\n        return fmt.Errorf(\"path traversal not allowed\")\n    }\n    \n    // Convert to absolute path\n    absPath, err := filepath.Abs(filePath)\n    if err != nil {\n        return fmt.Errorf(\"invalid path: %w\", err)\n    }\n    \n    // Check if path is within allowed directories\n    allowed := false\n    for _, allowedDir := range h.allowedDirs {\n        absAllowed, err := filepath.Abs(allowedDir)\n        if err != nil {\n            continue\n        }\n        \n        if strings.HasPrefix(absPath, absAllowed+string(filepath.Separator)) {\n            allowed = true\n            break\n        }\n    }\n    \n    if !allowed {\n        return fmt.Errorf(\"path not in allowed directories\")\n    }\n    \n    return nil\n}\n\nfunc (h *SecureFileHandler) readFile(filePath string) ([]byte, error) {\n    if err := h.validatePath(filePath); err != nil {\n        return nil, err\n    }\n    \n    // Check file size before reading\n    info, err := os.Stat(filePath)\n    if err != nil {\n        return nil, fmt.Errorf(\"file stat failed: %w\", err)\n    }\n    \n    if info.Size() &gt; h.maxSize {\n        return nil, fmt.Errorf(\"file too large: %d bytes (max: %d)\", info.Size(), h.maxSize)\n    }\n    \n    return os.ReadFile(filePath)\n}\n</code></pre>"},{"location":"develop/go/best-practices/#testing-patterns","title":"Testing Patterns","text":""},{"location":"develop/go/best-practices/#table-driven-tests","title":"Table-Driven Tests","text":"<pre><code>func TestToolExecution(t *testing.T) {\n    tests := []struct {\n        name      string\n        tool      Tool\n        args      map[string]interface{}\n        wantErr   bool\n        wantCount int\n        validate  func(t *testing.T, content []Content)\n    }{\n        {\n            name: \"valid echo\",\n            tool: &amp;EchoTool{},\n            args: map[string]interface{}{\"text\": \"hello\"},\n            wantErr: false,\n            wantCount: 1,\n            validate: func(t *testing.T, content []Content) {\n                assert.Equal(t, \"text\", content[0].Type)\n                assert.Contains(t, content[0].Text, \"hello\")\n            },\n        },\n        {\n            name: \"missing required argument\",\n            tool: &amp;EchoTool{},\n            args: map[string]interface{}{},\n            wantErr: true,\n        },\n        {\n            name: \"invalid argument type\",\n            tool: &amp;EchoTool{},\n            args: map[string]interface{}{\"text\": 123},\n            wantErr: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            ctx := context.Background()\n            content, err := tt.tool.Execute(ctx, tt.args)\n            \n            if tt.wantErr {\n                assert.Error(t, err)\n                return\n            }\n            \n            assert.NoError(t, err)\n            assert.Len(t, content, tt.wantCount)\n            \n            if tt.validate != nil {\n                tt.validate(t, content)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"develop/go/best-practices/#mock-generation-and-testing","title":"Mock Generation and Testing","text":"<pre><code>//go:generate go run github.com/golang/mock/mockgen -source=tool.go -destination=mocks/mock_tool.go\n\nfunc TestServerWithMocks(t *testing.T) {\n    ctrl := gomock.NewController(t)\n    defer ctrl.Finish()\n\n    mockTool := mocks.NewMockTool(ctrl)\n    mockTool.EXPECT().Name().Return(\"mock-tool\").AnyTimes()\n    mockTool.EXPECT().Execute(gomock.Any(), gomock.Any()).Return(\n        []Content{{Type: \"text\", Text: \"mock response\"}}, nil,\n    ).Times(1)\n\n    registry := NewRegistry()\n    registry.Register(mockTool)\n\n    server := NewServer(registry, nil, nil)\n    \n    ctx := context.Background()\n    result, err := server.CallTool(ctx, \"mock-tool\", map[string]interface{}{})\n    \n    assert.NoError(t, err)\n    assert.Len(t, result, 1)\n    assert.Equal(t, \"mock response\", result[0].Text)\n}\n</code></pre>"},{"location":"develop/go/best-practices/#documentation-and-code-quality","title":"Documentation and Code Quality","text":""},{"location":"develop/go/best-practices/#effective-comments-and-documentation","title":"Effective Comments and Documentation","text":"<pre><code>// Package tools provides implementations of MCP tools for various operations.\n// \n// Each tool implements the Tool interface and should provide:\n//   - A unique name that describes its function\n//   - A clear description of what it does\n//   - A JSON schema for input validation\n//   - Thread-safe execution logic\n//\n// Example usage:\n//   registry := tools.NewRegistry()\n//   registry.Register(&amp;tools.EchoTool{})\n//   \n//   result, err := registry.CallTool(ctx, \"echo\", map[string]interface{}{\n//       \"text\": \"Hello, World!\",\n//   })\npackage tools\n\n// EchoTool implements a simple echo functionality for testing and demonstration.\n// It accepts a text input and returns it unchanged, prefixed with \"Echo: \".\n//\n// This tool is primarily useful for:\n//   - Testing MCP client implementations\n//   - Demonstrating tool execution patterns\n//   - Validating connection and protocol functionality\ntype EchoTool struct {\n    // No fields needed for stateless echo operation\n}\n\n// Execute processes the echo request and returns the input text with a prefix.\n// \n// The context parameter is respected for cancellation, though echo operations\n// are typically fast enough that cancellation is rare.\n//\n// Arguments expected:\n//   - text (string): The text to echo back (required)\n//\n// Returns content with type \"text\" containing the echoed message.\nfunc (t *EchoTool) Execute(ctx context.Context, arguments map[string]interface{}) ([]Content, error) {\n    // Implementation details...\n}\n</code></pre>"},{"location":"develop/go/best-practices/#linting-configuration","title":"Linting Configuration","text":"<pre><code># .golangci.yml\nlinters-settings:\n  revive:\n    rules:\n      - name: exported\n        arguments: [checkPrivateReceivers, sayRepetitiveInsteadOfStutters]\n  govet:\n    check-shadowing: true\n  misspell:\n    locale: US\n  gofmt:\n    simplify: true\n\nlinters:\n  enable:\n    - revive\n    - govet\n    - misspell\n    - gofmt\n    - goimports\n    - gosec\n    - ineffassign\n    - staticcheck\n    - typecheck\n    - unused\n    - errcheck\n    - goconst\n    - gocyclo\n    - dupl\n\nissues:\n  exclude-rules:\n    - path: _test\\.go\n      linters:\n        - gosec\n        - dupl\n</code></pre> <p>Following these Go-specific best practices will result in MCP servers that are efficient, maintainable, secure, and idiomatic to the Go ecosystem.</p>"},{"location":"develop/go/building/","title":"Building","text":""},{"location":"develop/go/building/#go-building-and-deployment","title":"Go Building and Deployment","text":""},{"location":"develop/go/building/#building-go-mcp-servers-for-production","title":"Building Go MCP Servers for Production","text":"<p>This guide covers building, optimizing, and deploying Go MCP servers with proper cross-compilation, optimization, and containerization.</p>"},{"location":"develop/go/building/#build-configuration","title":"Build Configuration","text":""},{"location":"develop/go/building/#basic-build-commands","title":"Basic Build Commands","text":"<pre><code># Development build\ngo build -o mcp-server ./cmd/server\n\n# Production build with optimizations\ngo build -ldflags \"-w -s\" -trimpath -o mcp-server ./cmd/server\n\n# Build with version information\nVERSION=$(git describe --tags --always --dirty)\nBUILD_TIME=$(date -u '+%Y-%m-%dT%H:%M:%SZ')\ngo build -ldflags \"-w -s -X main.Version=$VERSION -X main.BuildTime=$BUILD_TIME\" -trimpath -o mcp-server ./cmd/server\n</code></pre>"},{"location":"develop/go/building/#advanced-build-configuration","title":"Advanced Build Configuration","text":"<pre><code>// cmd/server/version.go\npackage main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nvar (\n    Version   = \"dev\"\n    BuildTime = \"unknown\"\n    GitCommit = \"unknown\"\n)\n\nfunc printVersion() {\n    fmt.Printf(\"MCP Server %s\\n\", Version)\n    fmt.Printf(\"Build time: %s\\n\", BuildTime)\n    fmt.Printf(\"Git commit: %s\\n\", GitCommit)\n    fmt.Printf(\"Go version: %s\\n\", runtime.Version())\n    fmt.Printf(\"OS/Arch: %s/%s\\n\", runtime.GOOS, runtime.GOARCH)\n}\n</code></pre>"},{"location":"develop/go/building/#cross-platform-compilation","title":"Cross-Platform Compilation","text":""},{"location":"develop/go/building/#multi-platform-makefile","title":"Multi-Platform Makefile","text":"<pre><code># Build configuration\nBINARY_NAME=mcp-server\nMAIN_PATH=./cmd/server\nVERSION ?= $(shell git describe --tags --always --dirty)\nBUILD_TIME ?= $(shell date -u '+%Y-%m-%dT%H:%M:%SZ')\nGIT_COMMIT ?= $(shell git rev-parse HEAD)\n\n# Build flags\nLDFLAGS=-ldflags \"-w -s -X main.Version=$(VERSION) -X main.BuildTime=$(BUILD_TIME) -X main.GitCommit=$(GIT_COMMIT)\"\nBUILD_FLAGS=-trimpath $(LDFLAGS)\n\n# Supported platforms\nPLATFORMS := windows/amd64 linux/amd64 linux/arm64 darwin/amd64 darwin/arm64\n\n# Default build\nbuild:\n\tgo build $(BUILD_FLAGS) -o $(BINARY_NAME) $(MAIN_PATH)\n\n# Cross-compile for all platforms\nbuild-all: $(PLATFORMS)\n\n$(PLATFORMS):\n\t$(eval GOOS := $(word 1,$(subst /, ,$@)))\n\t$(eval GOARCH := $(word 2,$(subst /, ,$@)))\n\t$(eval BINARY := $(BINARY_NAME)-$(GOOS)-$(GOARCH))\n\t$(eval BINARY := $(if $(filter windows,$(GOOS)),$(BINARY).exe,$(BINARY)))\n\t\n\t@echo \"Building $(BINARY)...\"\n\tGOOS=$(GOOS) GOARCH=$(GOARCH) go build $(BUILD_FLAGS) -o dist/$(BINARY) $(MAIN_PATH)\n\n# Build for current platform with race detection (development)\nbuild-dev:\n\tgo build -race -o $(BINARY_NAME)-dev $(MAIN_PATH)\n\n# Static binary for containers\nbuild-static:\n\tCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build $(BUILD_FLAGS) -a -installsuffix cgo -o $(BINARY_NAME)-static $(MAIN_PATH)\n\n# Clean build artifacts\nclean:\n\trm -f $(BINARY_NAME)*\n\trm -rf dist/\n\n.PHONY: build build-all build-dev build-static clean $(PLATFORMS)\n</code></pre>"},{"location":"develop/go/building/#github-actions-build-pipeline","title":"GitHub Actions Build Pipeline","text":"<pre><code># .github/workflows/build.yml\nname: Build and Release\n\non:\n  push:\n    branches: [main]\n    tags: ['v*']\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Set up Go\n      uses: actions/setup-go@v4\n      with:\n        go-version: '1.21'\n    \n    - name: Run tests\n      run: |\n        go test -race -coverprofile=coverage.out ./...\n        go tool cover -func=coverage.out\n    \n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n\n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        goos: [linux, windows, darwin]\n        goarch: [amd64, arm64]\n        exclude:\n          - goos: windows\n            goarch: arm64\n    \n    steps:\n    - uses: actions/checkout@v4\n      with:\n        fetch-depth: 0\n    \n    - name: Set up Go\n      uses: actions/setup-go@v4\n      with:\n        go-version: '1.21'\n    \n    - name: Build binary\n      env:\n        GOOS: ${{ matrix.goos }}\n        GOARCH: ${{ matrix.goarch }}\n      run: |\n        VERSION=$(git describe --tags --always --dirty)\n        BUILD_TIME=$(date -u '+%Y-%m-%dT%H:%M:%SZ')\n        GIT_COMMIT=$(git rev-parse HEAD)\n        \n        BINARY_NAME=mcp-server-${{ matrix.goos }}-${{ matrix.goarch }}\n        if [ \"${{ matrix.goos }}\" = \"windows\" ]; then\n          BINARY_NAME=\"${BINARY_NAME}.exe\"\n        fi\n        \n        CGO_ENABLED=0 go build \\\n          -ldflags \"-w -s -X main.Version=$VERSION -X main.BuildTime=$BUILD_TIME -X main.GitCommit=$GIT_COMMIT\" \\\n          -trimpath \\\n          -o $BINARY_NAME \\\n          ./cmd/server\n    \n    - name: Upload artifacts\n      uses: actions/upload-artifact@v3\n      with:\n        name: binaries\n        path: mcp-server-*\n\n  release:\n    if: startsWith(github.ref, 'refs/tags/v')\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n    - name: Download artifacts\n      uses: actions/download-artifact@v3\n      with:\n        name: binaries\n    \n    - name: Create release\n      uses: softprops/action-gh-release@v1\n      with:\n        files: mcp-server-*\n        generate_release_notes: true\n</code></pre>"},{"location":"develop/go/building/#container-building","title":"Container Building","text":""},{"location":"develop/go/building/#multi-stage-dockerfile","title":"Multi-Stage Dockerfile","text":"<pre><code># Build stage\nFROM golang:1.21-alpine AS builder\n\n# Install build dependencies\nRUN apk add --no-cache git ca-certificates tzdata\n\n# Set working directory\nWORKDIR /app\n\n# Copy go mod files\nCOPY go.mod go.sum ./\n\n# Download dependencies\nRUN go mod download\n\n# Copy source code\nCOPY . .\n\n# Build arguments\nARG VERSION=dev\nARG BUILD_TIME\nARG GIT_COMMIT\n\n# Build the binary\nRUN CGO_ENABLED=0 GOOS=linux go build \\\n    -ldflags \"-w -s -X main.Version=$VERSION -X main.BuildTime=$BUILD_TIME -X main.GitCommit=$GIT_COMMIT\" \\\n    -trimpath \\\n    -o mcp-server \\\n    ./cmd/server\n\n# Final stage\nFROM scratch\n\n# Copy CA certificates\nCOPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/\n\n# Copy timezone data\nCOPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo\n\n# Copy the binary\nCOPY --from=builder /app/mcp-server /mcp-server\n\n# Create non-root user (numeric for scratch image)\nUSER 10001:10001\n\n# Expose port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD [\"/mcp-server\", \"health\"]\n\n# Run the binary\nENTRYPOINT [\"/mcp-server\"]\n</code></pre>"},{"location":"develop/go/building/#optimized-dockerfile-with-upx","title":"Optimized Dockerfile with UPX","text":"<pre><code># Build stage with UPX compression\nFROM golang:1.21-alpine AS builder\n\n# Install dependencies including UPX\nRUN apk add --no-cache git ca-certificates tzdata upx\n\nWORKDIR /app\n\nCOPY go.mod go.sum ./\nRUN go mod download\n\nCOPY . .\n\nARG VERSION=dev\nARG BUILD_TIME\nARG GIT_COMMIT\n\n# Build with static linking\nRUN CGO_ENABLED=0 GOOS=linux go build \\\n    -ldflags \"-w -s -X main.Version=$VERSION -X main.BuildTime=$BUILD_TIME -X main.GitCommit=$GIT_COMMIT\" \\\n    -trimpath \\\n    -a -installsuffix cgo \\\n    -o mcp-server \\\n    ./cmd/server\n\n# Compress binary with UPX\nRUN upx --best --lzma mcp-server\n\n# Verify the compressed binary works\nRUN ./mcp-server version\n\n# Final stage\nFROM scratch\n\nCOPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/\nCOPY --from=builder /app/mcp-server /mcp-server\n\nUSER 10001:10001\nEXPOSE 8000\n\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD [\"/mcp-server\", \"health\"]\n\nENTRYPOINT [\"/mcp-server\"]\n</code></pre>"},{"location":"develop/go/building/#docker-compose-for-development","title":"Docker Compose for Development","text":"<pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  mcp-server:\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n      args:\n        VERSION: dev\n    ports:\n      - \"8000:8000\"\n    environment:\n      - MCP_LOG_LEVEL=debug\n      - MCP_TRANSPORT=http\n      - MCP_HTTP_ADDR=:8000\n    volumes:\n      - .:/app\n      - go-mod-cache:/go/pkg/mod\n    depends_on:\n      - postgres\n      - redis\n\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: mcp_dev\n      POSTGRES_USER: mcp\n      POSTGRES_PASSWORD: password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n\n  redis:\n    image: redis:7-alpine\n    command: redis-server --appendonly yes\n    volumes:\n      - redis_data:/data\n    ports:\n      - \"6379:6379\"\n\nvolumes:\n  go-mod-cache:\n  postgres_data:\n  redis_data:\n</code></pre>"},{"location":"develop/go/building/#development-dockerfile","title":"Development Dockerfile","text":"<pre><code># Dockerfile.dev - for development with hot reload\nFROM golang:1.21-alpine\n\nRUN apk add --no-cache git ca-certificates tzdata\n\n# Install air for hot reloading\nRUN go install github.com/cosmtrek/air@latest\n\nWORKDIR /app\n\n# Copy go mod files and download deps\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Copy source code\nCOPY . .\n\n# Expose port\nEXPOSE 8000\n\n# Command for development\nCMD [\"air\", \"-c\", \".air.toml\"]\n</code></pre>"},{"location":"develop/go/building/#build-optimization","title":"Build Optimization","text":""},{"location":"develop/go/building/#compiler-optimizations","title":"Compiler Optimizations","text":"<pre><code># Size optimization\ngo build -ldflags \"-w -s\" -trimpath\n\n# Performance optimization  \ngo build -ldflags \"-w -s\" -trimpath -gcflags \"-B\"\n\n# Link-time optimization (experimental)\ngo build -ldflags \"-w -s\" -trimpath -buildmode=pie\n\n# Profile-guided optimization (Go 1.21+)\ngo build -pgo=auto -ldflags \"-w -s\" -trimpath\n</code></pre>"},{"location":"develop/go/building/#build-caching","title":"Build Caching","text":"<pre><code># Enable build cache\nexport GOCACHE=$(go env GOCACHE)\n\n# Module cache\nexport GOMODCACHE=$(go env GOMODCACHE)\n\n# Docker build cache\ndocker build --build-arg BUILDKIT_INLINE_CACHE=1 .\n</code></pre>"},{"location":"develop/go/building/#binary-analysis","title":"Binary Analysis","text":""},{"location":"develop/go/building/#size-analysis-script","title":"Size Analysis Script","text":"<pre><code>#!/bin/bash\n# scripts/analyze-binary.sh\n\nBINARY=${1:-mcp-server}\n\nif [ ! -f \"$BINARY\" ]; then\n    echo \"Binary $BINARY not found\"\n    exit 1\nfi\n\necho \"=== Binary Analysis for $BINARY ===\"\necho\n\necho \"File size:\"\nls -lh \"$BINARY\" | awk '{print $5}'\necho\n\necho \"Symbols (top 20):\"\ngo tool nm \"$BINARY\" | grep -E ' T | D | B ' | sort -k3 -nr | head -20\necho\n\necho \"Build info:\"\ngo version -m \"$BINARY\"\necho\n\necho \"Dependencies:\"\ngo tool nm \"$BINARY\" | grep -o 'github.com/[^/]*/[^/]*' | sort | uniq -c | sort -nr | head -10\n</code></pre>"},{"location":"develop/go/building/#security-scanning","title":"Security Scanning","text":"<pre><code>#!/bin/bash\n# scripts/security-scan.sh\n\necho \"=== Security Analysis ===\"\n\n# Check for hardcoded secrets\necho \"Checking for hardcoded secrets...\"\ntruffleHog --regex --entropy=False .\n\n# Scan dependencies for vulnerabilities\necho \"Scanning dependencies...\"\ngo list -json -m all | nancy sleuth\n\n# Static analysis\necho \"Running static analysis...\"\ngosec ./...\n\n# Container security scan (if image built)\nif [ \"$1\" = \"container\" ]; then\n    echo \"Scanning container image...\"\n    trivy image mcp-server:latest\nfi\n</code></pre>"},{"location":"develop/go/building/#performance-optimization","title":"Performance Optimization","text":""},{"location":"develop/go/building/#build-time-profiling","title":"Build-Time Profiling","text":"<pre><code>// build_profile.go - build with profiling enabled\n//go:build profile\n\npackage main\n\nimport (\n    _ \"net/http/pprof\"\n    \"net/http\"\n    \"log\"\n)\n\nfunc init() {\n    go func() {\n        log.Println(\"Starting profile server on :6060\")\n        log.Println(http.ListenAndServe(\":6060\", nil))\n    }()\n}\n</code></pre>"},{"location":"develop/go/building/#memory-optimization","title":"Memory Optimization","text":"<pre><code># Build with memory optimization\ngo build -gcflags \"-l=4\" -ldflags \"-w -s\" -trimpath\n\n# Runtime memory tuning\nexport GOGC=100\nexport GOMEMLIMIT=1GiB\nexport GOMAXPROCS=4\n</code></pre>"},{"location":"develop/go/building/#deployment-scripts","title":"Deployment Scripts","text":""},{"location":"develop/go/building/#systemd-service","title":"Systemd Service","text":"<pre><code># /etc/systemd/system/mcp-server.service\n[Unit]\nDescription=MCP Server\nAfter=network.target\nWants=network.target\n\n[Service]\nType=simple\nUser=mcp\nGroup=mcp\nWorkingDirectory=/opt/mcp-server\nExecStart=/opt/mcp-server/mcp-server\nRestart=always\nRestartSec=5\nStandardOutput=journal\nStandardError=journal\nSyslogIdentifier=mcp-server\n\n# Security settings\nNoNewPrivileges=true\nProtectSystem=strict\nProtectHome=true\nReadWritePaths=/var/log/mcp-server\n\n# Environment\nEnvironment=MCP_LOG_LEVEL=info\nEnvironment=MCP_TRANSPORT=http\nEnvironment=MCP_HTTP_ADDR=:8000\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"develop/go/building/#installation-script","title":"Installation Script","text":"<pre><code>#!/bin/bash\n# scripts/install.sh\n\nset -e\n\n# Configuration\nUSER=\"mcp\"\nGROUP=\"mcp\"\nINSTALL_DIR=\"/opt/mcp-server\"\nSERVICE_NAME=\"mcp-server\"\n\n# Check if running as root\nif [ \"$EUID\" -ne 0 ]; then\n    echo \"Please run as root\"\n    exit 1\nfi\n\n# Create user and group\nif ! id \"$USER\" &amp;&gt;/dev/null; then\n    useradd -r -s /bin/false -d \"$INSTALL_DIR\" \"$USER\"\nfi\n\n# Create installation directory\nmkdir -p \"$INSTALL_DIR\"\nmkdir -p \"/var/log/$SERVICE_NAME\"\n\n# Copy binary\ncp mcp-server \"$INSTALL_DIR/\"\nchmod +x \"$INSTALL_DIR/mcp-server\"\n\n# Set ownership\nchown -R \"$USER:$GROUP\" \"$INSTALL_DIR\"\nchown -R \"$USER:$GROUP\" \"/var/log/$SERVICE_NAME\"\n\n# Install systemd service\ncp scripts/mcp-server.service /etc/systemd/system/\nsystemctl daemon-reload\nsystemctl enable \"$SERVICE_NAME\"\n\necho \"Installation complete!\"\necho \"Start the service with: systemctl start $SERVICE_NAME\"\necho \"Check status with: systemctl status $SERVICE_NAME\"\necho \"View logs with: journalctl -u $SERVICE_NAME -f\"\n</code></pre>"},{"location":"develop/go/building/#best-practices","title":"Best Practices","text":""},{"location":"develop/go/building/#build-performance","title":"Build Performance","text":"<ol> <li>Module caching: Use persistent module cache in CI/CD</li> <li>Layer caching: Optimize Docker layer caching</li> <li>Parallel builds: Use <code>GOMAXPROCS</code> for faster builds</li> <li>Incremental builds: Structure code to minimize rebuild scope</li> </ol>"},{"location":"develop/go/building/#security","title":"Security","text":"<ol> <li>Static linking: Use <code>CGO_ENABLED=0</code> for static binaries</li> <li>Strip symbols: Use <code>-ldflags \"-w -s\"</code> to reduce size</li> <li>Minimal containers: Use scratch or distroless base images</li> <li>Vulnerability scanning: Regularly scan dependencies and containers</li> </ol>"},{"location":"develop/go/building/#optimization","title":"Optimization","text":"<ol> <li>Profile-guided optimization: Use PGO for performance-critical code</li> <li>Binary compression: Consider UPX for size-constrained deployments</li> <li>Runtime tuning: Configure Go runtime parameters for deployment environment</li> <li>Health checks: Include health check endpoints in production builds</li> </ol> <p>This comprehensive building guide ensures your Go MCP server is optimized, secure, and ready for production deployment.</p>"},{"location":"develop/go/implementation/","title":"Implementation","text":""},{"location":"develop/go/implementation/#go-implementation-guide","title":"Go Implementation Guide","text":""},{"location":"develop/go/implementation/#building-mcp-servers-in-go","title":"Building MCP Servers in Go","text":"<p>This guide covers implementation patterns, best practices, and examples for building robust MCP servers using Go.</p>"},{"location":"develop/go/implementation/#core-implementation-patterns","title":"Core Implementation Patterns","text":""},{"location":"develop/go/implementation/#server-implementation","title":"Server Implementation","text":"<pre><code>// internal/server/handlers.go\npackage server\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n    \"github.com/your-org/mcp-server-go/internal/tools\"\n)\n\nfunc (s *Server) handleListTools(ctx context.Context) (*server.ListToolsResponse, error) {\n    toolList := s.toolRegistry.ListTools()\n    \n    return &amp;server.ListToolsResponse{\n        Tools: toolList,\n    }, nil\n}\n\nfunc (s *Server) handleCallTool(ctx context.Context, req *server.CallToolRequest) (*server.CallToolResponse, error) {\n    log.Printf(\"Calling tool: %s with arguments: %v\", req.Params.Name, req.Params.Arguments)\n    \n    content, err := s.toolRegistry.CallTool(ctx, req.Params.Name, req.Params.Arguments)\n    if err != nil {\n        return nil, fmt.Errorf(\"tool execution failed: %w\", err)\n    }\n\n    return &amp;server.CallToolResponse{\n        Content: content,\n    }, nil\n}\n\nfunc (s *Server) handleListResources(ctx context.Context) (*server.ListResourcesResponse, error) {\n    resources := s.resourceRegistry.ListResources()\n    \n    return &amp;server.ListResourcesResponse{\n        Resources: resources,\n    }, nil\n}\n\nfunc (s *Server) handleReadResource(ctx context.Context, req *server.ReadResourceRequest) (*server.ReadResourceResponse, error) {\n    content, err := s.resourceRegistry.ReadResource(ctx, req.Params.URI)\n    if err != nil {\n        return nil, fmt.Errorf(\"resource read failed: %w\", err)\n    }\n\n    return &amp;server.ReadResourceResponse{\n        Contents: content,\n    }, nil\n}\n</code></pre>"},{"location":"develop/go/implementation/#advanced-tool-implementation","title":"Advanced Tool Implementation","text":"<pre><code>// internal/tools/database.go\npackage tools\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"encoding/json\"\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n    _ \"github.com/lib/pq\" // PostgreSQL driver\n)\n\ntype DatabaseTool struct {\n    db *sql.DB\n}\n\nfunc NewDatabaseTool(databaseURL string) (*DatabaseTool, error) {\n    db, err := sql.Open(\"postgres\", databaseURL)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to connect to database: %w\", err)\n    }\n\n    if err := db.Ping(); err != nil {\n        return nil, fmt.Errorf(\"failed to ping database: %w\", err)\n    }\n\n    return &amp;DatabaseTool{db: db}, nil\n}\n\nfunc (t *DatabaseTool) Name() string {\n    return \"query_database\"\n}\n\nfunc (t *DatabaseTool) Description() string {\n    return \"Execute SQL queries against the database. Only SELECT statements are allowed.\"\n}\n\nfunc (t *DatabaseTool) InputSchema() map[string]interface{} {\n    return map[string]interface{}{\n        \"type\": \"object\",\n        \"properties\": map[string]interface{}{\n            \"query\": map[string]interface{}{\n                \"type\":        \"string\",\n                \"description\": \"SQL query to execute (SELECT only)\",\n            },\n            \"limit\": map[string]interface{}{\n                \"type\":        \"integer\",\n                \"description\": \"Maximum number of rows to return\",\n                \"default\":     100,\n                \"minimum\":     1,\n                \"maximum\":     1000,\n            },\n        },\n        \"required\": []string{\"query\"},\n    }\n}\n\nfunc (t *DatabaseTool) Execute(ctx context.Context, arguments map[string]interface{}) ([]server.Content, error) {\n    query, ok := arguments[\"query\"].(string)\n    if !ok {\n        return nil, fmt.Errorf(\"query argument must be a string\")\n    }\n\n    // Security: Only allow SELECT statements\n    if err := t.validateQuery(query); err != nil {\n        return nil, err\n    }\n\n    limit := 100\n    if l, ok := arguments[\"limit\"].(float64); ok {\n        limit = int(l)\n    }\n\n    // Add LIMIT clause if not present\n    if !strings.Contains(strings.ToUpper(query), \"LIMIT\") {\n        query = fmt.Sprintf(\"%s LIMIT %d\", query, limit)\n    }\n\n    rows, err := t.db.QueryContext(ctx, query)\n    if err != nil {\n        return nil, fmt.Errorf(\"query execution failed: %w\", err)\n    }\n    defer rows.Close()\n\n    results, err := t.scanRows(rows)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to scan results: %w\", err)\n    }\n\n    resultJSON, err := json.MarshalIndent(results, \"\", \"  \")\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to marshal results: %w\", err)\n    }\n\n    return []server.Content{\n        {\n            Type: \"text\",\n            Text: string(resultJSON),\n        },\n    }, nil\n}\n\nfunc (t *DatabaseTool) validateQuery(query string) error {\n    upperQuery := strings.ToUpper(strings.TrimSpace(query))\n    \n    // Only allow SELECT statements\n    if !strings.HasPrefix(upperQuery, \"SELECT\") {\n        return fmt.Errorf(\"only SELECT statements are allowed\")\n    }\n\n    // Block dangerous keywords\n    dangerousKeywords := []string{\n        \"DROP\", \"DELETE\", \"INSERT\", \"UPDATE\", \"ALTER\", \n        \"CREATE\", \"TRUNCATE\", \"REPLACE\", \"MERGE\",\n    }\n\n    for _, keyword := range dangerousKeywords {\n        if strings.Contains(upperQuery, keyword) {\n            return fmt.Errorf(\"query contains forbidden keyword: %s\", keyword)\n        }\n    }\n\n    return nil\n}\n\nfunc (t *DatabaseTool) scanRows(rows *sql.Rows) ([]map[string]interface{}, error) {\n    columns, err := rows.Columns()\n    if err != nil {\n        return nil, err\n    }\n\n    var results []map[string]interface{}\n\n    for rows.Next() {\n        values := make([]interface{}, len(columns))\n        valuePtrs := make([]interface{}, len(columns))\n        \n        for i := range columns {\n            valuePtrs[i] = &amp;values[i]\n        }\n\n        if err := rows.Scan(valuePtrs...); err != nil {\n            return nil, err\n        }\n\n        row := make(map[string]interface{})\n        for i, col := range columns {\n            row[col] = t.convertValue(values[i])\n        }\n\n        results = append(results, row)\n    }\n\n    return results, rows.Err()\n}\n\nfunc (t *DatabaseTool) convertValue(value interface{}) interface{} {\n    if value == nil {\n        return nil\n    }\n\n    switch v := value.(type) {\n    case []byte:\n        return string(v)\n    default:\n        return v\n    }\n}\n\nfunc (t *DatabaseTool) Close() error {\n    return t.db.Close()\n}\n</code></pre>"},{"location":"develop/go/implementation/#http-client-tool","title":"HTTP Client Tool","text":"<pre><code>// internal/tools/http.go\npackage tools\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"net/url\"\n    \"time\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n)\n\ntype HTTPTool struct {\n    client *http.Client\n}\n\nfunc NewHTTPTool() *HTTPTool {\n    return &amp;HTTPTool{\n        client: &amp;http.Client{\n            Timeout: 30 * time.Second,\n        },\n    }\n}\n\nfunc (t *HTTPTool) Name() string {\n    return \"http_request\"\n}\n\nfunc (t *HTTPTool) Description() string {\n    return \"Make HTTP requests to external APIs. Supports GET, POST, PUT, DELETE methods.\"\n}\n\nfunc (t *HTTPTool) InputSchema() map[string]interface{} {\n    return map[string]interface{}{\n        \"type\": \"object\",\n        \"properties\": map[string]interface{}{\n            \"method\": map[string]interface{}{\n                \"type\":        \"string\",\n                \"enum\":        []string{\"GET\", \"POST\", \"PUT\", \"DELETE\"},\n                \"description\": \"HTTP method to use\",\n                \"default\":     \"GET\",\n            },\n            \"url\": map[string]interface{}{\n                \"type\":        \"string\",\n                \"description\": \"URL to make the request to\",\n                \"format\":      \"uri\",\n            },\n            \"headers\": map[string]interface{}{\n                \"type\":        \"object\",\n                \"description\": \"HTTP headers to include\",\n            },\n            \"body\": map[string]interface{}{\n                \"type\":        \"string\",\n                \"description\": \"Request body (for POST/PUT requests)\",\n            },\n            \"timeout\": map[string]interface{}{\n                \"type\":        \"integer\",\n                \"description\": \"Request timeout in seconds\",\n                \"default\":     30,\n                \"minimum\":     1,\n                \"maximum\":     300,\n            },\n        },\n        \"required\": []string{\"url\"},\n    }\n}\n\nfunc (t *HTTPTool) Execute(ctx context.Context, arguments map[string]interface{}) ([]server.Content, error) {\n    reqURL, ok := arguments[\"url\"].(string)\n    if !ok {\n        return nil, fmt.Errorf(\"url argument must be a string\")\n    }\n\n    // Validate URL\n    if _, err := url.Parse(reqURL); err != nil {\n        return nil, fmt.Errorf(\"invalid URL: %w\", err)\n    }\n\n    method := \"GET\"\n    if m, ok := arguments[\"method\"].(string); ok {\n        method = m\n    }\n\n    // Set timeout\n    timeout := 30 * time.Second\n    if t, ok := arguments[\"timeout\"].(float64); ok {\n        timeout = time.Duration(t) * time.Second\n    }\n\n    client := &amp;http.Client{Timeout: timeout}\n\n    // Prepare request body\n    var body io.Reader\n    if b, ok := arguments[\"body\"].(string); ok &amp;&amp; b != \"\" {\n        body = bytes.NewReader([]byte(b))\n    }\n\n    req, err := http.NewRequestWithContext(ctx, method, reqURL, body)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create request: %w\", err)\n    }\n\n    // Add headers\n    if headers, ok := arguments[\"headers\"].(map[string]interface{}); ok {\n        for key, value := range headers {\n            if strValue, ok := value.(string); ok {\n                req.Header.Set(key, strValue)\n            }\n        }\n    }\n\n    // Set default content type for POST/PUT\n    if (method == \"POST\" || method == \"PUT\") &amp;&amp; req.Header.Get(\"Content-Type\") == \"\" {\n        req.Header.Set(\"Content-Type\", \"application/json\")\n    }\n\n    resp, err := client.Do(req)\n    if err != nil {\n        return nil, fmt.Errorf(\"request failed: %w\", err)\n    }\n    defer resp.Body.Close()\n\n    responseBody, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to read response body: %w\", err)\n    }\n\n    result := map[string]interface{}{\n        \"status_code\": resp.StatusCode,\n        \"status\":      resp.Status,\n        \"headers\":     resp.Header,\n        \"body\":        string(responseBody),\n    }\n\n    resultJSON, err := json.MarshalIndent(result, \"\", \"  \")\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to marshal response: %w\", err)\n    }\n\n    return []server.Content{\n        {\n            Type: \"text\",\n            Text: string(resultJSON),\n        },\n    }, nil\n}\n</code></pre>"},{"location":"develop/go/implementation/#file-system-tool","title":"File System Tool","text":"<pre><code>// internal/tools/filesystem.go\npackage tools\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n)\n\ntype FileSystemTool struct {\n    allowedPaths []string\n}\n\nfunc NewFileSystemTool(allowedPaths []string) *FileSystemTool {\n    return &amp;FileSystemTool{\n        allowedPaths: allowedPaths,\n    }\n}\n\nfunc (t *FileSystemTool) Name() string {\n    return \"read_file\"\n}\n\nfunc (t *FileSystemTool) Description() string {\n    return \"Read the contents of a text file from the filesystem.\"\n}\n\nfunc (t *FileSystemTool) InputSchema() map[string]interface{} {\n    return map[string]interface{}{\n        \"type\": \"object\",\n        \"properties\": map[string]interface{}{\n            \"path\": map[string]interface{}{\n                \"type\":        \"string\",\n                \"description\": \"Path to the file to read\",\n            },\n        },\n        \"required\": []string{\"path\"},\n    }\n}\n\nfunc (t *FileSystemTool) Execute(ctx context.Context, arguments map[string]interface{}) ([]server.Content, error) {\n    filePath, ok := arguments[\"path\"].(string)\n    if !ok {\n        return nil, fmt.Errorf(\"path argument must be a string\")\n    }\n\n    // Security: Validate file path\n    if err := t.validatePath(filePath); err != nil {\n        return nil, err\n    }\n\n    content, err := os.ReadFile(filePath)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil, fmt.Errorf(\"file not found: %s\", filePath)\n        }\n        if os.IsPermission(err) {\n            return nil, fmt.Errorf(\"permission denied: %s\", filePath)\n        }\n        return nil, fmt.Errorf(\"failed to read file: %w\", err)\n    }\n\n    return []server.Content{\n        {\n            Type: \"text\",\n            Text: string(content),\n        },\n    }, nil\n}\n\nfunc (t *FileSystemTool) validatePath(filePath string) error {\n    // Prevent path traversal attacks\n    if strings.Contains(filePath, \"..\") {\n        return fmt.Errorf(\"path traversal not allowed\")\n    }\n\n    // Check if path is within allowed directories\n    if len(t.allowedPaths) &gt; 0 {\n        absPath, err := filepath.Abs(filePath)\n        if err != nil {\n            return fmt.Errorf(\"invalid path: %w\", err)\n        }\n\n        allowed := false\n        for _, allowedPath := range t.allowedPaths {\n            absAllowed, err := filepath.Abs(allowedPath)\n            if err != nil {\n                continue\n            }\n\n            if strings.HasPrefix(absPath, absAllowed) {\n                allowed = true\n                break\n            }\n        }\n\n        if !allowed {\n            return fmt.Errorf(\"path not in allowed directories: %s\", filePath)\n        }\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"develop/go/implementation/#resource-implementation","title":"Resource Implementation","text":"<pre><code>// internal/resources/config.go\npackage resources\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n    \"github.com/your-org/mcp-server-go/internal/config\"\n)\n\ntype ConfigResource struct {\n    config *config.Config\n}\n\nfunc NewConfigResource(cfg *config.Config) *ConfigResource {\n    return &amp;ConfigResource{config: cfg}\n}\n\nfunc (r *ConfigResource) ListResources() []server.Resource {\n    return []server.Resource{\n        {\n            URI:         \"config://server\",\n            Name:        \"Server Configuration\",\n            Description: \"Current server configuration settings\",\n            MimeType:    \"application/json\",\n        },\n        {\n            URI:         \"config://database\",\n            Name:        \"Database Configuration\", \n            Description: \"Database connection settings\",\n            MimeType:    \"application/json\",\n        },\n    }\n}\n\nfunc (r *ConfigResource) ReadResource(ctx context.Context, uri string) ([]server.ResourceContent, error) {\n    switch uri {\n    case \"config://server\":\n        return r.getServerConfig()\n    case \"config://database\":\n        return r.getDatabaseConfig()\n    default:\n        return nil, fmt.Errorf(\"unknown resource URI: %s\", uri)\n    }\n}\n\nfunc (r *ConfigResource) getServerConfig() ([]server.ResourceContent, error) {\n    configData := map[string]interface{}{\n        \"server_name\": r.config.ServerName,\n        \"version\":     r.config.Version,\n        \"transport\":   r.config.Transport,\n        \"http_addr\":   r.config.HTTPAddr,\n        \"log_level\":   r.config.LogLevel,\n        \"log_format\":  r.config.LogFormat,\n    }\n\n    jsonData, err := json.MarshalIndent(configData, \"\", \"  \")\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to marshal server config: %w\", err)\n    }\n\n    return []server.ResourceContent{\n        {\n            URI:      \"config://server\",\n            MimeType: \"application/json\",\n            Text:     string(jsonData),\n        },\n    }, nil\n}\n\nfunc (r *ConfigResource) getDatabaseConfig() ([]server.ResourceContent, error) {\n    // Don't expose sensitive information like passwords\n    configData := map[string]interface{}{\n        \"max_conns\":    r.config.Database.MaxConns,\n        \"max_idle\":     r.config.Database.MaxIdle,\n        \"conn_timeout\": r.config.Database.ConnTimeout,\n        \"url_scheme\":   \"postgresql\", // Only show scheme, not full URL\n    }\n\n    jsonData, err := json.MarshalIndent(configData, \"\", \"  \")\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to marshal database config: %w\", err)\n    }\n\n    return []server.ResourceContent{\n        {\n            URI:      \"config://database\",\n            MimeType: \"application/json\",\n            Text:     string(jsonData),\n        },\n    }, nil\n}\n</code></pre>"},{"location":"develop/go/implementation/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"develop/go/implementation/#custom-error-types","title":"Custom Error Types","text":"<pre><code>// internal/errors/errors.go\npackage errors\n\nimport \"fmt\"\n\ntype MCPError struct {\n    Code    string\n    Message string\n    Err     error\n}\n\nfunc (e *MCPError) Error() string {\n    if e.Err != nil {\n        return fmt.Sprintf(\"%s: %s: %v\", e.Code, e.Message, e.Err)\n    }\n    return fmt.Sprintf(\"%s: %s\", e.Code, e.Message)\n}\n\nfunc (e *MCPError) Unwrap() error {\n    return e.Err\n}\n\n// Common error types\nfunc NewValidationError(message string, err error) *MCPError {\n    return &amp;MCPError{\n        Code:    \"VALIDATION_ERROR\",\n        Message: message,\n        Err:     err,\n    }\n}\n\nfunc NewExecutionError(message string, err error) *MCPError {\n    return &amp;MCPError{\n        Code:    \"EXECUTION_ERROR\",\n        Message: message,\n        Err:     err,\n    }\n}\n\nfunc NewPermissionError(message string) *MCPError {\n    return &amp;MCPError{\n        Code:    \"PERMISSION_ERROR\",\n        Message: message,\n    }\n}\n</code></pre>"},{"location":"develop/go/implementation/#logging-implementation","title":"Logging Implementation","text":"<pre><code>// internal/logging/logger.go\npackage logging\n\nimport (\n    \"context\"\n    \"log/slog\"\n    \"os\"\n)\n\ntype Logger struct {\n    *slog.Logger\n}\n\nfunc New(level string, format string) *Logger {\n    var handler slog.Handler\n\n    opts := &amp;slog.HandlerOptions{\n        Level: parseLevel(level),\n    }\n\n    switch format {\n    case \"json\":\n        handler = slog.NewJSONHandler(os.Stdout, opts)\n    default:\n        handler = slog.NewTextHandler(os.Stdout, opts)\n    }\n\n    return &amp;Logger{\n        Logger: slog.New(handler),\n    }\n}\n\nfunc parseLevel(level string) slog.Level {\n    switch level {\n    case \"debug\":\n        return slog.LevelDebug\n    case \"info\":\n        return slog.LevelInfo\n    case \"warn\":\n        return slog.LevelWarn\n    case \"error\":\n        return slog.LevelError\n    default:\n        return slog.LevelInfo\n    }\n}\n\nfunc (l *Logger) WithRequest(ctx context.Context, requestID string) *slog.Logger {\n    return l.With(\"request_id\", requestID)\n}\n</code></pre>"},{"location":"develop/go/implementation/#testing-helpers","title":"Testing Helpers","text":"<pre><code>// internal/testutil/testutil.go\npackage testutil\n\nimport (\n    \"context\"\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/your-org/mcp-server-go/internal/config\"\n    \"github.com/your-org/mcp-server-go/internal/server\"\n)\n\nfunc NewTestServer(t *testing.T) *server.Server {\n    cfg := &amp;config.Config{\n        ServerName: \"test-server\",\n        Version:    \"test\",\n        Transport:  \"stdio\",\n        LogLevel:   \"debug\",\n    }\n\n    srv, err := server.New(cfg)\n    assert.NoError(t, err)\n\n    return srv\n}\n\nfunc NewTestContext() context.Context {\n    return context.Background()\n}\n\ntype MockTool struct {\n    NameValue        string\n    DescriptionValue string\n    SchemaValue      map[string]interface{}\n    ExecuteFunc      func(context.Context, map[string]interface{}) ([]server.Content, error)\n}\n\nfunc (m *MockTool) Name() string {\n    return m.NameValue\n}\n\nfunc (m *MockTool) Description() string {\n    return m.DescriptionValue\n}\n\nfunc (m *MockTool) InputSchema() map[string]interface{} {\n    return m.SchemaValue\n}\n\nfunc (m *MockTool) Execute(ctx context.Context, args map[string]interface{}) ([]server.Content, error) {\n    if m.ExecuteFunc != nil {\n        return m.ExecuteFunc(ctx, args)\n    }\n    return nil, nil\n}\n</code></pre> <p>This implementation guide provides robust patterns for building production-ready MCP servers in Go with proper error handling, logging, and testing support.</p>"},{"location":"develop/go/structure/","title":"Project Structure","text":""},{"location":"develop/go/structure/#go-project-structure","title":"Go Project Structure","text":""},{"location":"develop/go/structure/#recommended-project-layout-for-go-mcp-servers","title":"Recommended Project Layout for Go MCP Servers","text":"<p>Following Go community conventions and best practices for maintainable MCP server projects.</p>"},{"location":"develop/go/structure/#standard-go-project-layout","title":"Standard Go Project Layout","text":"<pre><code>mcp-server-go/\n\u251c\u2500\u2500 cmd/\n\u2502   \u2514\u2500\u2500 server/\n\u2502       \u2514\u2500\u2500 main.go              # Application entrypoint\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 server/\n\u2502   \u2502   \u251c\u2500\u2500 server.go           # MCP server implementation\n\u2502   \u2502   \u2514\u2500\u2500 handlers.go         # Request handlers\n\u2502   \u251c\u2500\u2500 tools/\n\u2502   \u2502   \u251c\u2500\u2500 tools.go           # Tool implementations\n\u2502   \u2502   \u2514\u2500\u2500 registry.go        # Tool registration\n\u2502   \u251c\u2500\u2500 resources/\n\u2502   \u2502   \u251c\u2500\u2500 resources.go       # Resource providers\n\u2502   \u2502   \u2514\u2500\u2500 handlers.go        # Resource handlers\n\u2502   \u2514\u2500\u2500 config/\n\u2502       \u2514\u2500\u2500 config.go          # Configuration management\n\u251c\u2500\u2500 pkg/\n\u2502   \u251c\u2500\u2500 client/\n\u2502   \u2502   \u2514\u2500\u2500 client.go          # MCP client implementation (if needed)\n\u2502   \u2514\u2500\u2500 types/\n\u2502       \u2514\u2500\u2500 types.go           # Shared types\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 mcp/\n\u2502       \u2514\u2500\u2500 v1/\n\u2502           \u2514\u2500\u2500 types.go       # API type definitions\n\u251c\u2500\u2500 build/\n\u2502   \u251c\u2500\u2500 Dockerfile\n\u2502   \u2514\u2500\u2500 package/\n\u251c\u2500\u2500 scripts/\n\u2502   \u251c\u2500\u2500 build.sh\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 test/\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 testdata/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 api.md\n\u2502   \u2514\u2500\u2500 deployment.md\n\u251c\u2500\u2500 go.mod                     # Go module definition\n\u251c\u2500\u2500 go.sum                     # Dependency checksums\n\u251c\u2500\u2500 Makefile                   # Build automation\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"develop/go/structure/#core-components","title":"Core Components","text":""},{"location":"develop/go/structure/#main-entry-point","title":"Main Entry Point","text":"<pre><code>// cmd/server/main.go\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"log\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n\n    \"github.com/your-org/mcp-server-go/internal/config\"\n    \"github.com/your-org/mcp-server-go/internal/server\"\n)\n\nfunc main() {\n    var configPath = flag.String(\"config\", \"\", \"Path to configuration file\")\n    flag.Parse()\n\n    cfg, err := config.Load(*configPath)\n    if err != nil {\n        log.Fatalf(\"Failed to load configuration: %v\", err)\n    }\n\n    srv, err := server.New(cfg)\n    if err != nil {\n        log.Fatalf(\"Failed to create server: %v\", err)\n    }\n\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n\n    // Handle graceful shutdown\n    sigCh := make(chan os.Signal, 1)\n    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)\n    \n    go func() {\n        &lt;-sigCh\n        log.Println(\"Shutting down server...\")\n        cancel()\n    }()\n\n    if err := srv.Run(ctx); err != nil {\n        log.Fatalf(\"Server error: %v\", err)\n    }\n}\n</code></pre>"},{"location":"develop/go/structure/#server-implementation","title":"Server Implementation","text":"<pre><code>// internal/server/server.go\npackage server\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n    \"github.com/your-org/mcp-server-go/internal/config\"\n    \"github.com/your-org/mcp-server-go/internal/tools\"\n)\n\ntype Server struct {\n    config *config.Config\n    server *server.Server\n}\n\nfunc New(cfg *config.Config) (*Server, error) {\n    mcpServer := server.NewServer(\n        server.ServerInfo{\n            Name:    cfg.ServerName,\n            Version: cfg.Version,\n        },\n        server.ServerCapabilities{\n            Tools: &amp;server.ToolsCapability{},\n        },\n    )\n\n    s := &amp;Server{\n        config: cfg,\n        server: mcpServer,\n    }\n\n    if err := s.registerHandlers(); err != nil {\n        return nil, fmt.Errorf(\"failed to register handlers: %w\", err)\n    }\n\n    return s, nil\n}\n\nfunc (s *Server) registerHandlers() error {\n    // Register tool handlers\n    s.server.SetListToolsHandler(s.handleListTools)\n    s.server.SetCallToolHandler(s.handleCallTool)\n\n    return nil\n}\n\nfunc (s *Server) Run(ctx context.Context) error {\n    switch s.config.Transport {\n    case \"stdio\":\n        return s.server.RunStdio(ctx, os.Stdin, os.Stdout)\n    case \"http\":\n        return s.server.RunHTTP(ctx, s.config.HTTPAddr)\n    default:\n        return fmt.Errorf(\"unsupported transport: %s\", s.config.Transport)\n    }\n}\n</code></pre>"},{"location":"develop/go/structure/#configuration-management","title":"Configuration Management","text":"<pre><code>// internal/config/config.go\npackage config\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype Config struct {\n    ServerName string `json:\"server_name\" env:\"SERVER_NAME\"`\n    Version    string `json:\"version\" env:\"VERSION\"`\n    Transport  string `json:\"transport\" env:\"TRANSPORT\"`\n    HTTPAddr   string `json:\"http_addr\" env:\"HTTP_ADDR\"`\n    \n    // Database configuration\n    Database DatabaseConfig `json:\"database\"`\n    \n    // API configuration\n    APIs map[string]APIConfig `json:\"apis\"`\n    \n    // Logging\n    LogLevel  string `json:\"log_level\" env:\"LOG_LEVEL\"`\n    LogFormat string `json:\"log_format\" env:\"LOG_FORMAT\"`\n}\n\ntype DatabaseConfig struct {\n    URL         string `json:\"url\" env:\"DATABASE_URL\"`\n    MaxConns    int    `json:\"max_conns\" env:\"DATABASE_MAX_CONNS\"`\n    MaxIdle     int    `json:\"max_idle\" env:\"DATABASE_MAX_IDLE\"`\n    ConnTimeout int    `json:\"conn_timeout\" env:\"DATABASE_CONN_TIMEOUT\"`\n}\n\ntype APIConfig struct {\n    BaseURL string `json:\"base_url\"`\n    APIKey  string `json:\"api_key\"`\n    Timeout int    `json:\"timeout\"`\n}\n\nfunc Load(configPath string) (*Config, error) {\n    cfg := &amp;Config{\n        ServerName: \"mcp-server-go\",\n        Version:    \"1.0.0\",\n        Transport:  \"stdio\",\n        HTTPAddr:   \":8000\",\n        LogLevel:   \"info\",\n        LogFormat:  \"json\",\n        Database: DatabaseConfig{\n            MaxConns:    10,\n            MaxIdle:     5,\n            ConnTimeout: 30,\n        },\n    }\n\n    // Load from file if provided\n    if configPath != \"\" {\n        if err := loadFromFile(cfg, configPath); err != nil {\n            return nil, fmt.Errorf(\"failed to load config from file: %w\", err)\n        }\n    }\n\n    // Override with environment variables\n    if err := loadFromEnv(cfg); err != nil {\n        return nil, fmt.Errorf(\"failed to load config from environment: %w\", err)\n    }\n\n    return cfg, nil\n}\n\nfunc loadFromFile(cfg *Config, path string) error {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return err\n    }\n\n    return json.Unmarshal(data, cfg)\n}\n\nfunc loadFromEnv(cfg *Config) error {\n    if val := os.Getenv(\"SERVER_NAME\"); val != \"\" {\n        cfg.ServerName = val\n    }\n    if val := os.Getenv(\"VERSION\"); val != \"\" {\n        cfg.Version = val\n    }\n    if val := os.Getenv(\"TRANSPORT\"); val != \"\" {\n        cfg.Transport = val\n    }\n    if val := os.Getenv(\"HTTP_ADDR\"); val != \"\" {\n        cfg.HTTPAddr = val\n    }\n    if val := os.Getenv(\"DATABASE_URL\"); val != \"\" {\n        cfg.Database.URL = val\n    }\n    if val := os.Getenv(\"LOG_LEVEL\"); val != \"\" {\n        cfg.LogLevel = val\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"develop/go/structure/#tool-implementation","title":"Tool Implementation","text":"<pre><code>// internal/tools/tools.go\npackage tools\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n)\n\ntype ToolRegistry struct {\n    tools map[string]Tool\n}\n\ntype Tool interface {\n    Name() string\n    Description() string\n    InputSchema() map[string]interface{}\n    Execute(ctx context.Context, arguments map[string]interface{}) ([]server.Content, error)\n}\n\nfunc NewRegistry() *ToolRegistry {\n    return &amp;ToolRegistry{\n        tools: make(map[string]Tool),\n    }\n}\n\nfunc (r *ToolRegistry) Register(tool Tool) {\n    r.tools[tool.Name()] = tool\n}\n\nfunc (r *ToolRegistry) ListTools() []server.Tool {\n    var tools []server.Tool\n    \n    for _, tool := range r.tools {\n        tools = append(tools, server.Tool{\n            Name:        tool.Name(),\n            Description: tool.Description(),\n            InputSchema: tool.InputSchema(),\n        })\n    }\n    \n    return tools\n}\n\nfunc (r *ToolRegistry) CallTool(ctx context.Context, name string, arguments map[string]interface{}) ([]server.Content, error) {\n    tool, exists := r.tools[name]\n    if !exists {\n        return nil, fmt.Errorf(\"unknown tool: %s\", name)\n    }\n\n    return tool.Execute(ctx, arguments)\n}\n\n// Example tool implementation\ntype EchoTool struct{}\n\nfunc (t *EchoTool) Name() string {\n    return \"echo\"\n}\n\nfunc (t *EchoTool) Description() string {\n    return \"Echo back the provided text\"\n}\n\nfunc (t *EchoTool) InputSchema() map[string]interface{} {\n    return map[string]interface{}{\n        \"type\": \"object\",\n        \"properties\": map[string]interface{}{\n            \"text\": map[string]interface{}{\n                \"type\":        \"string\",\n                \"description\": \"Text to echo back\",\n            },\n        },\n        \"required\": []string{\"text\"},\n    }\n}\n\nfunc (t *EchoTool) Execute(ctx context.Context, arguments map[string]interface{}) ([]server.Content, error) {\n    text, ok := arguments[\"text\"].(string)\n    if !ok {\n        return nil, fmt.Errorf(\"text argument must be a string\")\n    }\n\n    return []server.Content{\n        {\n            Type: \"text\",\n            Text: fmt.Sprintf(\"Echo: %s\", text),\n        },\n    }, nil\n}\n</code></pre>"},{"location":"develop/go/structure/#go-module-configuration","title":"Go Module Configuration","text":""},{"location":"develop/go/structure/#gomod","title":"go.mod","text":"<pre><code>module github.com/your-org/mcp-server-go\n\ngo 1.21\n\nrequire (\n    github.com/modelcontextprotocol/go-sdk v0.1.0\n    github.com/stretchr/testify v1.8.4\n)\n\nrequire (\n    github.com/davecgh/go-spew v1.1.1 // indirect\n    github.com/pmezard/go-difflib v1.0.0 // indirect\n    gopkg.in/yaml.v3 v3.0.1 // indirect\n)\n</code></pre>"},{"location":"develop/go/structure/#build-configuration","title":"Build Configuration","text":""},{"location":"develop/go/structure/#makefile","title":"Makefile","text":"<pre><code>.PHONY: build test clean lint fmt vet deps\n\n# Go parameters\nGOCMD=go\nGOBUILD=$(GOCMD) build\nGOCLEAN=$(GOCMD) clean\nGOTEST=$(GOCMD) test\nGOGET=$(GOCMD) get\nGOMOD=$(GOCMD) mod\nBINARY_NAME=mcp-server\nBINARY_PATH=cmd/server\n\n# Build flags\nLDFLAGS=-ldflags \"-w -s\"\nBUILD_FLAGS=-trimpath $(LDFLAGS)\n\n# Default target\nall: test build\n\n# Build the binary\nbuild:\n\t$(GOBUILD) $(BUILD_FLAGS) -o $(BINARY_NAME) ./$(BINARY_PATH)\n\n# Build for different platforms\nbuild-linux:\n\tGOOS=linux GOARCH=amd64 $(GOBUILD) $(BUILD_FLAGS) -o $(BINARY_NAME)-linux-amd64 ./$(BINARY_PATH)\n\nbuild-windows:\n\tGOOS=windows GOARCH=amd64 $(GOBUILD) $(BUILD_FLAGS) -o $(BINARY_NAME)-windows-amd64.exe ./$(BINARY_PATH)\n\nbuild-darwin:\n\tGOOS=darwin GOARCH=amd64 $(GOBUILD) $(BUILD_FLAGS) -o $(BINARY_NAME)-darwin-amd64 ./$(BINARY_PATH)\n\n# Test\ntest:\n\t$(GOTEST) -v -race -coverprofile=coverage.out ./...\n\n# Test with coverage\ntest-coverage:\n\t$(GOTEST) -race -coverprofile=coverage.out ./...\n\t$(GOCMD) tool cover -html=coverage.out -o coverage.html\n\n# Clean\nclean:\n\t$(GOCLEAN)\n\trm -f $(BINARY_NAME)*\n\trm -f coverage.out coverage.html\n\n# Format code\nfmt:\n\t$(GOCMD) fmt ./...\n\n# Lint\nlint:\n\tgolangci-lint run\n\n# Vet\nvet:\n\t$(GOCMD) vet ./...\n\n# Update dependencies\ndeps:\n\t$(GOMOD) download\n\t$(GOMOD) tidy\n\n# Install development tools\ntools:\n\t$(GOGET) -u github.com/golangci/golangci-lint/cmd/golangci-lint\n\n# Run server\nrun:\n\t$(GOCMD) run ./$(BINARY_PATH)\n\n# Run with config\nrun-config:\n\t$(GOCMD) run ./$(BINARY_PATH) -config=config.json\n\n# Install binary\ninstall:\n\t$(GOCMD) install $(BUILD_FLAGS) ./$(BINARY_PATH)\n</code></pre>"},{"location":"develop/go/structure/#best-practices","title":"Best Practices","text":""},{"location":"develop/go/structure/#project-organization","title":"Project Organization","text":"<ol> <li>cmd/: Application entrypoints</li> <li>internal/: Private application code</li> <li>pkg/: Library code for external use</li> <li>api/: API definitions and generated code</li> <li>build/: Packaging and CI configuration</li> </ol>"},{"location":"develop/go/structure/#code-structure","title":"Code Structure","text":"<ol> <li>Interfaces: Define clear interfaces for testability</li> <li>Dependency Injection: Use constructor injection</li> <li>Error Handling: Return errors, don't panic</li> <li>Context: Pass context.Context for cancellation</li> </ol>"},{"location":"develop/go/structure/#naming-conventions","title":"Naming Conventions","text":"<ol> <li>Packages: Short, lowercase, single word</li> <li>Files: Snake_case for multi-word names</li> <li>Functions: CamelCase, exported functions capitalized</li> <li>Constants: CamelCase or ALL_CAPS for package-level</li> </ol> <p>This structure provides a solid foundation for building scalable and maintainable MCP servers in Go.</p>"},{"location":"develop/go/testing/","title":"Testing","text":""},{"location":"develop/go/testing/#go-testing-guide","title":"Go Testing Guide","text":""},{"location":"develop/go/testing/#testing-strategies-for-go-mcp-servers","title":"Testing Strategies for Go MCP Servers","text":"<p>Comprehensive testing ensures your Go MCP server is reliable, maintainable, and performs well under various conditions.</p>"},{"location":"develop/go/testing/#testing-stack","title":"Testing Stack","text":""},{"location":"develop/go/testing/#core-testing-dependencies","title":"Core Testing Dependencies","text":"<pre><code>// go.mod\nmodule github.com/your-org/mcp-server-go\n\ngo 1.21\n\nrequire (\n    github.com/modelcontextprotocol/go-sdk v0.1.0\n    github.com/stretchr/testify v1.8.4\n    github.com/DATA-DOG/go-sqlmock v1.5.0\n    github.com/jarcoal/httpmock v1.3.1\n    github.com/golang/mock v1.6.0\n)\n\nrequire (\n    github.com/davecgh/go-spew v1.1.1 // indirect\n    github.com/pmezard/go-difflib v1.0.0 // indirect\n    gopkg.in/yaml.v3 v3.0.1 // indirect\n)\n</code></pre>"},{"location":"develop/go/testing/#test-configuration","title":"Test Configuration","text":"<pre><code>// internal/testutil/config.go\npackage testutil\n\nimport (\n    \"os\"\n    \"path/filepath\"\n    \"testing\"\n\n    \"github.com/stretchr/testify/require\"\n    \"github.com/your-org/mcp-server-go/internal/config\"\n)\n\n// NewTestConfig creates a configuration suitable for testing\nfunc NewTestConfig(t *testing.T) *config.Config {\n    tmpDir := t.TempDir()\n    \n    return &amp;config.Config{\n        ServerName:  \"test-server\",\n        Version:     \"test\",\n        Transport:   \"stdio\",\n        HTTPAddr:    \":0\", // Random available port\n        LogLevel:    \"debug\",\n        LogFormat:   \"text\",\n        Database: config.DatabaseConfig{\n            URL:         \"sqlite://file:test.db?mode=memory&amp;cache=shared\",\n            MaxConns:    1,\n            MaxIdle:     1,\n            ConnTimeout: 5,\n        },\n    }\n}\n\n// SetupTestDir creates a temporary directory for testing\nfunc SetupTestDir(t *testing.T, files map[string]string) string {\n    tmpDir := t.TempDir()\n    \n    for filename, content := range files {\n        filePath := filepath.Join(tmpDir, filename)\n        require.NoError(t, os.MkdirAll(filepath.Dir(filePath), 0755))\n        require.NoError(t, os.WriteFile(filePath, []byte(content), 0644))\n    }\n    \n    return tmpDir\n}\n</code></pre>"},{"location":"develop/go/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"develop/go/testing/#testing-tool-implementations","title":"Testing Tool Implementations","text":"<pre><code>// internal/tools/echo_test.go\npackage tools\n\nimport (\n    \"context\"\n    \"testing\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc TestEchoTool_Name(t *testing.T) {\n    tool := &amp;EchoTool{}\n    assert.Equal(t, \"echo\", tool.Name())\n}\n\nfunc TestEchoTool_Description(t *testing.T) {\n    tool := &amp;EchoTool{}\n    assert.NotEmpty(t, tool.Description())\n}\n\nfunc TestEchoTool_InputSchema(t *testing.T) {\n    tool := &amp;EchoTool{}\n    schema := tool.InputSchema()\n    \n    assert.Equal(t, \"object\", schema[\"type\"])\n    \n    properties, ok := schema[\"properties\"].(map[string]interface{})\n    require.True(t, ok)\n    \n    textProp, ok := properties[\"text\"].(map[string]interface{})\n    require.True(t, ok)\n    assert.Equal(t, \"string\", textProp[\"type\"])\n    \n    required, ok := schema[\"required\"].([]string)\n    require.True(t, ok)\n    assert.Contains(t, required, \"text\")\n}\n\nfunc TestEchoTool_Execute(t *testing.T) {\n    tests := []struct {\n        name      string\n        arguments map[string]interface{}\n        wantErr   bool\n        wantText  string\n    }{\n        {\n            name:      \"valid text\",\n            arguments: map[string]interface{}{\"text\": \"Hello, World!\"},\n            wantErr:   false,\n            wantText:  \"Echo: Hello, World!\",\n        },\n        {\n            name:      \"empty text\",\n            arguments: map[string]interface{}{\"text\": \"\"},\n            wantErr:   false,\n            wantText:  \"Echo: \",\n        },\n        {\n            name:      \"missing text argument\",\n            arguments: map[string]interface{}{},\n            wantErr:   true,\n        },\n        {\n            name:      \"invalid text type\",\n            arguments: map[string]interface{}{\"text\": 123},\n            wantErr:   true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            tool := &amp;EchoTool{}\n            ctx := context.Background()\n            \n            result, err := tool.Execute(ctx, tt.arguments)\n            \n            if tt.wantErr {\n                assert.Error(t, err)\n                assert.Nil(t, result)\n            } else {\n                assert.NoError(t, err)\n                require.Len(t, result, 1)\n                assert.Equal(t, \"text\", result[0].Type)\n                assert.Equal(t, tt.wantText, result[0].Text)\n            }\n        })\n    }\n}\n\nfunc TestEchoTool_ExecuteWithContext(t *testing.T) {\n    tool := &amp;EchoTool{}\n    \n    // Test context cancellation\n    ctx, cancel := context.WithCancel(context.Background())\n    cancel()\n    \n    arguments := map[string]interface{}{\"text\": \"test\"}\n    result, err := tool.Execute(ctx, arguments)\n    \n    // Echo tool doesn't check context, so it should still work\n    assert.NoError(t, err)\n    assert.Len(t, result, 1)\n}\n</code></pre>"},{"location":"develop/go/testing/#testing-database-tools-with-mocks","title":"Testing Database Tools with Mocks","text":"<pre><code>// internal/tools/database_test.go\npackage tools\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"testing\"\n\n    \"github.com/DATA-DOG/go-sqlmock\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc TestDatabaseTool_Execute(t *testing.T) {\n    // Create mock database\n    db, mock, err := sqlmock.New()\n    require.NoError(t, err)\n    defer db.Close()\n\n    tool := &amp;DatabaseTool{db: db}\n\n    tests := []struct {\n        name        string\n        arguments   map[string]interface{}\n        setupMock   func(sqlmock.Sqlmock)\n        wantErr     bool\n        wantResults int\n    }{\n        {\n            name:      \"valid select query\",\n            arguments: map[string]interface{}{\"query\": \"SELECT id, name FROM users\"},\n            setupMock: func(m sqlmock.Sqlmock) {\n                rows := sqlmock.NewRows([]string{\"id\", \"name\"}).\n                    AddRow(1, \"Alice\").\n                    AddRow(2, \"Bob\")\n                m.ExpectQuery(\"SELECT id, name FROM users LIMIT 100\").WillReturnRows(rows)\n            },\n            wantErr:     false,\n            wantResults: 1,\n        },\n        {\n            name:      \"invalid query - not SELECT\",\n            arguments: map[string]interface{}{\"query\": \"DELETE FROM users\"},\n            setupMock: func(m sqlmock.Sqlmock) {\n                // No mock setup needed as validation should fail first\n            },\n            wantErr: true,\n        },\n        {\n            name:      \"database error\",\n            arguments: map[string]interface{}{\"query\": \"SELECT * FROM nonexistent\"},\n            setupMock: func(m sqlmock.Sqlmock) {\n                m.ExpectQuery(\"SELECT \\\\* FROM nonexistent LIMIT 100\").\n                    WillReturnError(sql.ErrNoRows)\n            },\n            wantErr: true,\n        },\n        {\n            name:      \"query with custom limit\",\n            arguments: map[string]interface{}{\"query\": \"SELECT * FROM users\", \"limit\": float64(50)},\n            setupMock: func(m sqlmock.Sqlmock) {\n                rows := sqlmock.NewRows([]string{\"id\"}).AddRow(1)\n                m.ExpectQuery(\"SELECT \\\\* FROM users LIMIT 50\").WillReturnRows(rows)\n            },\n            wantErr:     false,\n            wantResults: 1,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            tt.setupMock(mock)\n            \n            ctx := context.Background()\n            result, err := tool.Execute(ctx, tt.arguments)\n            \n            if tt.wantErr {\n                assert.Error(t, err)\n            } else {\n                assert.NoError(t, err)\n                assert.Len(t, result, tt.wantResults)\n            }\n            \n            // Verify all expectations were met\n            assert.NoError(t, mock.ExpectationsWereMet())\n        })\n    }\n}\n\nfunc TestDatabaseTool_validateQuery(t *testing.T) {\n    tool := &amp;DatabaseTool{}\n\n    tests := []struct {\n        name    string\n        query   string\n        wantErr bool\n    }{\n        {\n            name:    \"valid select\",\n            query:   \"SELECT * FROM users\",\n            wantErr: false,\n        },\n        {\n            name:    \"valid select with whitespace\",\n            query:   \"  SELECT id FROM users  \",\n            wantErr: false,\n        },\n        {\n            name:    \"invalid - delete\",\n            query:   \"DELETE FROM users\",\n            wantErr: true,\n        },\n        {\n            name:    \"invalid - insert\",\n            query:   \"INSERT INTO users VALUES (1, 'test')\",\n            wantErr: true,\n        },\n        {\n            name:    \"invalid - drop hidden in select\",\n            query:   \"SELECT * FROM users; DROP TABLE users;\",\n            wantErr: true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := tool.validateQuery(tt.query)\n            \n            if tt.wantErr {\n                assert.Error(t, err)\n            } else {\n                assert.NoError(t, err)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"develop/go/testing/#testing-http-tools","title":"Testing HTTP Tools","text":"<pre><code>// internal/tools/http_test.go\npackage tools\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"net/http\"\n    \"testing\"\n\n    \"github.com/jarcoal/httpmock\"\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc TestHTTPTool_Execute(t *testing.T) {\n    // Setup HTTP mock\n    httpmock.Activate()\n    defer httpmock.DeactivateAndReset()\n\n    tool := NewHTTPTool()\n\n    tests := []struct {\n        name        string\n        arguments   map[string]interface{}\n        setupMock   func()\n        wantErr     bool\n        wantStatus  int\n    }{\n        {\n            name:      \"successful GET request\",\n            arguments: map[string]interface{}{\"url\": \"http://example.com/api/users\"},\n            setupMock: func() {\n                httpmock.RegisterResponder(\"GET\", \"http://example.com/api/users\",\n                    httpmock.NewStringResponder(200, `{\"users\": [\"alice\", \"bob\"]}`))\n            },\n            wantErr:    false,\n            wantStatus: 200,\n        },\n        {\n            name: \"successful POST request\",\n            arguments: map[string]interface{}{\n                \"method\": \"POST\",\n                \"url\":    \"http://example.com/api/users\",\n                \"body\":   `{\"name\": \"charlie\"}`,\n                \"headers\": map[string]interface{}{\n                    \"Content-Type\": \"application/json\",\n                },\n            },\n            setupMock: func() {\n                httpmock.RegisterResponder(\"POST\", \"http://example.com/api/users\",\n                    httpmock.NewStringResponder(201, `{\"id\": 123, \"name\": \"charlie\"}`))\n            },\n            wantErr:    false,\n            wantStatus: 201,\n        },\n        {\n            name:      \"404 error\",\n            arguments: map[string]interface{}{\"url\": \"http://example.com/api/notfound\"},\n            setupMock: func() {\n                httpmock.RegisterResponder(\"GET\", \"http://example.com/api/notfound\",\n                    httpmock.NewStringResponder(404, `{\"error\": \"Not found\"}`))\n            },\n            wantErr:    false,\n            wantStatus: 404,\n        },\n        {\n            name:      \"invalid URL\",\n            arguments: map[string]interface{}{\"url\": \"not-a-url\"},\n            setupMock: func() {},\n            wantErr:   true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            httpmock.Reset()\n            tt.setupMock()\n            \n            ctx := context.Background()\n            result, err := tool.Execute(ctx, tt.arguments)\n            \n            if tt.wantErr {\n                assert.Error(t, err)\n            } else {\n                assert.NoError(t, err)\n                require.Len(t, result, 1)\n                \n                var response map[string]interface{}\n                err := json.Unmarshal([]byte(result[0].Text), &amp;response)\n                require.NoError(t, err)\n                \n                statusCode, ok := response[\"status_code\"].(float64)\n                require.True(t, ok)\n                assert.Equal(t, float64(tt.wantStatus), statusCode)\n            }\n        })\n    }\n}\n\nfunc TestHTTPTool_ExecuteWithTimeout(t *testing.T) {\n    httpmock.Activate()\n    defer httpmock.DeactivateAndReset()\n\n    // Setup slow response\n    httpmock.RegisterResponder(\"GET\", \"http://example.com/slow\",\n        httpmock.NewStringResponder(200, \"slow response\").Delay(100))\n\n    tool := NewHTTPTool()\n    ctx := context.Background()\n\n    arguments := map[string]interface{}{\n        \"url\":     \"http://example.com/slow\",\n        \"timeout\": float64(1), // 1 second timeout\n    }\n\n    result, err := tool.Execute(ctx, arguments)\n    \n    // Should succeed as 100ms delay is within 1 second timeout\n    assert.NoError(t, err)\n    assert.Len(t, result, 1)\n}\n</code></pre>"},{"location":"develop/go/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"develop/go/testing/#testing-complete-server","title":"Testing Complete Server","text":"<pre><code>// test/integration/server_test.go\npackage integration\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"testing\"\n\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n    \n    \"github.com/your-org/mcp-server-go/internal/config\"\n    mcpserver \"github.com/your-org/mcp-server-go/internal/server\"\n    \"github.com/your-org/mcp-server-go/internal/testutil\"\n)\n\nfunc TestServer_Integration(t *testing.T) {\n    // Setup test configuration\n    cfg := testutil.NewTestConfig(t)\n    \n    // Create server\n    srv, err := mcpserver.New(cfg)\n    require.NoError(t, err)\n\n    ctx := context.Background()\n\n    // Test tool listing\n    toolsResponse, err := srv.HandleListTools(ctx)\n    require.NoError(t, err)\n    assert.NotEmpty(t, toolsResponse.Tools)\n\n    // Test tool execution\n    callRequest := &amp;server.CallToolRequest{\n        Params: server.CallToolParams{\n            Name: \"echo\",\n            Arguments: map[string]interface{}{\n                \"text\": \"integration test\",\n            },\n        },\n    }\n\n    callResponse, err := srv.HandleCallTool(ctx, callRequest)\n    require.NoError(t, err)\n    require.Len(t, callResponse.Content, 1)\n    assert.Contains(t, callResponse.Content[0].Text, \"integration test\")\n}\n\nfunc TestServer_ErrorHandling(t *testing.T) {\n    cfg := testutil.NewTestConfig(t)\n    srv, err := mcpserver.New(cfg)\n    require.NoError(t, err)\n\n    ctx := context.Background()\n\n    // Test unknown tool\n    callRequest := &amp;server.CallToolRequest{\n        Params: server.CallToolParams{\n            Name:      \"nonexistent_tool\",\n            Arguments: map[string]interface{}{},\n        },\n    }\n\n    _, err = srv.HandleCallTool(ctx, callRequest)\n    assert.Error(t, err)\n    assert.Contains(t, err.Error(), \"unknown tool\")\n}\n\nfunc TestServer_ResourceHandling(t *testing.T) {\n    cfg := testutil.NewTestConfig(t)\n    srv, err := mcpserver.New(cfg)\n    require.NoError(t, err)\n\n    ctx := context.Background()\n\n    // Test resource listing\n    resourcesResponse, err := srv.HandleListResources(ctx)\n    require.NoError(t, err)\n    \n    if len(resourcesResponse.Resources) &gt; 0 {\n        // Test reading first resource\n        readRequest := &amp;server.ReadResourceRequest{\n            Params: server.ReadResourceParams{\n                URI: resourcesResponse.Resources[0].URI,\n            },\n        }\n\n        readResponse, err := srv.HandleReadResource(ctx, readRequest)\n        require.NoError(t, err)\n        assert.NotEmpty(t, readResponse.Contents)\n    }\n}\n</code></pre>"},{"location":"develop/go/testing/#testing-with-external-services","title":"Testing with External Services","text":"<pre><code>// test/integration/external_test.go\npackage integration\n\nimport (\n    \"context\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n    \n    \"github.com/your-org/mcp-server-go/internal/tools\"\n)\n\nfunc TestHTTPTool_RealServer(t *testing.T) {\n    // Create test HTTP server\n    testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusOK)\n        w.Write([]byte(`{\"message\": \"test response\"}`))\n    }))\n    defer testServer.Close()\n\n    // Test HTTP tool against real server\n    tool := tools.NewHTTPTool()\n    ctx := context.Background()\n\n    arguments := map[string]interface{}{\n        \"url\": testServer.URL,\n    }\n\n    result, err := tool.Execute(ctx, arguments)\n    require.NoError(t, err)\n    require.Len(t, result, 1)\n    \n    assert.Contains(t, result[0].Text, \"test response\")\n}\n</code></pre>"},{"location":"develop/go/testing/#benchmark-tests","title":"Benchmark Tests","text":""},{"location":"develop/go/testing/#performance-testing","title":"Performance Testing","text":"<pre><code>// internal/tools/echo_bench_test.go\npackage tools\n\nimport (\n    \"context\"\n    \"testing\"\n)\n\nfunc BenchmarkEchoTool_Execute(b *testing.B) {\n    tool := &amp;EchoTool{}\n    ctx := context.Background()\n    arguments := map[string]interface{}{\n        \"text\": \"benchmark test message\",\n    }\n\n    b.ResetTimer()\n    for i := 0; i &lt; b.N; i++ {\n        _, err := tool.Execute(ctx, arguments)\n        if err != nil {\n            b.Fatal(err)\n        }\n    }\n}\n\nfunc BenchmarkEchoTool_ExecuteParallel(b *testing.B) {\n    tool := &amp;EchoTool{}\n    arguments := map[string]interface{}{\n        \"text\": \"benchmark test message\",\n    }\n\n    b.RunParallel(func(pb *testing.PB) {\n        ctx := context.Background()\n        for pb.Next() {\n            _, err := tool.Execute(ctx, arguments)\n            if err != nil {\n                b.Fatal(err)\n            }\n        }\n    })\n}\n\nfunc BenchmarkToolRegistry_CallTool(b *testing.B) {\n    registry := NewRegistry()\n    registry.Register(&amp;EchoTool{})\n\n    ctx := context.Background()\n    arguments := map[string]interface{}{\n        \"text\": \"benchmark test\",\n    }\n\n    b.ResetTimer()\n    for i := 0; i &lt; b.N; i++ {\n        _, err := registry.CallTool(ctx, \"echo\", arguments)\n        if err != nil {\n            b.Fatal(err)\n        }\n    }\n}\n</code></pre>"},{"location":"develop/go/testing/#test-utilities-and-helpers","title":"Test Utilities and Helpers","text":""},{"location":"develop/go/testing/#mock-interfaces","title":"Mock Interfaces","text":"<pre><code>// internal/testutil/mocks.go\n//go:generate mockgen -source=../tools/tools.go -destination=mocks.go\n\npackage testutil\n\nimport (\n    \"context\"\n\n    \"github.com/golang/mock/gomock\"\n    \"github.com/modelcontextprotocol/go-sdk/server\"\n)\n\n// MockTool is a mock implementation of the Tool interface\ntype MockTool struct {\n    ctrl     *gomock.Controller\n    recorder *MockToolMockRecorder\n}\n\ntype MockToolMockRecorder struct {\n    mock *MockTool\n}\n\nfunc NewMockTool(ctrl *gomock.Controller) *MockTool {\n    mock := &amp;MockTool{ctrl: ctrl}\n    mock.recorder = &amp;MockToolMockRecorder{mock}\n    return mock\n}\n\nfunc (m *MockTool) EXPECT() *MockToolMockRecorder {\n    return m.recorder\n}\n\nfunc (m *MockTool) Name() string {\n    m.ctrl.T.Helper()\n    ret := m.ctrl.Call(m, \"Name\")\n    ret0, _ := ret[0].(string)\n    return ret0\n}\n\nfunc (mr *MockToolMockRecorder) Name() *gomock.Call {\n    mr.mock.ctrl.T.Helper()\n    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Name\", reflect.TypeOf((*MockTool)(nil).Name))\n}\n\nfunc (m *MockTool) Description() string {\n    m.ctrl.T.Helper()\n    ret := m.ctrl.Call(m, \"Description\")\n    ret0, _ := ret[0].(string)\n    return ret0\n}\n\nfunc (mr *MockToolMockRecorder) Description() *gomock.Call {\n    mr.mock.ctrl.T.Helper()\n    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Description\", reflect.TypeOf((*MockTool)(nil).Description))\n}\n\nfunc (m *MockTool) InputSchema() map[string]interface{} {\n    m.ctrl.T.Helper()\n    ret := m.ctrl.Call(m, \"InputSchema\")\n    ret0, _ := ret[0].(map[string]interface{})\n    return ret0\n}\n\nfunc (mr *MockToolMockRecorder) InputSchema() *gomock.Call {\n    mr.mock.ctrl.T.Helper()\n    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"InputSchema\", reflect.TypeOf((*MockTool)(nil).InputSchema))\n}\n\nfunc (m *MockTool) Execute(ctx context.Context, arguments map[string]interface{}) ([]server.Content, error) {\n    m.ctrl.T.Helper()\n    ret := m.ctrl.Call(m, \"Execute\", ctx, arguments)\n    ret0, _ := ret[0].([]server.Content)\n    ret1, _ := ret[1].(error)\n    return ret0, ret1\n}\n\nfunc (mr *MockToolMockRecorder) Execute(ctx, arguments interface{}) *gomock.Call {\n    mr.mock.ctrl.T.Helper()\n    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Execute\", reflect.TypeOf((*MockTool)(nil).Execute), ctx, arguments)\n}\n</code></pre>"},{"location":"develop/go/testing/#test-configuration_1","title":"Test Configuration","text":""},{"location":"develop/go/testing/#makefile-test-targets","title":"Makefile Test Targets","text":"<pre><code># Test targets\n.PHONY: test test-unit test-integration test-bench test-race test-coverage\n\n# Run all tests\ntest: test-unit test-integration\n\n# Run unit tests only\ntest-unit:\n\t$(GOTEST) -short ./...\n\n# Run integration tests\ntest-integration:\n\t$(GOTEST) -tags=integration ./test/integration/...\n\n# Run benchmark tests\ntest-bench:\n\t$(GOTEST) -bench=. -benchmem ./...\n\n# Run tests with race detection\ntest-race:\n\t$(GOTEST) -race ./...\n\n# Generate test coverage report\ntest-coverage:\n\t$(GOTEST) -race -coverprofile=coverage.out ./...\n\t$(GOCMD) tool cover -html=coverage.out -o coverage.html\n\t$(GOCMD) tool cover -func=coverage.out\n\n# Run tests with verbose output\ntest-verbose:\n\t$(GOTEST) -v ./...\n\n# Run tests for specific package\ntest-pkg:\n\t$(GOTEST) -v ./$(PKG)/...\n</code></pre>"},{"location":"develop/go/testing/#best-practices","title":"Best Practices","text":""},{"location":"develop/go/testing/#test-organization","title":"Test Organization","text":"<ol> <li>Package-level tests: Place tests in the same package as the code being tested</li> <li>Integration tests: Separate integration tests in their own package</li> <li>Test data: Use <code>testdata/</code> directories for test fixtures</li> <li>Parallel tests: Use <code>t.Parallel()</code> for independent tests</li> </ol>"},{"location":"develop/go/testing/#assertions-and-validation","title":"Assertions and Validation","text":"<ol> <li>Use testify: Leverage testify for cleaner assertions</li> <li>Descriptive names: Write clear, descriptive test function names</li> <li>Table-driven tests: Use table-driven tests for multiple scenarios</li> <li>Error checking: Always check and assert on errors appropriately</li> </ol>"},{"location":"develop/go/testing/#performance-and-reliability","title":"Performance and Reliability","text":"<ol> <li>Benchmark critical paths: Benchmark performance-critical code</li> <li>Race detection: Always run tests with race detection enabled</li> <li>Context usage: Test context cancellation and timeouts</li> <li>Resource cleanup: Ensure proper cleanup of resources in tests</li> </ol> <p>This comprehensive testing approach ensures your Go MCP server is robust, performant, and maintainable.</p>"},{"location":"develop/javascript/","title":"JavaScript Overview","text":""},{"location":"develop/javascript/#javascripttypescript-development","title":"JavaScript/TypeScript Development","text":""},{"location":"develop/javascript/#mcp-server-development-with-javascript","title":"MCP Server Development with JavaScript","text":"<p>Build MCP servers using JavaScript or TypeScript with the official SDK.</p>"},{"location":"develop/javascript/#quick-start","title":"Quick Start","text":""},{"location":"develop/javascript/#installation","title":"Installation","text":"<pre><code># npm\nnpm install @modelcontextprotocol/sdk\n\n# yarn\nyarn add @modelcontextprotocol/sdk\n\n# pnpm\npnpm add @modelcontextprotocol/sdk\n</code></pre>"},{"location":"develop/javascript/#basic-server-javascript","title":"Basic Server (JavaScript)","text":"<pre><code>const { Server } = require('@modelcontextprotocol/sdk');\n\nconst server = new Server({\n  name: 'my-js-server',\n  version: '1.0.0'\n});\n\nserver.tool('greet', {\n  description: 'Greet someone',\n  parameters: {\n    type: 'object',\n    properties: {\n      name: { type: 'string' }\n    },\n    required: ['name']\n  }\n}, async ({ name }) =&gt; {\n  return `Hello, ${name}!`;\n});\n\nserver.start();\n</code></pre>"},{"location":"develop/javascript/#typescript-server","title":"TypeScript Server","text":"<pre><code>import { Server, Tool } from '@modelcontextprotocol/sdk';\n\ninterface GreetParams {\n  name: string;\n  greeting?: string;\n}\n\nconst server = new Server({\n  name: 'my-ts-server',\n  version: '1.0.0'\n});\n\nconst greetTool: Tool&lt;GreetParams&gt; = {\n  name: 'greet',\n  description: 'Greet someone',\n  parameters: {\n    type: 'object',\n    properties: {\n      name: { type: 'string' },\n      greeting: { type: 'string', default: 'Hello' }\n    },\n    required: ['name']\n  },\n  handler: async ({ name, greeting = 'Hello' }) =&gt; {\n    return `${greeting}, ${name}!`;\n  }\n};\n\nserver.registerTool(greetTool);\nserver.start();\n</code></pre>"},{"location":"develop/javascript/#project-setup","title":"Project Setup","text":""},{"location":"develop/javascript/#packagejson","title":"Package.json","text":"<pre><code>{\n  \"name\": \"my-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsx watch src/index.ts\",\n    \"test\": \"jest\",\n    \"lint\": \"eslint src/**/*.ts\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"jest\": \"^29.0.0\",\n    \"@types/jest\": \"^29.0.0\",\n    \"eslint\": \"^8.0.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\"\n  }\n}\n</code></pre>"},{"location":"develop/javascript/#typescript-configuration","title":"TypeScript Configuration","text":"<pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"**/*.test.ts\"]\n}\n</code></pre>"},{"location":"develop/javascript/#advanced-features","title":"Advanced Features","text":""},{"location":"develop/javascript/#async-operations","title":"Async Operations","text":"<pre><code>server.tool('fetchData', {\n  description: 'Fetch data from API',\n  parameters: {\n    type: 'object',\n    properties: {\n      url: { type: 'string', format: 'uri' }\n    },\n    required: ['url']\n  }\n}, async ({ url }) =&gt; {\n  const response = await fetch(url);\n  const data = await response.json();\n  return JSON.stringify(data, null, 2);\n});\n</code></pre>"},{"location":"develop/javascript/#resource-providers","title":"Resource Providers","text":"<pre><code>server.resource('config', {\n  description: 'Server configuration',\n  handler: async () =&gt; {\n    return {\n      version: '1.0.0',\n      features: ['tools', 'resources'],\n      environment: process.env.NODE_ENV\n    };\n  }\n});\n</code></pre>"},{"location":"develop/javascript/#error-handling","title":"Error Handling","text":"<pre><code>class McpError extends Error {\n  constructor(message: string, public code: number = -32000) {\n    super(message);\n    this.name = 'McpError';\n  }\n}\n\nserver.tool('riskyOperation', {\n  // ... parameters\n}, async (params) =&gt; {\n  try {\n    return await performOperation(params);\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      throw new McpError('Invalid input', -32602);\n    }\n    throw new McpError('Operation failed', -32000);\n  }\n});\n</code></pre>"},{"location":"develop/javascript/#testing","title":"Testing","text":""},{"location":"develop/javascript/#jest-configuration","title":"Jest Configuration","text":"<pre><code>// jest.config.js\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['&lt;rootDir&gt;/src'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/**/*.test.ts'\n  ]\n};\n</code></pre>"},{"location":"develop/javascript/#unit-tests","title":"Unit Tests","text":"<pre><code>// src/__tests__/tools.test.ts\nimport { greetTool } from '../tools';\n\ndescribe('greet tool', () =&gt; {\n  it('should greet with name', async () =&gt; {\n    const result = await greetTool.handler({ name: 'Alice' });\n    expect(result).toBe('Hello, Alice!');\n  });\n\n  it('should use custom greeting', async () =&gt; {\n    const result = await greetTool.handler({ \n      name: 'Bob', \n      greeting: 'Hi' \n    });\n    expect(result).toBe('Hi, Bob!');\n  });\n});\n</code></pre>"},{"location":"develop/javascript/#deployment","title":"Deployment","text":""},{"location":"develop/javascript/#docker","title":"Docker","text":"<pre><code>FROM node:20-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY dist ./dist\n\nEXPOSE 8000\n\nCMD [\"node\", \"dist/index.js\"]\n</code></pre>"},{"location":"develop/javascript/#environment-variables","title":"Environment Variables","text":"<pre><code>const config = {\n  port: process.env.MCP_PORT || 8000,\n  apiKey: process.env.MCP_API_KEY,\n  debug: process.env.MCP_DEBUG === 'true'\n};\n\nif (!config.apiKey) {\n  throw new Error('MCP_API_KEY is required');\n}\n</code></pre>"},{"location":"develop/javascript/#performance-optimization","title":"Performance Optimization","text":""},{"location":"develop/javascript/#connection-pooling","title":"Connection Pooling","text":"<pre><code>import { Pool } from 'pg';\n\nconst pool = new Pool({\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n});\n\nserver.tool('queryDatabase', {\n  // parameters...\n}, async ({ query }) =&gt; {\n  const client = await pool.connect();\n  try {\n    const result = await client.query(query);\n    return result.rows;\n  } finally {\n    client.release();\n  }\n});\n</code></pre>"},{"location":"develop/javascript/#caching","title":"Caching","text":"<pre><code>const cache = new Map&lt;string, { data: any; expires: number }&gt;();\n\nfunction cached&lt;T&gt;(key: string, ttl: number, fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {\n  const now = Date.now();\n  const cached = cache.get(key);\n  \n  if (cached &amp;&amp; cached.expires &gt; now) {\n    return Promise.resolve(cached.data);\n  }\n  \n  return fn().then(data =&gt; {\n    cache.set(key, { data, expires: now + ttl });\n    return data;\n  });\n}\n</code></pre>"},{"location":"develop/javascript/#common-patterns","title":"Common Patterns","text":""},{"location":"develop/javascript/#middleware-pattern","title":"Middleware Pattern","text":"<pre><code>type Middleware = (context: any, next: () =&gt; Promise&lt;any&gt;) =&gt; Promise&lt;any&gt;;\n\nclass MiddlewareServer extends Server {\n  private middlewares: Middleware[] = [];\n  \n  use(middleware: Middleware) {\n    this.middlewares.push(middleware);\n  }\n  \n  async execute(context: any, handler: () =&gt; Promise&lt;any&gt;) {\n    let index = 0;\n    \n    const next = async (): Promise&lt;any&gt; =&gt; {\n      if (index &gt;= this.middlewares.length) {\n        return handler();\n      }\n      \n      const middleware = this.middlewares[index++];\n      return middleware(context, next);\n    };\n    \n    return next();\n  }\n}\n</code></pre>"},{"location":"develop/javascript/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udd37 TypeScript Best Practices</li> <li>\ud83d\ude80 Node.js Specifics</li> <li>\ud83c\udf10 Browser Integration</li> <li>\ud83e\uddea Testing Guide</li> <li>\ud83d\udce6 Packaging &amp; Distribution</li> </ul>"},{"location":"develop/javascript/browser/","title":"Browser","text":""},{"location":"develop/javascript/browser/#browser-development","title":"Browser Development","text":""},{"location":"develop/javascript/browser/#mcp-clients-in-the-browser","title":"MCP Clients in the Browser","text":"<p>Building browser-based MCP clients enables rich web applications to interact with MCP servers through various transport mechanisms.</p>"},{"location":"develop/javascript/browser/#browser-transport-options","title":"Browser Transport Options","text":""},{"location":"develop/javascript/browser/#http-transport","title":"HTTP Transport","text":"<p>The primary transport for browser-based MCP clients, using the Streamable HTTP specification.</p> <pre><code>// src/client.js\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { HTTPTransport } from '@modelcontextprotocol/sdk/client/http.js';\n\nclass BrowserMCPClient {\n  constructor(serverUrl) {\n    this.transport = new HTTPTransport(serverUrl);\n    this.client = new Client(\n      {\n        name: 'browser-mcp-client',\n        version: '1.0.0'\n      },\n      {\n        capabilities: {}\n      }\n    );\n  }\n\n  async connect() {\n    await this.client.connect(this.transport);\n    console.log('Connected to MCP server');\n  }\n\n  async listTools() {\n    const response = await this.client.request(\n      { method: 'tools/list' },\n      { method: 'tools/list' }\n    );\n    return response.tools;\n  }\n\n  async callTool(name, arguments = {}) {\n    const response = await this.client.request(\n      { \n        method: 'tools/call',\n        params: { name, arguments }\n      },\n      { \n        method: 'tools/call',\n        params: { name, arguments }\n      }\n    );\n    return response.content;\n  }\n\n  async disconnect() {\n    await this.client.close();\n    console.log('Disconnected from MCP server');\n  }\n}\n\n// Usage\nconst client = new BrowserMCPClient('http://localhost:8000/mcp');\nawait client.connect();\n</code></pre>"},{"location":"develop/javascript/browser/#websocket-transport","title":"WebSocket Transport","text":"<p>For real-time communication with MCP servers (when supported):</p> <pre><code>// src/websocket-client.js\nclass WebSocketMCPClient {\n  constructor(wsUrl) {\n    this.wsUrl = wsUrl;\n    this.ws = null;\n    this.requestId = 1;\n    this.pendingRequests = new Map();\n  }\n\n  async connect() {\n    return new Promise((resolve, reject) =&gt; {\n      this.ws = new WebSocket(this.wsUrl);\n      \n      this.ws.onopen = () =&gt; {\n        console.log('WebSocket connected');\n        resolve();\n      };\n      \n      this.ws.onmessage = (event) =&gt; {\n        this.handleMessage(JSON.parse(event.data));\n      };\n      \n      this.ws.onerror = (error) =&gt; {\n        console.error('WebSocket error:', error);\n        reject(error);\n      };\n      \n      this.ws.onclose = () =&gt; {\n        console.log('WebSocket disconnected');\n      };\n    });\n  }\n\n  handleMessage(message) {\n    if (message.id &amp;&amp; this.pendingRequests.has(message.id)) {\n      const { resolve, reject } = this.pendingRequests.get(message.id);\n      this.pendingRequests.delete(message.id);\n      \n      if (message.error) {\n        reject(new Error(message.error.message));\n      } else {\n        resolve(message.result);\n      }\n    }\n  }\n\n  async sendRequest(method, params = {}) {\n    const id = this.requestId++;\n    const message = {\n      jsonrpc: '2.0',\n      id,\n      method,\n      params\n    };\n\n    return new Promise((resolve, reject) =&gt; {\n      this.pendingRequests.set(id, { resolve, reject });\n      \n      if (this.ws.readyState === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify(message));\n      } else {\n        this.pendingRequests.delete(id);\n        reject(new Error('WebSocket not connected'));\n      }\n    });\n  }\n\n  async listTools() {\n    return await this.sendRequest('tools/list');\n  }\n\n  async callTool(name, arguments) {\n    return await this.sendRequest('tools/call', { name, arguments });\n  }\n\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}\n</code></pre>"},{"location":"develop/javascript/browser/#building-a-web-interface","title":"Building a Web Interface","text":""},{"location":"develop/javascript/browser/#html-structure","title":"HTML Structure","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;MCP Web Client&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        .container {\n            background: white;\n            border-radius: 8px;\n            padding: 24px;\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n        \n        .tool-card {\n            border: 1px solid #e1e5e9;\n            border-radius: 6px;\n            padding: 16px;\n            margin: 12px 0;\n            background: #fafbfc;\n        }\n        \n        .tool-input {\n            width: 100%;\n            padding: 8px 12px;\n            border: 1px solid #d0d7de;\n            border-radius: 4px;\n            margin: 8px 0;\n        }\n        \n        .btn {\n            background-color: #0969da;\n            color: white;\n            border: none;\n            padding: 8px 16px;\n            border-radius: 4px;\n            cursor: pointer;\n            font-size: 14px;\n        }\n        \n        .btn:hover {\n            background-color: #0550ae;\n        }\n        \n        .result {\n            background: #f6f8fa;\n            border: 1px solid #d0d7de;\n            border-radius: 4px;\n            padding: 12px;\n            margin: 12px 0;\n            white-space: pre-wrap;\n            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;\n        }\n        \n        .status {\n            padding: 8px 12px;\n            border-radius: 4px;\n            margin: 8px 0;\n            font-weight: 500;\n        }\n        \n        .status.connected {\n            background-color: #dafbe1;\n            color: #1a7f37;\n        }\n        \n        .status.disconnected {\n            background-color: #ffebe9;\n            color: #cf222e;\n        }\n        \n        .loading {\n            opacity: 0.6;\n            pointer-events: none;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h1&gt;MCP Web Client&lt;/h1&gt;\n        \n        &lt;div class=\"connection-section\"&gt;\n            &lt;h2&gt;Connection&lt;/h2&gt;\n            &lt;input type=\"text\" id=\"serverUrl\" placeholder=\"http://localhost:8000/mcp\" class=\"tool-input\"&gt;\n            &lt;button id=\"connectBtn\" class=\"btn\"&gt;Connect&lt;/button&gt;\n            &lt;button id=\"disconnectBtn\" class=\"btn\" style=\"display: none;\"&gt;Disconnect&lt;/button&gt;\n            &lt;div id=\"connectionStatus\" class=\"status disconnected\"&gt;Disconnected&lt;/div&gt;\n        &lt;/div&gt;\n        \n        &lt;div class=\"tools-section\" style=\"display: none;\"&gt;\n            &lt;h2&gt;Available Tools&lt;/h2&gt;\n            &lt;div id=\"toolsList\"&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        \n        &lt;div class=\"results-section\"&gt;\n            &lt;h2&gt;Results&lt;/h2&gt;\n            &lt;div id=\"results\"&gt;&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script type=\"module\" src=\"app.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"develop/javascript/browser/#application-logic","title":"Application Logic","text":"<pre><code>// app.js\nclass MCPWebClient {\n  constructor() {\n    this.client = null;\n    this.isConnected = false;\n    this.tools = [];\n    \n    this.initializeEventListeners();\n  }\n\n  initializeEventListeners() {\n    document.getElementById('connectBtn').addEventListener('click', () =&gt; {\n      this.connect();\n    });\n    \n    document.getElementById('disconnectBtn').addEventListener('click', () =&gt; {\n      this.disconnect();\n    });\n  }\n\n  async connect() {\n    const serverUrl = document.getElementById('serverUrl').value.trim();\n    if (!serverUrl) {\n      this.addResult('Error: Please enter a server URL', 'error');\n      return;\n    }\n\n    try {\n      this.setLoading(true);\n      \n      // Use fetch-based HTTP transport for browser compatibility\n      this.client = new HTTPMCPClient(serverUrl);\n      await this.client.connect();\n      \n      this.isConnected = true;\n      this.updateConnectionStatus(true);\n      \n      // Load available tools\n      await this.loadTools();\n      \n      this.addResult('Connected successfully!', 'success');\n    } catch (error) {\n      this.addResult(`Connection failed: ${error.message}`, 'error');\n      this.updateConnectionStatus(false);\n    } finally {\n      this.setLoading(false);\n    }\n  }\n\n  async disconnect() {\n    if (this.client) {\n      await this.client.disconnect();\n      this.client = null;\n    }\n    \n    this.isConnected = false;\n    this.updateConnectionStatus(false);\n    this.clearTools();\n    this.addResult('Disconnected', 'info');\n  }\n\n  async loadTools() {\n    try {\n      this.tools = await this.client.listTools();\n      this.renderTools();\n    } catch (error) {\n      this.addResult(`Failed to load tools: ${error.message}`, 'error');\n    }\n  }\n\n  renderTools() {\n    const toolsList = document.getElementById('toolsList');\n    toolsList.innerHTML = '';\n\n    if (this.tools.length === 0) {\n      toolsList.innerHTML = '&lt;p&gt;No tools available&lt;/p&gt;';\n      return;\n    }\n\n    this.tools.forEach(tool =&gt; {\n      const toolCard = this.createToolCard(tool);\n      toolsList.appendChild(toolCard);\n    });\n\n    document.querySelector('.tools-section').style.display = 'block';\n  }\n\n  createToolCard(tool) {\n    const card = document.createElement('div');\n    card.className = 'tool-card';\n    \n    card.innerHTML = `\n      &lt;h3&gt;${tool.name}&lt;/h3&gt;\n      &lt;p&gt;${tool.description}&lt;/p&gt;\n      &lt;div class=\"tool-inputs\" id=\"inputs-${tool.name}\"&gt;&lt;/div&gt;\n      &lt;button class=\"btn\" onclick=\"mcpClient.callTool('${tool.name}')\"&gt;\n        Call Tool\n      &lt;/button&gt;\n    `;\n\n    // Generate input fields based on schema\n    const inputsContainer = card.querySelector(`#inputs-${tool.name}`);\n    this.generateInputFields(tool.inputSchema, inputsContainer, tool.name);\n\n    return card;\n  }\n\n  generateInputFields(schema, container, toolName) {\n    if (!schema || !schema.properties) {\n      return;\n    }\n\n    Object.entries(schema.properties).forEach(([propName, propSchema]) =&gt; {\n      const inputGroup = document.createElement('div');\n      \n      const label = document.createElement('label');\n      label.textContent = propName + (schema.required?.includes(propName) ? ' *' : '');\n      label.style.display = 'block';\n      label.style.marginBottom = '4px';\n      label.style.fontWeight = '500';\n      \n      const input = document.createElement('input');\n      input.className = 'tool-input';\n      input.id = `${toolName}-${propName}`;\n      input.placeholder = propSchema.description || '';\n      \n      // Set input type based on schema\n      if (propSchema.type === 'number') {\n        input.type = 'number';\n      } else if (propSchema.type === 'boolean') {\n        input.type = 'checkbox';\n      } else if (propSchema.enum) {\n        const select = document.createElement('select');\n        select.className = 'tool-input';\n        select.id = `${toolName}-${propName}`;\n        \n        propSchema.enum.forEach(value =&gt; {\n          const option = document.createElement('option');\n          option.value = value;\n          option.textContent = value;\n          select.appendChild(option);\n        });\n        \n        inputGroup.appendChild(label);\n        inputGroup.appendChild(select);\n        container.appendChild(inputGroup);\n        return;\n      } else {\n        input.type = 'text';\n      }\n\n      inputGroup.appendChild(label);\n      inputGroup.appendChild(input);\n      container.appendChild(inputGroup);\n    });\n  }\n\n  async callTool(toolName) {\n    const tool = this.tools.find(t =&gt; t.name === toolName);\n    if (!tool) {\n      this.addResult(`Tool not found: ${toolName}`, 'error');\n      return;\n    }\n\n    // Collect input values\n    const arguments = {};\n    const schema = tool.inputSchema;\n    \n    if (schema &amp;&amp; schema.properties) {\n      Object.keys(schema.properties).forEach(propName =&gt; {\n        const input = document.getElementById(`${toolName}-${propName}`);\n        if (input) {\n          if (input.type === 'checkbox') {\n            arguments[propName] = input.checked;\n          } else if (input.type === 'number') {\n            arguments[propName] = parseFloat(input.value) || 0;\n          } else {\n            arguments[propName] = input.value;\n          }\n        }\n      });\n    }\n\n    try {\n      this.setLoading(true);\n      this.addResult(`Calling tool: ${toolName}`, 'info');\n      \n      const result = await this.client.callTool(toolName, arguments);\n      \n      // Display result\n      const resultText = result.map(item =&gt; {\n        if (item.type === 'text') {\n          return item.text;\n        } else {\n          return JSON.stringify(item, null, 2);\n        }\n      }).join('\\n\\n');\n      \n      this.addResult(resultText, 'success');\n    } catch (error) {\n      this.addResult(`Tool call failed: ${error.message}`, 'error');\n    } finally {\n      this.setLoading(false);\n    }\n  }\n\n  updateConnectionStatus(connected) {\n    const status = document.getElementById('connectionStatus');\n    const connectBtn = document.getElementById('connectBtn');\n    const disconnectBtn = document.getElementById('disconnectBtn');\n    \n    if (connected) {\n      status.textContent = 'Connected';\n      status.className = 'status connected';\n      connectBtn.style.display = 'none';\n      disconnectBtn.style.display = 'inline-block';\n    } else {\n      status.textContent = 'Disconnected';\n      status.className = 'status disconnected';\n      connectBtn.style.display = 'inline-block';\n      disconnectBtn.style.display = 'none';\n    }\n  }\n\n  clearTools() {\n    document.getElementById('toolsList').innerHTML = '';\n    document.querySelector('.tools-section').style.display = 'none';\n    this.tools = [];\n  }\n\n  addResult(message, type = 'info') {\n    const results = document.getElementById('results');\n    const resultDiv = document.createElement('div');\n    resultDiv.className = 'result';\n    \n    const timestamp = new Date().toLocaleTimeString();\n    resultDiv.innerHTML = `\n      &lt;strong&gt;[${timestamp}] ${type.toUpperCase()}:&lt;/strong&gt;&lt;br&gt;\n      ${message}\n    `;\n    \n    // Color code by type\n    if (type === 'error') {\n      resultDiv.style.borderColor = '#d73a49';\n      resultDiv.style.backgroundColor = '#ffeaea';\n    } else if (type === 'success') {\n      resultDiv.style.borderColor = '#28a745';\n      resultDiv.style.backgroundColor = '#eaffea';\n    } else if (type === 'info') {\n      resultDiv.style.borderColor = '#0366d6';\n      resultDiv.style.backgroundColor = '#eaf3ff';\n    }\n    \n    results.prepend(resultDiv);\n    \n    // Limit number of results displayed\n    while (results.children.length &gt; 10) {\n      results.removeChild(results.lastChild);\n    }\n  }\n\n  setLoading(loading) {\n    document.body.classList.toggle('loading', loading);\n  }\n}\n\n// HTTP-based MCP client for browsers\nclass HTTPMCPClient {\n  constructor(baseUrl) {\n    this.baseUrl = baseUrl.replace(/\\/$/, '');\n    this.connected = false;\n  }\n\n  async connect() {\n    // Test connection with a simple request\n    try {\n      const response = await fetch(`${this.baseUrl}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          jsonrpc: '2.0',\n          method: 'initialize',\n          id: 1,\n          params: {\n            protocolVersion: '2025-06-18',\n            capabilities: {},\n            clientInfo: {\n              name: 'browser-mcp-client',\n              version: '1.0.0'\n            }\n          }\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      this.connected = true;\n    } catch (error) {\n      throw new Error(`Connection failed: ${error.message}`);\n    }\n  }\n\n  async sendRequest(method, params = {}) {\n    if (!this.connected) {\n      throw new Error('Not connected to server');\n    }\n\n    const response = await fetch(`${this.baseUrl}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        method,\n        params,\n        id: Date.now()\n      })\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    \n    if (data.error) {\n      throw new Error(data.error.message || 'Server error');\n    }\n\n    return data.result;\n  }\n\n  async listTools() {\n    const result = await this.sendRequest('tools/list');\n    return result.tools || [];\n  }\n\n  async callTool(name, arguments) {\n    const result = await this.sendRequest('tools/call', { name, arguments });\n    return result.content || [];\n  }\n\n  async disconnect() {\n    this.connected = false;\n  }\n}\n\n// Initialize the application\nconst mcpClient = new MCPWebClient();\nwindow.mcpClient = mcpClient; // Make available globally for button onclick handlers\n</code></pre>"},{"location":"develop/javascript/browser/#error-handling-and-user-experience","title":"Error Handling and User Experience","text":""},{"location":"develop/javascript/browser/#robust-error-handling","title":"Robust Error Handling","text":"<pre><code>// error-handler.js\nclass ErrorHandler {\n  static handle(error, context = '') {\n    console.error(`Error in ${context}:`, error);\n    \n    let userMessage = 'An unexpected error occurred';\n    \n    // Categorize errors for better user experience\n    if (error instanceof TypeError &amp;&amp; error.message.includes('fetch')) {\n      userMessage = 'Network error: Unable to connect to server. Please check the URL and try again.';\n    } else if (error.message.includes('HTTP 404')) {\n      userMessage = 'Server not found: The MCP server URL appears to be incorrect.';\n    } else if (error.message.includes('HTTP 500')) {\n      userMessage = 'Server error: The MCP server encountered an internal error.';\n    } else if (error.message.includes('timeout')) {\n      userMessage = 'Request timeout: The server took too long to respond.';\n    } else if (error.message.includes('CORS')) {\n      userMessage = 'Cross-origin error: The server needs to allow browser access.';\n    } else if (error.message) {\n      userMessage = error.message;\n    }\n    \n    return userMessage;\n  }\n\n  static showUserError(message, container) {\n    const errorDiv = document.createElement('div');\n    errorDiv.className = 'error-message';\n    errorDiv.style.cssText = `\n      background-color: #ffebee;\n      color: #c62828;\n      padding: 12px 16px;\n      border-radius: 4px;\n      margin: 8px 0;\n      border: 1px solid #ef5350;\n    `;\n    errorDiv.textContent = message;\n    \n    container.prepend(errorDiv);\n    \n    // Auto-remove after 5 seconds\n    setTimeout(() =&gt; {\n      if (errorDiv.parentNode) {\n        errorDiv.parentNode.removeChild(errorDiv);\n      }\n    }, 5000);\n  }\n}\n</code></pre>"},{"location":"develop/javascript/browser/#progressive-web-app-features","title":"Progressive Web App Features","text":""},{"location":"develop/javascript/browser/#service-worker-for-offline-capability","title":"Service Worker for Offline Capability","text":"<pre><code>// sw.js (Service Worker)\nconst CACHE_NAME = 'mcp-client-v1';\nconst urlsToCache = [\n  '/',\n  '/app.js',\n  '/style.css'\n];\n\nself.addEventListener('install', (event) =&gt; {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then((cache) =&gt; cache.addAll(urlsToCache))\n  );\n});\n\nself.addEventListener('fetch', (event) =&gt; {\n  event.respondWith(\n    caches.match(event.request)\n      .then((response) =&gt; {\n        // Return cached version or fetch from network\n        return response || fetch(event.request);\n      })\n  );\n});\n</code></pre>"},{"location":"develop/javascript/browser/#web-app-manifest","title":"Web App Manifest","text":"<pre><code>{\n  \"name\": \"MCP Web Client\",\n  \"short_name\": \"MCP Client\",\n  \"description\": \"Browser-based Model Context Protocol client\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#0969da\",\n  \"icons\": [\n    {\n      \"src\": \"/icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icon-512.png\", \n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n</code></pre>"},{"location":"develop/javascript/browser/#build-process","title":"Build Process","text":""},{"location":"develop/javascript/browser/#webpack-configuration","title":"Webpack Configuration","text":"<pre><code>// webpack.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/app.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n    clean: true,\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env']\n          }\n        }\n      },\n      {\n        test: /\\.css$/i,\n        use: ['style-loader', 'css-loader'],\n      }\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html',\n    }),\n  ],\n  devServer: {\n    static: './dist',\n    port: 3000,\n    open: true,\n  },\n  resolve: {\n    fallback: {\n      \"buffer\": require.resolve(\"buffer/\"),\n      \"process\": require.resolve(\"process/browser\")\n    }\n  }\n};\n</code></pre>"},{"location":"develop/javascript/browser/#security-considerations","title":"Security Considerations","text":""},{"location":"develop/javascript/browser/#content-security-policy","title":"Content Security Policy","text":"<pre><code>&lt;meta http-equiv=\"Content-Security-Policy\" \n      content=\"default-src 'self'; \n               connect-src 'self' http://localhost:8000 https://your-mcp-server.com;\n               script-src 'self' 'unsafe-inline';\n               style-src 'self' 'unsafe-inline';\"&gt;\n</code></pre>"},{"location":"develop/javascript/browser/#cors-handling","title":"CORS Handling","text":"<pre><code>// For MCP servers that need to support browser clients\n// Add CORS headers to server responses:\n\n// Access-Control-Allow-Origin: https://your-client-domain.com\n// Access-Control-Allow-Methods: POST, OPTIONS\n// Access-Control-Allow-Headers: Content-Type, Authorization\n// Access-Control-Max-Age: 86400\n</code></pre>"},{"location":"develop/javascript/browser/#best-practices","title":"Best Practices","text":""},{"location":"develop/javascript/browser/#performance","title":"Performance","text":"<ol> <li>Lazy Loading: Load tools and features on demand</li> <li>Caching: Cache server responses when appropriate</li> <li>Debouncing: Debounce user inputs to reduce server requests</li> <li>Virtual Scrolling: For large lists of tools or results</li> </ol>"},{"location":"develop/javascript/browser/#user-experience","title":"User Experience","text":"<ol> <li>Loading States: Show loading indicators for all async operations</li> <li>Error Recovery: Provide clear error messages and recovery options</li> <li>Offline Support: Cache resources for offline functionality</li> <li>Responsive Design: Support mobile and desktop interfaces</li> </ol>"},{"location":"develop/javascript/browser/#development","title":"Development","text":"<ol> <li>Code Splitting: Split code into chunks for better loading performance</li> <li>Testing: Write unit tests for client logic</li> <li>Documentation: Document API endpoints and tool schemas</li> <li>Monitoring: Track errors and performance metrics</li> </ol> <p>Browser-based MCP clients enable rich, interactive web applications that can leverage the full power of MCP servers while providing excellent user experiences.</p>"},{"location":"develop/javascript/nodejs/","title":"Node.js","text":""},{"location":"develop/javascript/nodejs/#nodejs-development","title":"Node.js Development","text":""},{"location":"develop/javascript/nodejs/#building-mcp-servers-with-nodejs","title":"Building MCP Servers with Node.js","text":"<p>Node.js provides an excellent runtime for MCP servers with its strong async capabilities, rich ecosystem, and native JSON handling.</p>"},{"location":"develop/javascript/nodejs/#nodejs-setup","title":"Node.js Setup","text":""},{"location":"develop/javascript/nodejs/#project-initialization","title":"Project Initialization","text":"<pre><code># Initialize new Node.js project\nnpm init -y\n\n# Install MCP SDK\nnpm install @modelcontextprotocol/sdk\n\n# Install development dependencies\nnpm install --save-dev nodemon dotenv\n</code></pre>"},{"location":"develop/javascript/nodejs/#package-configuration","title":"Package Configuration","text":"<pre><code>{\n  \"name\": \"nodejs-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"main\": \"src/server.js\",\n  \"scripts\": {\n    \"start\": \"node src/server.js\",\n    \"dev\": \"nodemon src/server.js\",\n    \"test\": \"node --test src/**/*.test.js\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.1.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.0\",\n    \"dotenv\": \"^16.3.0\"\n  }\n}\n</code></pre>"},{"location":"develop/javascript/nodejs/#basic-nodejs-mcp-server","title":"Basic Node.js MCP Server","text":""},{"location":"develop/javascript/nodejs/#simple-server-implementation","title":"Simple Server Implementation","text":"<pre><code>// src/server.js\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema\n} from '@modelcontextprotocol/sdk/types.js';\n\nclass NodeMCPServer {\n  constructor(name, version) {\n    this.server = new Server(\n      { name, version },\n      {\n        capabilities: {\n          tools: {}\n        }\n      }\n    );\n\n    this.setupToolHandlers();\n  }\n\n  setupToolHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: 'file_read',\n            description: 'Read contents of a file',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                path: {\n                  type: 'string',\n                  description: 'Path to the file to read'\n                },\n                encoding: {\n                  type: 'string',\n                  enum: ['utf8', 'base64', 'hex'],\n                  default: 'utf8',\n                  description: 'File encoding'\n                }\n              },\n              required: ['path']\n            }\n          },\n          {\n            name: 'system_info',\n            description: 'Get system information',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                info_type: {\n                  type: 'string',\n                  enum: ['platform', 'memory', 'cpu', 'network'],\n                  description: 'Type of system information to retrieve'\n                }\n              },\n              required: ['info_type']\n            }\n          }\n        ]\n      };\n    });\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      const { name, arguments: args } = request.params;\n\n      try {\n        switch (name) {\n          case 'file_read':\n            return await this.handleFileRead(args);\n          case 'system_info':\n            return await this.handleSystemInfo(args);\n          default:\n            throw new Error(`Unknown tool: ${name}`);\n        }\n      } catch (error) {\n        return {\n          content: [{\n            type: 'text',\n            text: `Error: ${error.message}`\n          }]\n        };\n      }\n    });\n  }\n\n  async handleFileRead(args) {\n    const { path, encoding = 'utf8' } = args;\n    \n    // Input validation\n    if (!path || typeof path !== 'string') {\n      throw new Error('Path is required and must be a string');\n    }\n\n    try {\n      const fs = await import('fs/promises');\n      const content = await fs.readFile(path, encoding);\n      \n      return {\n        content: [{\n          type: 'text',\n          text: `File contents (${path}):\\n${content}`\n        }]\n      };\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        throw new Error(`File not found: ${path}`);\n      } else if (error.code === 'EACCES') {\n        throw new Error(`Permission denied: ${path}`);\n      }\n      throw error;\n    }\n  }\n\n  async handleSystemInfo(args) {\n    const { info_type } = args;\n    const os = await import('os');\n    \n    let info;\n    \n    switch (info_type) {\n      case 'platform':\n        info = {\n          platform: os.platform(),\n          arch: os.arch(),\n          release: os.release(),\n          hostname: os.hostname()\n        };\n        break;\n        \n      case 'memory':\n        info = {\n          total_memory: os.totalmem(),\n          free_memory: os.freemem(),\n          memory_usage: process.memoryUsage()\n        };\n        break;\n        \n      case 'cpu':\n        info = {\n          cpu_count: os.cpus().length,\n          cpu_model: os.cpus()[0]?.model || 'Unknown',\n          load_average: os.loadavg(),\n          uptime: os.uptime()\n        };\n        break;\n        \n      case 'network':\n        info = {\n          network_interfaces: os.networkInterfaces()\n        };\n        break;\n        \n      default:\n        throw new Error(`Unknown info type: ${info_type}`);\n    }\n\n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify(info, null, 2)\n      }]\n    };\n  }\n\n  async run() {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n  }\n}\n\n// Main execution\nasync function main() {\n  const server = new NodeMCPServer('nodejs-mcp-server', '1.0.0');\n  await server.run();\n}\n\n// Handle process signals\nprocess.on('SIGINT', () =&gt; {\n  console.log('Received SIGINT, shutting down gracefully...');\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () =&gt; {\n  console.log('Received SIGTERM, shutting down gracefully...');\n  process.exit(0);\n});\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main().catch(console.error);\n}\n</code></pre>"},{"location":"develop/javascript/nodejs/#file-system-operations","title":"File System Operations","text":""},{"location":"develop/javascript/nodejs/#advanced-file-handling","title":"Advanced File Handling","text":"<pre><code>// src/tools/filesystem.js\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nexport class FileSystemTools {\n  constructor(allowedPaths = []) {\n    this.allowedPaths = allowedPaths;\n  }\n\n  validatePath(filePath) {\n    const resolvedPath = path.resolve(filePath);\n    \n    // Check if path is within allowed directories\n    if (this.allowedPaths.length &gt; 0) {\n      const isAllowed = this.allowedPaths.some(allowedPath =&gt; \n        resolvedPath.startsWith(path.resolve(allowedPath))\n      );\n      \n      if (!isAllowed) {\n        throw new Error(`Access denied: Path not in allowed directories`);\n      }\n    }\n    \n    return resolvedPath;\n  }\n\n  async readFile(filePath, encoding = 'utf8') {\n    const validPath = this.validatePath(filePath);\n    \n    try {\n      const content = await fs.readFile(validPath, encoding);\n      return {\n        path: validPath,\n        size: (await fs.stat(validPath)).size,\n        content: content\n      };\n    } catch (error) {\n      this.handleFileError(error, validPath);\n    }\n  }\n\n  async writeFile(filePath, content, options = {}) {\n    const validPath = this.validatePath(filePath);\n    \n    try {\n      await fs.writeFile(validPath, content, {\n        encoding: 'utf8',\n        ...options\n      });\n      \n      const stats = await fs.stat(validPath);\n      return {\n        path: validPath,\n        size: stats.size,\n        modified: stats.mtime\n      };\n    } catch (error) {\n      this.handleFileError(error, validPath);\n    }\n  }\n\n  async listDirectory(dirPath) {\n    const validPath = this.validatePath(dirPath);\n    \n    try {\n      const entries = await fs.readdir(validPath, { withFileTypes: true });\n      \n      return entries.map(entry =&gt; ({\n        name: entry.name,\n        type: entry.isDirectory() ? 'directory' : 'file',\n        path: path.join(validPath, entry.name)\n      }));\n    } catch (error) {\n      this.handleFileError(error, validPath);\n    }\n  }\n\n  async getFileStats(filePath) {\n    const validPath = this.validatePath(filePath);\n    \n    try {\n      const stats = await fs.stat(validPath);\n      \n      return {\n        path: validPath,\n        size: stats.size,\n        created: stats.birthtime,\n        modified: stats.mtime,\n        accessed: stats.atime,\n        isDirectory: stats.isDirectory(),\n        isFile: stats.isFile(),\n        permissions: stats.mode\n      };\n    } catch (error) {\n      this.handleFileError(error, validPath);\n    }\n  }\n\n  handleFileError(error, filePath) {\n    switch (error.code) {\n      case 'ENOENT':\n        throw new Error(`File or directory not found: ${filePath}`);\n      case 'EACCES':\n        throw new Error(`Permission denied: ${filePath}`);\n      case 'EISDIR':\n        throw new Error(`Expected file but found directory: ${filePath}`);\n      case 'ENOTDIR':\n        throw new Error(`Expected directory but found file: ${filePath}`);\n      default:\n        throw error;\n    }\n  }\n}\n</code></pre>"},{"location":"develop/javascript/nodejs/#http-client-integration","title":"HTTP Client Integration","text":""},{"location":"develop/javascript/nodejs/#rest-api-tools","title":"REST API Tools","text":"<pre><code>// src/tools/http-client.js\nexport class HttpClient {\n  constructor(options = {}) {\n    this.defaultTimeout = options.timeout || 30000;\n    this.defaultHeaders = options.headers || {};\n    this.retryCount = options.retryCount || 3;\n    this.retryDelay = options.retryDelay || 1000;\n  }\n\n  async request(url, options = {}) {\n    const requestOptions = {\n      method: 'GET',\n      timeout: this.defaultTimeout,\n      headers: { ...this.defaultHeaders },\n      ...options\n    };\n\n    let lastError;\n    \n    for (let attempt = 1; attempt &lt;= this.retryCount; attempt++) {\n      try {\n        const response = await this.performRequest(url, requestOptions);\n        return response;\n      } catch (error) {\n        lastError = error;\n        \n        if (attempt &lt; this.retryCount &amp;&amp; this.shouldRetry(error)) {\n          await this.delay(this.retryDelay * attempt);\n          continue;\n        }\n        \n        break;\n      }\n    }\n    \n    throw lastError;\n  }\n\n  async performRequest(url, options) {\n    // Use dynamic import for better compatibility\n    const { default: fetch } = await import('node-fetch');\n    \n    const controller = new AbortController();\n    const timeoutId = setTimeout(() =&gt; controller.abort(), options.timeout);\n    \n    try {\n      const response = await fetch(url, {\n        ...options,\n        signal: controller.signal\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const contentType = response.headers.get('content-type');\n      let data;\n      \n      if (contentType?.includes('application/json')) {\n        data = await response.json();\n      } else {\n        data = await response.text();\n      }\n      \n      return {\n        status: response.status,\n        statusText: response.statusText,\n        headers: Object.fromEntries(response.headers.entries()),\n        data: data\n      };\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  shouldRetry(error) {\n    // Retry on network errors, timeouts, and 5xx status codes\n    return (\n      error.name === 'AbortError' ||\n      error.code === 'ECONNRESET' ||\n      error.code === 'ETIMEDOUT' ||\n      (error.message &amp;&amp; error.message.includes('HTTP 5'))\n    );\n  }\n\n  delay(ms) {\n    return new Promise(resolve =&gt; setTimeout(resolve, ms));\n  }\n\n  async get(url, options = {}) {\n    return this.request(url, { ...options, method: 'GET' });\n  }\n\n  async post(url, data, options = {}) {\n    return this.request(url, {\n      ...options,\n      method: 'POST',\n      body: JSON.stringify(data),\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      }\n    });\n  }\n\n  async put(url, data, options = {}) {\n    return this.request(url, {\n      ...options,\n      method: 'PUT',\n      body: JSON.stringify(data),\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      }\n    });\n  }\n\n  async delete(url, options = {}) {\n    return this.request(url, { ...options, method: 'DELETE' });\n  }\n}\n</code></pre>"},{"location":"develop/javascript/nodejs/#configuration-management","title":"Configuration Management","text":""},{"location":"develop/javascript/nodejs/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>// src/config.js\nimport { config } from 'dotenv';\nimport path from 'path';\n\n// Load environment variables\nconfig();\n\nexport class Config {\n  constructor() {\n    this.server = {\n      name: process.env.MCP_SERVER_NAME || 'nodejs-mcp-server',\n      version: process.env.MCP_SERVER_VERSION || '1.0.0',\n      debug: process.env.MCP_DEBUG === 'true'\n    };\n\n    this.filesystem = {\n      allowedPaths: process.env.ALLOWED_PATHS \n        ? process.env.ALLOWED_PATHS.split(',').map(p =&gt; p.trim())\n        : []\n    };\n\n    this.http = {\n      timeout: parseInt(process.env.HTTP_TIMEOUT) || 30000,\n      retryCount: parseInt(process.env.HTTP_RETRY_COUNT) || 3,\n      retryDelay: parseInt(process.env.HTTP_RETRY_DELAY) || 1000,\n      userAgent: process.env.HTTP_USER_AGENT || 'MCP-Server/1.0'\n    };\n\n    this.database = {\n      url: process.env.DATABASE_URL,\n      poolSize: parseInt(process.env.DB_POOL_SIZE) || 10,\n      timeout: parseInt(process.env.DB_TIMEOUT) || 30000\n    };\n\n    this.logging = {\n      level: process.env.LOG_LEVEL || 'info',\n      format: process.env.LOG_FORMAT || 'json'\n    };\n  }\n\n  validate() {\n    const errors = [];\n\n    // Validate required configuration\n    if (this.filesystem.allowedPaths.length === 0) {\n      console.warn('Warning: No allowed paths configured for filesystem access');\n    }\n\n    if (this.database.url &amp;&amp; !this.isValidUrl(this.database.url)) {\n      errors.push('Invalid database URL');\n    }\n\n    if (errors.length &gt; 0) {\n      throw new Error(`Configuration validation failed: ${errors.join(', ')}`);\n    }\n  }\n\n  isValidUrl(string) {\n    try {\n      new URL(string);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport const config = new Config();\n</code></pre>"},{"location":"develop/javascript/nodejs/#database-integration","title":"Database Integration","text":""},{"location":"develop/javascript/nodejs/#database-connection-pool","title":"Database Connection Pool","text":"<pre><code>// src/database.js\nexport class DatabaseConnection {\n  constructor(config) {\n    this.config = config;\n    this.pool = null;\n  }\n\n  async connect() {\n    if (this.pool) {\n      return this.pool;\n    }\n\n    // Example with a hypothetical database driver\n    try {\n      const { createPool } = await import('generic-database-driver');\n      \n      this.pool = createPool({\n        connectionString: this.config.database.url,\n        max: this.config.database.poolSize,\n        idleTimeoutMillis: this.config.database.timeout,\n        ssl: process.env.NODE_ENV === 'production'\n      });\n\n      // Test connection\n      const client = await this.pool.connect();\n      await client.query('SELECT 1');\n      client.release();\n\n      console.log('Database connected successfully');\n      return this.pool;\n    } catch (error) {\n      console.error('Failed to connect to database:', error.message);\n      throw error;\n    }\n  }\n\n  async query(text, params = []) {\n    if (!this.pool) {\n      await this.connect();\n    }\n\n    const client = await this.pool.connect();\n    \n    try {\n      const result = await client.query(text, params);\n      return result;\n    } finally {\n      client.release();\n    }\n  }\n\n  async transaction(callback) {\n    const client = await this.pool.connect();\n    \n    try {\n      await client.query('BEGIN');\n      const result = await callback(client);\n      await client.query('COMMIT');\n      return result;\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async close() {\n    if (this.pool) {\n      await this.pool.end();\n      this.pool = null;\n    }\n  }\n}\n</code></pre>"},{"location":"develop/javascript/nodejs/#logging-and-monitoring","title":"Logging and Monitoring","text":""},{"location":"develop/javascript/nodejs/#structured-logging","title":"Structured Logging","text":"<pre><code>// src/logger.js\nexport class Logger {\n  constructor(options = {}) {\n    this.level = options.level || 'info';\n    this.format = options.format || 'json';\n    this.levels = {\n      debug: 0,\n      info: 1,\n      warn: 2,\n      error: 3\n    };\n  }\n\n  shouldLog(level) {\n    return this.levels[level] &gt;= this.levels[this.level];\n  }\n\n  formatMessage(level, message, meta = {}) {\n    const timestamp = new Date().toISOString();\n    \n    if (this.format === 'json') {\n      return JSON.stringify({\n        timestamp,\n        level: level.toUpperCase(),\n        message,\n        ...meta,\n        pid: process.pid,\n        hostname: require('os').hostname()\n      });\n    } else {\n      const metaStr = Object.keys(meta).length &gt; 0 \n        ? ` ${JSON.stringify(meta)}` \n        : '';\n      return `${timestamp} [${level.toUpperCase()}] ${message}${metaStr}`;\n    }\n  }\n\n  log(level, message, meta) {\n    if (!this.shouldLog(level)) {\n      return;\n    }\n\n    const formatted = this.formatMessage(level, message, meta);\n    \n    if (level === 'error') {\n      console.error(formatted);\n    } else {\n      console.log(formatted);\n    }\n  }\n\n  debug(message, meta) {\n    this.log('debug', message, meta);\n  }\n\n  info(message, meta) {\n    this.log('info', message, meta);\n  }\n\n  warn(message, meta) {\n    this.log('warn', message, meta);\n  }\n\n  error(message, meta) {\n    this.log('error', message, meta);\n  }\n}\n\nexport const logger = new Logger({\n  level: process.env.LOG_LEVEL || 'info',\n  format: process.env.LOG_FORMAT || 'json'\n});\n</code></pre>"},{"location":"develop/javascript/nodejs/#testing","title":"Testing","text":""},{"location":"develop/javascript/nodejs/#unit-tests-with-nodejs-test-runner","title":"Unit Tests with Node.js Test Runner","text":"<pre><code>// src/server.test.js\nimport { describe, it, before, after } from 'node:test';\nimport assert from 'node:assert';\nimport { NodeMCPServer } from './server.js';\n\ndescribe('NodeMCPServer', () =&gt; {\n  let server;\n\n  before(async () =&gt; {\n    server = new NodeMCPServer('test-server', '1.0.0');\n  });\n\n  it('should handle file read correctly', async () =&gt; {\n    const result = await server.handleFileRead({\n      path: './package.json',\n      encoding: 'utf8'\n    });\n\n    assert(result.content);\n    assert(Array.isArray(result.content));\n    assert(result.content[0].type === 'text');\n    assert(result.content[0].text.includes('package.json'));\n  });\n\n  it('should handle system info requests', async () =&gt; {\n    const result = await server.handleSystemInfo({\n      info_type: 'platform'\n    });\n\n    assert(result.content);\n    assert(result.content[0].type === 'text');\n    \n    const info = JSON.parse(result.content[0].text);\n    assert(typeof info.platform === 'string');\n    assert(typeof info.arch === 'string');\n  });\n\n  it('should throw error for invalid file paths', async () =&gt; {\n    await assert.rejects(\n      server.handleFileRead({ path: '/nonexistent/file.txt' }),\n      /File not found/\n    );\n  });\n});\n</code></pre>"},{"location":"develop/javascript/nodejs/#production-deployment","title":"Production Deployment","text":""},{"location":"develop/javascript/nodejs/#process-management","title":"Process Management","text":"<pre><code>// src/cluster.js\nimport cluster from 'cluster';\nimport os from 'os';\nimport { logger } from './logger.js';\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isPrimary) {\n  logger.info(`Master ${process.pid} is running`);\n\n  // Fork workers\n  for (let i = 0; i &lt; numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) =&gt; {\n    logger.warn(`Worker ${worker.process.pid} died`, { code, signal });\n    logger.info('Starting a new worker');\n    cluster.fork();\n  });\n} else {\n  // Workers can share any TCP port\n  const { NodeMCPServer } = await import('./server.js');\n  const server = new NodeMCPServer('nodejs-mcp-server', '1.0.0');\n  \n  await server.run();\n  logger.info(`Worker ${process.pid} started`);\n}\n</code></pre>"},{"location":"develop/javascript/nodejs/#best-practices","title":"Best Practices","text":""},{"location":"develop/javascript/nodejs/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Event Loop: Keep the event loop responsive</li> <li>Memory Management: Monitor and prevent memory leaks  </li> <li>Streaming: Use streams for large data processing</li> <li>Connection Pooling: Reuse database and HTTP connections</li> </ol>"},{"location":"develop/javascript/nodejs/#error-handling","title":"Error Handling","text":"<ol> <li>Graceful Degradation: Handle errors without crashing</li> <li>Process Signals: Handle SIGINT and SIGTERM properly</li> <li>Uncaught Exceptions: Log and handle uncaught errors</li> <li>Promise Rejections: Always handle promise rejections</li> </ol>"},{"location":"develop/javascript/nodejs/#security","title":"Security","text":"<ol> <li>Input Validation: Validate all inputs thoroughly</li> <li>Path Traversal: Prevent directory traversal attacks</li> <li>Environment Variables: Never log sensitive data</li> <li>Dependencies: Regularly update dependencies</li> </ol> <p>Node.js provides excellent performance and developer experience for building scalable MCP servers with rich ecosystem support.</p>"},{"location":"develop/javascript/packaging/","title":"Packaging","text":""},{"location":"develop/javascript/packaging/#javascript-packaging","title":"JavaScript Packaging","text":""},{"location":"develop/javascript/packaging/#packaging-mcp-applications-for-distribution","title":"Packaging MCP Applications for Distribution","text":"<p>Proper packaging makes your MCP servers and clients easy to install, distribute, and maintain across different environments.</p>"},{"location":"develop/javascript/packaging/#package-structure","title":"Package Structure","text":""},{"location":"develop/javascript/packaging/#nodejs-package-setup","title":"Node.js Package Setup","text":"<pre><code>{\n  \"name\": \"@your-org/mcp-server\",\n  \"version\": \"1.0.0\",\n  \"description\": \"MCP server for [specific purpose]\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"src/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./client\": {\n      \"import\": \"./dist/client.js\",\n      \"types\": \"./dist/client.d.ts\"\n    }\n  },\n  \"bin\": {\n    \"mcp-server\": \"./bin/server.js\"\n  },\n  \"files\": [\n    \"dist/\",\n    \"bin/\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"scripts\": {\n    \"build\": \"npm run clean &amp;&amp; npm run compile\",\n    \"clean\": \"rm -rf dist/\",\n    \"compile\": \"tsc &amp;&amp; npm run bundle\",\n    \"bundle\": \"rollup -c rollup.config.js\",\n    \"dev\": \"nodemon --exec node --loader=tsx src/index.ts\",\n    \"start\": \"node dist/index.js\",\n    \"test\": \"jest\",\n    \"test:coverage\": \"jest --coverage\",\n    \"lint\": \"eslint src/**/*.{js,ts}\",\n    \"lint:fix\": \"eslint src/**/*.{js,ts} --fix\",\n    \"prepublishOnly\": \"npm run build &amp;&amp; npm test\",\n    \"postversion\": \"git push &amp;&amp; git push --tags\"\n  },\n  \"keywords\": [\n    \"mcp\",\n    \"model-context-protocol\",\n    \"ai\",\n    \"assistant\",\n    \"server\",\n    \"tools\"\n  ],\n  \"author\": \"Your Name &lt;you@example.com&gt;\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/your-org/mcp-server.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/your-org/mcp-server/issues\"\n  },\n  \"homepage\": \"https://github.com/your-org/mcp-server#readme\",\n  \"engines\": {\n    \"node\": \"&gt;=18.0.0\",\n    \"npm\": \"&gt;=9.0.0\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.1.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.10.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\",\n    \"eslint\": \"^8.56.0\",\n    \"jest\": \"^29.7.0\",\n    \"nodemon\": \"^3.0.0\",\n    \"rollup\": \"^4.0.0\",\n    \"typescript\": \"^5.3.0\",\n    \"tsx\": \"^4.0.0\"\n  }\n}\n</code></pre>"},{"location":"develop/javascript/packaging/#build-configuration","title":"Build Configuration","text":""},{"location":"develop/javascript/packaging/#typescript-compilation","title":"TypeScript Compilation","text":"<pre><code>// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"removeComments\": false,\n    \"noEmitOnError\": true,\n    \"resolveJsonModule\": true,\n    \"allowImportingTsExtensions\": false,\n    \"noEmit\": false\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.test.ts\",\n    \"**/*.test.js\"\n  ]\n}\n</code></pre>"},{"location":"develop/javascript/packaging/#rollup-bundling","title":"Rollup Bundling","text":"<pre><code>// rollup.config.js\nimport { nodeResolve } from '@rollup/plugin-node-resolve';\nimport { terser } from 'rollup-plugin-terser';\nimport commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\nexport default [\n  // ESM build\n  {\n    input: 'dist/index.js',\n    output: {\n      file: 'dist/index.esm.js',\n      format: 'esm',\n      sourcemap: true\n    },\n    plugins: [\n      nodeResolve({ preferBuiltins: true }),\n      json(),\n      isProduction &amp;&amp; terser()\n    ].filter(Boolean),\n    external: [\n      '@modelcontextprotocol/sdk',\n      'node:fs',\n      'node:path',\n      'node:process'\n    ]\n  },\n  \n  // CommonJS build\n  {\n    input: 'dist/index.js', \n    output: {\n      file: 'dist/index.cjs',\n      format: 'cjs',\n      sourcemap: true\n    },\n    plugins: [\n      nodeResolve({ preferBuiltins: true }),\n      commonjs(),\n      json(),\n      isProduction &amp;&amp; terser()\n    ].filter(Boolean),\n    external: [\n      '@modelcontextprotocol/sdk'\n    ]\n  },\n\n  // Binary executable\n  {\n    input: 'dist/server.js',\n    output: {\n      file: 'bin/server.js',\n      format: 'cjs',\n      banner: '#!/usr/bin/env node',\n      sourcemap: false\n    },\n    plugins: [\n      nodeResolve({ preferBuiltins: true }),\n      commonjs(),\n      json(),\n      terser()\n    ],\n    external: []\n  }\n];\n</code></pre>"},{"location":"develop/javascript/packaging/#cli-executable","title":"CLI Executable","text":""},{"location":"develop/javascript/packaging/#binary-script","title":"Binary Script","text":"<pre><code>#!/usr/bin/env node\n// bin/server.js\n\nimport { fileURLToPath } from 'node:url';\nimport { dirname, join } from 'node:path';\nimport { readFileSync } from 'node:fs';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// Load package.json for version info\nconst packageJson = JSON.parse(\n  readFileSync(join(__dirname, '../package.json'), 'utf8')\n);\n\n// CLI argument parsing\nfunction parseArgs() {\n  const args = process.argv.slice(2);\n  const options = {\n    version: false,\n    help: false,\n    config: null,\n    port: process.env.PORT || 8000,\n    transport: 'stdio'\n  };\n\n  for (let i = 0; i &lt; args.length; i++) {\n    switch (args[i]) {\n      case '--version':\n      case '-v':\n        options.version = true;\n        break;\n      case '--help':\n      case '-h':\n        options.help = true;\n        break;\n      case '--config':\n      case '-c':\n        options.config = args[++i];\n        break;\n      case '--port':\n      case '-p':\n        options.port = parseInt(args[++i]);\n        break;\n      case '--transport':\n      case '-t':\n        options.transport = args[++i];\n        break;\n      default:\n        console.error(`Unknown option: ${args[i]}`);\n        process.exit(1);\n    }\n  }\n\n  return options;\n}\n\n// Display help text\nfunction showHelp() {\n  console.log(`\n${packageJson.name} v${packageJson.version}\n\nUsage: mcp-server [options]\n\nOptions:\n  -v, --version              Show version number\n  -h, --help                 Show help\n  -c, --config &lt;file&gt;        Configuration file path\n  -p, --port &lt;number&gt;        Port number (default: 8000)\n  -t, --transport &lt;type&gt;     Transport type: stdio|http (default: stdio)\n\nExamples:\n  mcp-server                 Start with stdio transport\n  mcp-server -t http -p 8000 Start HTTP server on port 8000\n  mcp-server -c config.json  Start with custom configuration\n`);\n}\n\n// Main execution\nasync function main() {\n  const options = parseArgs();\n\n  if (options.version) {\n    console.log(packageJson.version);\n    process.exit(0);\n  }\n\n  if (options.help) {\n    showHelp();\n    process.exit(0);\n  }\n\n  try {\n    const { MCPServer } = await import('../dist/index.js');\n    \n    const server = new MCPServer({\n      name: packageJson.name,\n      version: packageJson.version,\n      configFile: options.config\n    });\n\n    console.log(`Starting ${packageJson.name} v${packageJson.version}`);\n    console.log(`Transport: ${options.transport}`);\n    \n    if (options.transport === 'http') {\n      console.log(`Port: ${options.port}`);\n      await server.listen(options.port);\n    } else {\n      console.log('Using stdio transport');\n      await server.run();\n    }\n    \n  } catch (error) {\n    console.error('Failed to start server:', error.message);\n    process.exit(1);\n  }\n}\n\n// Handle process signals\nprocess.on('SIGINT', () =&gt; {\n  console.log('\\nReceived SIGINT, shutting down gracefully...');\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () =&gt; {\n  console.log('\\nReceived SIGTERM, shutting down gracefully...');\n  process.exit(0);\n});\n\nmain().catch((error) =&gt; {\n  console.error('Unhandled error:', error);\n  process.exit(1);\n});\n</code></pre>"},{"location":"develop/javascript/packaging/#browser-distribution","title":"Browser Distribution","text":""},{"location":"develop/javascript/packaging/#webpack-configuration","title":"Webpack Configuration","text":"<pre><code>// webpack.config.js\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\nmodule.exports = (env, argv) =&gt; {\n  const isProduction = argv.mode === 'production';\n  \n  return {\n    entry: {\n      main: './src/browser/index.js',\n      worker: './src/browser/worker.js'\n    },\n    \n    output: {\n      filename: isProduction ? '[name].[contenthash].js' : '[name].js',\n      path: path.resolve(__dirname, 'dist/browser'),\n      clean: true,\n      library: {\n        name: 'MCPClient',\n        type: 'umd'\n      }\n    },\n    \n    module: {\n      rules: [\n        {\n          test: /\\.js$/,\n          exclude: /node_modules/,\n          use: {\n            loader: 'babel-loader',\n            options: {\n              presets: [\n                ['@babel/preset-env', {\n                  targets: {\n                    browsers: ['&gt; 1%', 'last 2 versions']\n                  }\n                }]\n              ]\n            }\n          }\n        },\n        {\n          test: /\\.css$/i,\n          use: ['style-loader', 'css-loader']\n        },\n        {\n          test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n          type: 'asset/resource'\n        }\n      ]\n    },\n    \n    plugins: [\n      new CleanWebpackPlugin(),\n      new HtmlWebpackPlugin({\n        title: 'MCP Client',\n        template: './src/browser/index.html',\n        chunks: ['main']\n      })\n    ],\n    \n    optimization: {\n      splitChunks: {\n        chunks: 'all',\n        cacheGroups: {\n          vendor: {\n            test: /[\\\\/]node_modules[\\\\/]/,\n            name: 'vendors',\n            chunks: 'all',\n          }\n        }\n      }\n    },\n    \n    devServer: {\n      static: './dist/browser',\n      port: 3000,\n      hot: true,\n      open: true\n    },\n    \n    resolve: {\n      fallback: {\n        \"buffer\": require.resolve(\"buffer/\"),\n        \"process\": require.resolve(\"process/browser\"),\n        \"stream\": require.resolve(\"stream-browserify\"),\n        \"util\": require.resolve(\"util/\")\n      }\n    }\n  };\n};\n</code></pre>"},{"location":"develop/javascript/packaging/#docker-packaging","title":"Docker Packaging","text":""},{"location":"develop/javascript/packaging/#multi-stage-dockerfile","title":"Multi-stage Dockerfile","text":"<pre><code># Build stage\nFROM node:20-alpine AS builder\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\nCOPY tsconfig.json ./\nCOPY rollup.config.js ./\n\n# Install dependencies\nRUN npm ci --only=production\n\n# Copy source code\nCOPY src/ ./src/\n\n# Build application\nRUN npm run build\n\n# Production stage\nFROM node:20-alpine AS production\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs &amp;&amp; \\\n    adduser -S mcp -u 1001\n\nWORKDIR /app\n\n# Copy built application\nCOPY --from=builder --chown=mcp:nodejs /app/dist ./dist\nCOPY --from=builder --chown=mcp:nodejs /app/package*.json ./\nCOPY --from=builder --chown=mcp:nodejs /app/bin ./bin\n\n# Install production dependencies only\nRUN npm ci --omit=dev --cache /tmp/empty-cache &amp;&amp; \\\n    rm -rf /tmp/empty-cache\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node -e \"console.log('OK')\" || exit 1\n\n# Switch to non-root user\nUSER mcp\n\n# Expose port\nEXPOSE 8000\n\n# Default command\nCMD [\"node\", \"bin/server.js\", \"--transport\", \"http\", \"--port\", \"8000\"]\n</code></pre>"},{"location":"develop/javascript/packaging/#docker-compose-for-development","title":"Docker Compose for Development","text":"<pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  mcp-server:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - NODE_ENV=production\n      - PORT=8000\n      - LOG_LEVEL=info\n    volumes:\n      - ./config:/app/config:ro\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  mcp-client:\n    build:\n      context: .\n      dockerfile: Dockerfile.client\n    ports:\n      - \"3000:3000\"\n    environment:\n      - REACT_APP_MCP_SERVER_URL=http://mcp-server:8000\n    depends_on:\n      - mcp-server\n</code></pre>"},{"location":"develop/javascript/packaging/#publishing","title":"Publishing","text":""},{"location":"develop/javascript/packaging/#npm-publishing-workflow","title":"NPM Publishing Workflow","text":"<pre><code>// scripts/publish.js\n#!/usr/bin/env node\n\nimport { execSync } from 'child_process';\nimport { readFileSync, writeFileSync } from 'fs';\n\n// Validate environment\nif (!process.env.NPM_TOKEN) {\n  console.error('NPM_TOKEN environment variable is required');\n  process.exit(1);\n}\n\n// Read package.json\nconst packageJson = JSON.parse(readFileSync('package.json', 'utf8'));\nconst currentVersion = packageJson.version;\n\nconsole.log(`Publishing ${packageJson.name} v${currentVersion}`);\n\ntry {\n  // Run pre-publish checks\n  console.log('Running pre-publish checks...');\n  execSync('npm run lint', { stdio: 'inherit' });\n  execSync('npm test', { stdio: 'inherit' });\n  execSync('npm run build', { stdio: 'inherit' });\n  \n  // Publish to npm\n  console.log('Publishing to npm...');\n  execSync('npm publish --access public', { stdio: 'inherit' });\n  \n  // Create git tag\n  console.log('Creating git tag...');\n  execSync(`git tag v${currentVersion}`, { stdio: 'inherit' });\n  execSync('git push origin --tags', { stdio: 'inherit' });\n  \n  console.log(`\u2705 Successfully published ${packageJson.name} v${currentVersion}`);\n  \n} catch (error) {\n  console.error('\u274c Publish failed:', error.message);\n  process.exit(1);\n}\n</code></pre>"},{"location":"develop/javascript/packaging/#github-actions-publishing","title":"GitHub Actions Publishing","text":"<pre><code># .github/workflows/publish.yml\nname: Publish Package\n\non:\n  release:\n    types: [published]\n\njobs:\n  publish-npm:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          registry-url: 'https://registry.npmjs.org'\n      \n      - name: Install dependencies\n        run: npm ci\n      \n      - name: Run tests\n        run: npm test\n      \n      - name: Build package\n        run: npm run build\n      \n      - name: Publish to NPM\n        run: npm publish --access public\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n\n  publish-docker:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n      \n      - name: Login to Docker Hub\n        uses: docker/login-action@v3\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      \n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: your-org/mcp-server\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n      \n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n</code></pre>"},{"location":"develop/javascript/packaging/#distribution-formats","title":"Distribution Formats","text":""},{"location":"develop/javascript/packaging/#multiple-export-formats","title":"Multiple Export Formats","text":"<pre><code>// scripts/build-all.js\nimport { execSync } from 'child_process';\nimport { mkdirSync, existsSync } from 'fs';\n\n// Ensure dist directory exists\nif (!existsSync('dist')) {\n  mkdirSync('dist', { recursive: true });\n}\n\nconsole.log('Building all distribution formats...');\n\n// Build TypeScript\nconsole.log('\ud83d\udce6 Building TypeScript...');\nexecSync('tsc', { stdio: 'inherit' });\n\n// Build ES modules\nconsole.log('\ud83d\udce6 Building ES modules...');\nexecSync('rollup -c --format es --file dist/index.esm.js', { stdio: 'inherit' });\n\n// Build CommonJS\nconsole.log('\ud83d\udce6 Building CommonJS...');\nexecSync('rollup -c --format cjs --file dist/index.cjs', { stdio: 'inherit' });\n\n// Build UMD for browsers\nconsole.log('\ud83d\udce6 Building UMD...');\nexecSync('rollup -c --format umd --name MCPServer --file dist/index.umd.js', { stdio: 'inherit' });\n\n// Build minified version\nconsole.log('\ud83d\udce6 Building minified version...');\nexecSync('rollup -c --format umd --name MCPServer --file dist/index.umd.min.js --environment NODE_ENV:production', { stdio: 'inherit' });\n\n// Build CLI executable\nconsole.log('\ud83d\udce6 Building CLI executable...');\nexecSync('rollup -c rollup.cli.config.js', { stdio: 'inherit' });\n\nconsole.log('\u2705 All builds completed successfully!');\n</code></pre>"},{"location":"develop/javascript/packaging/#version-management","title":"Version Management","text":""},{"location":"develop/javascript/packaging/#semantic-release-configuration","title":"Semantic Release Configuration","text":"<pre><code>// .releaserc.json\n{\n  \"branches\": [\n    \"main\",\n    {\n      \"name\": \"beta\",\n      \"prerelease\": true\n    }\n  ],\n  \"plugins\": [\n    \"@semantic-release/commit-analyzer\",\n    \"@semantic-release/release-notes-generator\",\n    [\n      \"@semantic-release/changelog\",\n      {\n        \"changelogFile\": \"CHANGELOG.md\"\n      }\n    ],\n    [\n      \"@semantic-release/npm\",\n      {\n        \"npmPublish\": true\n      }\n    ],\n    [\n      \"@semantic-release/github\",\n      {\n        \"assets\": [\n          {\n            \"path\": \"dist/*.js\",\n            \"label\": \"Distribution files\"\n          }\n        ]\n      }\n    ],\n    [\n      \"@semantic-release/git\",\n      {\n        \"assets\": [\"package.json\", \"CHANGELOG.md\"],\n        \"message\": \"chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}\"\n      }\n    ]\n  ]\n}\n</code></pre>"},{"location":"develop/javascript/packaging/#best-practices","title":"Best Practices","text":""},{"location":"develop/javascript/packaging/#package-optimization","title":"Package Optimization","text":"<ol> <li>Tree Shaking: Structure code to support tree shaking</li> <li>Bundle Size: Monitor and optimize bundle size</li> <li>Dependencies: Minimize runtime dependencies</li> <li>Polyfills: Include necessary polyfills for browser compatibility</li> </ol>"},{"location":"develop/javascript/packaging/#security","title":"Security","text":"<ol> <li>Dependency Scanning: Regularly scan for vulnerable dependencies</li> <li>Package Signing: Sign packages when publishing</li> <li>Access Control: Use proper NPM access controls</li> <li>Secrets Management: Never commit API keys or secrets</li> </ol>"},{"location":"develop/javascript/packaging/#distribution","title":"Distribution","text":"<ol> <li>Multiple Formats: Support ESM, CommonJS, and UMD formats</li> <li>Browser Compatibility: Test across different browsers</li> <li>Node.js Versions: Support multiple Node.js versions</li> <li>Documentation: Include comprehensive installation and usage docs</li> </ol> <p>Proper packaging ensures your MCP applications are accessible, maintainable, and easy to deploy across different environments and platforms.</p>"},{"location":"develop/javascript/testing/","title":"Testing","text":""},{"location":"develop/javascript/testing/#javascript-testing","title":"JavaScript Testing","text":""},{"location":"develop/javascript/testing/#testing-strategy-for-javascript-mcp-applications","title":"Testing Strategy for JavaScript MCP Applications","text":"<p>Comprehensive testing ensures your MCP servers and clients work reliably across different environments and scenarios.</p>"},{"location":"develop/javascript/testing/#testing-stack","title":"Testing Stack","text":""},{"location":"develop/javascript/testing/#core-testing-tools","title":"Core Testing Tools","text":"<pre><code># Install testing dependencies\nnpm install --save-dev \\\n  jest \\\n  @jest/globals \\\n  jest-environment-node \\\n  supertest \\\n  nock \\\n  msw\n</code></pre>"},{"location":"develop/javascript/testing/#jest-configuration","title":"Jest Configuration","text":"<pre><code>// jest.config.js\nexport default {\n  testEnvironment: 'node',\n  extensionsToTreatAsEsm: ['.js'],\n  globals: {\n    'ts-jest': {\n      useESM: true\n    }\n  },\n  moduleNameMapping: {\n    '^(\\\\.{1,2}/.*)\\\\.js$': '$1'\n  },\n  transform: {\n    '^.+\\\\.js$': ['babel-jest', { presets: [['@babel/preset-env', { targets: { node: 'current' } }]] }]\n  },\n  collectCoverageFrom: [\n    'src/**/*.js',\n    '!src/**/*.test.js',\n    '!src/test-helpers/**'\n  ],\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n  testMatch: [\n    '**/src/**/__tests__/**/*.js',\n    '**/src/**/*.test.js'\n  ],\n  setupFilesAfterEnv: ['&lt;rootDir&gt;/src/test-setup.js']\n};\n</code></pre>"},{"location":"develop/javascript/testing/#unit-testing-mcp-servers","title":"Unit Testing MCP Servers","text":""},{"location":"develop/javascript/testing/#testing-tool-handlers","title":"Testing Tool Handlers","text":"<pre><code>// src/tools/__tests__/database-tools.test.js\nimport { jest } from '@jest/globals';\nimport { DatabaseTools } from '../database-tools.js';\n\ndescribe('DatabaseTools', () =&gt; {\n  let dbTools;\n  let mockDatabase;\n\n  beforeEach(() =&gt; {\n    mockDatabase = {\n      query: jest.fn(),\n      connect: jest.fn(),\n      close: jest.fn()\n    };\n    dbTools = new DatabaseTools(mockDatabase);\n  });\n\n  afterEach(() =&gt; {\n    jest.clearAllMocks();\n  });\n\n  describe('executeQuery', () =&gt; {\n    it('should execute valid SELECT query', async () =&gt; {\n      const mockResults = [\n        { id: 1, name: 'John' },\n        { id: 2, name: 'Jane' }\n      ];\n      \n      mockDatabase.query.mockResolvedValue({ rows: mockResults });\n\n      const result = await dbTools.executeQuery({\n        query: 'SELECT * FROM users',\n        limit: 10\n      });\n\n      expect(mockDatabase.query).toHaveBeenCalledWith(\n        'SELECT * FROM users LIMIT $1',\n        [10]\n      );\n      \n      expect(result).toEqual({\n        content: [{\n          type: 'text',\n          text: JSON.stringify(mockResults, null, 2)\n        }]\n      });\n    });\n\n    it('should reject dangerous queries', async () =&gt; {\n      await expect(dbTools.executeQuery({\n        query: 'DROP TABLE users'\n      })).rejects.toThrow('Dangerous query detected');\n\n      expect(mockDatabase.query).not.toHaveBeenCalled();\n    });\n\n    it('should handle database connection errors', async () =&gt; {\n      mockDatabase.query.mockRejectedValue(new Error('Connection failed'));\n\n      await expect(dbTools.executeQuery({\n        query: 'SELECT 1'\n      })).rejects.toThrow('Database error: Connection failed');\n    });\n\n    it('should validate input parameters', async () =&gt; {\n      await expect(dbTools.executeQuery({})).rejects.toThrow('Query is required');\n      \n      await expect(dbTools.executeQuery({\n        query: ''\n      })).rejects.toThrow('Query cannot be empty');\n      \n      await expect(dbTools.executeQuery({\n        query: 'SELECT * FROM users',\n        limit: -1\n      })).rejects.toThrow('Limit must be positive');\n    });\n  });\n\n  describe('listTables', () =&gt; {\n    it('should return available tables', async () =&gt; {\n      const mockTables = ['users', 'products', 'orders'];\n      mockDatabase.query.mockResolvedValue({\n        rows: mockTables.map(name =&gt; ({ table_name: name }))\n      });\n\n      const result = await dbTools.listTables();\n\n      expect(result.content[0].text).toContain('users');\n      expect(result.content[0].text).toContain('products');\n      expect(result.content[0].text).toContain('orders');\n    });\n  });\n});\n</code></pre>"},{"location":"develop/javascript/testing/#testing-http-tools","title":"Testing HTTP Tools","text":"<pre><code>// src/tools/__tests__/http-tools.test.js\nimport nock from 'nock';\nimport { HTTPTools } from '../http-tools.js';\n\ndescribe('HTTPTools', () =&gt; {\n  let httpTools;\n\n  beforeEach(() =&gt; {\n    httpTools = new HTTPTools();\n    nock.cleanAll();\n  });\n\n  afterEach(() =&gt; {\n    nock.cleanAll();\n  });\n\n  describe('fetchUrl', () =&gt; {\n    it('should fetch URL successfully', async () =&gt; {\n      const mockData = { message: 'Hello, World!' };\n      \n      nock('https://api.example.com')\n        .get('/test')\n        .reply(200, mockData);\n\n      const result = await httpTools.fetchUrl({\n        url: 'https://api.example.com/test'\n      });\n\n      expect(result.content[0].text).toContain(JSON.stringify(mockData));\n    });\n\n    it('should handle HTTP errors', async () =&gt; {\n      nock('https://api.example.com')\n        .get('/error')\n        .reply(404, { error: 'Not found' });\n\n      await expect(httpTools.fetchUrl({\n        url: 'https://api.example.com/error'\n      })).rejects.toThrow('HTTP 404');\n    });\n\n    it('should handle network timeouts', async () =&gt; {\n      nock('https://api.example.com')\n        .get('/slow')\n        .delay(6000)\n        .reply(200, 'OK');\n\n      await expect(httpTools.fetchUrl({\n        url: 'https://api.example.com/slow',\n        timeout: 1000\n      })).rejects.toThrow('timeout');\n    });\n\n    it('should validate URLs', async () =&gt; {\n      await expect(httpTools.fetchUrl({\n        url: 'not-a-url'\n      })).rejects.toThrow('Invalid URL');\n\n      await expect(httpTools.fetchUrl({\n        url: 'javascript:alert(\"xss\")'\n      })).rejects.toThrow('Invalid protocol');\n    });\n  });\n\n  describe('postData', () =&gt; {\n    it('should send POST requests with JSON data', async () =&gt; {\n      const requestData = { name: 'John', email: 'john@example.com' };\n      const responseData = { id: 123, status: 'created' };\n\n      nock('https://api.example.com')\n        .post('/users', requestData)\n        .reply(201, responseData);\n\n      const result = await httpTools.postData({\n        url: 'https://api.example.com/users',\n        data: requestData\n      });\n\n      expect(result.content[0].text).toContain(JSON.stringify(responseData));\n    });\n  });\n});\n</code></pre>"},{"location":"develop/javascript/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"develop/javascript/testing/#testing-complete-mcp-server","title":"Testing Complete MCP Server","text":"<pre><code>// src/__tests__/server.integration.test.js\nimport { jest } from '@jest/globals';\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { MCPServer } from '../server.js';\n\ndescribe('MCP Server Integration', () =&gt; {\n  let server;\n  let mockTransport;\n\n  beforeEach(async () =&gt; {\n    mockTransport = {\n      start: jest.fn(),\n      close: jest.fn(),\n      send: jest.fn(),\n      onmessage: null,\n      onerror: null,\n      onclose: null\n    };\n\n    server = new MCPServer('test-server', '1.0.0');\n  });\n\n  afterEach(async () =&gt; {\n    if (server) {\n      await server.close();\n    }\n  });\n\n  describe('Tool Discovery', () =&gt; {\n    it('should list all registered tools', async () =&gt; {\n      const response = await simulateRequest({\n        jsonrpc: '2.0',\n        method: 'tools/list',\n        id: 1\n      });\n\n      expect(response.result.tools).toBeInstanceOf(Array);\n      expect(response.result.tools.length).toBeGreaterThan(0);\n      \n      const toolNames = response.result.tools.map(t =&gt; t.name);\n      expect(toolNames).toContain('database_query');\n      expect(toolNames).toContain('http_fetch');\n    });\n\n    it('should provide complete tool schemas', async () =&gt; {\n      const response = await simulateRequest({\n        jsonrpc: '2.0',\n        method: 'tools/list', \n        id: 1\n      });\n\n      const dbTool = response.result.tools.find(t =&gt; t.name === 'database_query');\n      expect(dbTool).toBeDefined();\n      expect(dbTool.description).toBeTruthy();\n      expect(dbTool.inputSchema).toBeDefined();\n      expect(dbTool.inputSchema.properties).toBeDefined();\n    });\n  });\n\n  describe('Tool Execution', () =&gt; {\n    it('should execute tools with valid parameters', async () =&gt; {\n      const response = await simulateRequest({\n        jsonrpc: '2.0',\n        method: 'tools/call',\n        params: {\n          name: 'echo',\n          arguments: { text: 'Hello, World!' }\n        },\n        id: 1\n      });\n\n      expect(response.result.content).toBeInstanceOf(Array);\n      expect(response.result.content[0].text).toContain('Hello, World!');\n    });\n\n    it('should handle tool errors gracefully', async () =&gt; {\n      const response = await simulateRequest({\n        jsonrpc: '2.0',\n        method: 'tools/call',\n        params: {\n          name: 'database_query',\n          arguments: { query: 'INVALID SQL' }\n        },\n        id: 1\n      });\n\n      expect(response.error).toBeDefined();\n      expect(response.error.message).toContain('syntax error');\n    });\n\n    it('should validate tool arguments', async () =&gt; {\n      const response = await simulateRequest({\n        jsonrpc: '2.0',\n        method: 'tools/call',\n        params: {\n          name: 'echo',\n          arguments: {} // Missing required 'text' parameter\n        },\n        id: 1\n      });\n\n      expect(response.error).toBeDefined();\n      expect(response.error.message).toContain('required');\n    });\n  });\n\n  // Helper function to simulate JSON-RPC requests\n  async function simulateRequest(request) {\n    return new Promise((resolve) =&gt; {\n      const handler = server.server.getRequestHandler(request.method);\n      handler(request).then(result =&gt; {\n        resolve({\n          jsonrpc: '2.0',\n          id: request.id,\n          result\n        });\n      }).catch(error =&gt; {\n        resolve({\n          jsonrpc: '2.0',\n          id: request.id,\n          error: {\n            code: -32603,\n            message: error.message\n          }\n        });\n      });\n    });\n  }\n});\n</code></pre>"},{"location":"develop/javascript/testing/#testing-browser-clients","title":"Testing Browser Clients","text":""},{"location":"develop/javascript/testing/#mock-service-worker-setup","title":"Mock Service Worker Setup","text":"<pre><code>// src/test-helpers/msw-setup.js\nimport { setupServer } from 'msw/node';\nimport { rest } from 'msw';\n\n// Mock MCP server responses\nexport const server = setupServer(\n  rest.post('http://localhost:8000/mcp', (req, res, ctx) =&gt; {\n    const { method, params } = req.body;\n    \n    if (method === 'tools/list') {\n      return res(\n        ctx.json({\n          jsonrpc: '2.0',\n          id: req.body.id,\n          result: {\n            tools: [\n              {\n                name: 'echo',\n                description: 'Echo back text',\n                inputSchema: {\n                  type: 'object',\n                  properties: {\n                    text: { type: 'string' }\n                  },\n                  required: ['text']\n                }\n              }\n            ]\n          }\n        })\n      );\n    }\n    \n    if (method === 'tools/call' &amp;&amp; params.name === 'echo') {\n      return res(\n        ctx.json({\n          jsonrpc: '2.0',\n          id: req.body.id,\n          result: {\n            content: [{\n              type: 'text',\n              text: `Echo: ${params.arguments.text}`\n            }]\n          }\n        })\n      );\n    }\n    \n    return res(\n      ctx.status(404),\n      ctx.json({\n        jsonrpc: '2.0',\n        id: req.body.id,\n        error: {\n          code: -32601,\n          message: 'Method not found'\n        }\n      })\n    );\n  })\n);\n\n// Start server before all tests\nbeforeAll(() =&gt; server.listen());\n\n// Reset handlers after each test\nafterEach(() =&gt; server.resetHandlers());\n\n// Clean up after all tests\nafterAll(() =&gt; server.close());\n</code></pre>"},{"location":"develop/javascript/testing/#browser-client-testing","title":"Browser Client Testing","text":"<pre><code>// src/__tests__/browser-client.test.js\nimport { screen, fireEvent, waitFor } from '@testing-library/dom';\nimport '@testing-library/jest-dom';\nimport { MCPWebClient } from '../browser-client.js';\n\n// Mock fetch globally\nglobal.fetch = jest.fn();\n\ndescribe('Browser MCP Client', () =&gt; {\n  let client;\n  let mockContainer;\n\n  beforeEach(() =&gt; {\n    // Create DOM container for testing\n    mockContainer = document.createElement('div');\n    mockContainer.innerHTML = `\n      &lt;input id=\"serverUrl\" value=\"http://localhost:8000/mcp\"&gt;\n      &lt;button id=\"connectBtn\"&gt;Connect&lt;/button&gt;\n      &lt;div id=\"connectionStatus\"&gt;&lt;/div&gt;\n      &lt;div id=\"toolsList\"&gt;&lt;/div&gt;\n      &lt;div id=\"results\"&gt;&lt;/div&gt;\n    `;\n    document.body.appendChild(mockContainer);\n\n    client = new MCPWebClient();\n    \n    // Reset fetch mock\n    fetch.mockClear();\n  });\n\n  afterEach(() =&gt; {\n    document.body.removeChild(mockContainer);\n  });\n\n  describe('Connection', () =&gt; {\n    it('should connect to MCP server successfully', async () =&gt; {\n      fetch.mockResolvedValueOnce({\n        ok: true,\n        json: () =&gt; Promise.resolve({\n          jsonrpc: '2.0',\n          id: 1,\n          result: {}\n        })\n      });\n\n      const connectBtn = screen.getByText('Connect');\n      fireEvent.click(connectBtn);\n\n      await waitFor(() =&gt; {\n        expect(fetch).toHaveBeenCalledWith(\n          'http://localhost:8000/mcp',\n          expect.objectContaining({\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' }\n          })\n        );\n      });\n    });\n\n    it('should handle connection errors', async () =&gt; {\n      fetch.mockRejectedValueOnce(new Error('Network error'));\n\n      const connectBtn = screen.getByText('Connect');\n      fireEvent.click(connectBtn);\n\n      await waitFor(() =&gt; {\n        const status = screen.getByText(/Connection failed/);\n        expect(status).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Tool Management', () =&gt; {\n    beforeEach(async () =&gt; {\n      // Mock successful connection\n      fetch.mockResolvedValue({\n        ok: true,\n        json: () =&gt; Promise.resolve({\n          jsonrpc: '2.0',\n          id: 1,\n          result: {\n            tools: [{\n              name: 'echo',\n              description: 'Echo text',\n              inputSchema: {\n                type: 'object',\n                properties: {\n                  text: { type: 'string' }\n                },\n                required: ['text']\n              }\n            }]\n          }\n        })\n      });\n\n      await client.connect();\n    });\n\n    it('should load and display tools', async () =&gt; {\n      await waitFor(() =&gt; {\n        expect(screen.getByText('echo')).toBeInTheDocument();\n        expect(screen.getByText('Echo text')).toBeInTheDocument();\n      });\n    });\n\n    it('should generate input fields from schema', async () =&gt; {\n      await waitFor(() =&gt; {\n        const textInput = screen.getByPlaceholderText(/text/i);\n        expect(textInput).toBeInTheDocument();\n        expect(textInput.type).toBe('text');\n      });\n    });\n\n    it('should call tools with user input', async () =&gt; {\n      fetch.mockResolvedValueOnce({\n        ok: true,\n        json: () =&gt; Promise.resolve({\n          jsonrpc: '2.0',\n          id: 2,\n          result: {\n            content: [{ type: 'text', text: 'Echo: Hello' }]\n          }\n        })\n      });\n\n      await waitFor(() =&gt; {\n        const textInput = screen.getByPlaceholderText(/text/i);\n        fireEvent.change(textInput, { target: { value: 'Hello' } });\n        \n        const callBtn = screen.getByText('Call Tool');\n        fireEvent.click(callBtn);\n      });\n\n      await waitFor(() =&gt; {\n        expect(fetch).toHaveBeenCalledWith(\n          'http://localhost:8000/mcp',\n          expect.objectContaining({\n            body: expect.stringContaining('\"arguments\":{\"text\":\"Hello\"}')\n          })\n        );\n      });\n    });\n  });\n});\n</code></pre>"},{"location":"develop/javascript/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"develop/javascript/testing/#load-testing-tools","title":"Load Testing Tools","text":"<pre><code>// src/__tests__/performance.test.js\nimport { performance } from 'perf_hooks';\nimport { MCPServer } from '../server.js';\n\ndescribe('Performance Tests', () =&gt; {\n  let server;\n\n  beforeEach(() =&gt; {\n    server = new MCPServer('perf-test-server', '1.0.0');\n  });\n\n  describe('Response Times', () =&gt; {\n    it('should respond to tool calls within acceptable time', async () =&gt; {\n      const startTime = performance.now();\n      \n      await server.handleToolCall('echo', { text: 'performance test' });\n      \n      const endTime = performance.now();\n      const responseTime = endTime - startTime;\n      \n      expect(responseTime).toBeLessThan(100); // 100ms threshold\n    });\n\n    it('should handle concurrent requests efficiently', async () =&gt; {\n      const numberOfRequests = 100;\n      const requests = Array.from({ length: numberOfRequests }, (_, i) =&gt; \n        server.handleToolCall('echo', { text: `request ${i}` })\n      );\n\n      const startTime = performance.now();\n      await Promise.all(requests);\n      const endTime = performance.now();\n\n      const totalTime = endTime - startTime;\n      const avgResponseTime = totalTime / numberOfRequests;\n\n      expect(avgResponseTime).toBeLessThan(50); // Average under 50ms\n    });\n  });\n\n  describe('Memory Usage', () =&gt; {\n    it('should not leak memory during repeated operations', async () =&gt; {\n      const initialMemory = process.memoryUsage().heapUsed;\n      \n      // Perform many operations\n      for (let i = 0; i &lt; 1000; i++) {\n        await server.handleToolCall('echo', { text: `iteration ${i}` });\n      }\n      \n      // Force garbage collection if available\n      if (global.gc) {\n        global.gc();\n      }\n      \n      const finalMemory = process.memoryUsage().heapUsed;\n      const memoryIncrease = finalMemory - initialMemory;\n      \n      // Memory increase should be reasonable (less than 10MB)\n      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);\n    });\n  });\n});\n</code></pre>"},{"location":"develop/javascript/testing/#test-coverage-and-reporting","title":"Test Coverage and Reporting","text":""},{"location":"develop/javascript/testing/#coverage-configuration","title":"Coverage Configuration","text":"<pre><code>// jest.config.js (coverage section)\nexport default {\n  // ... other config\n  collectCoverageFrom: [\n    'src/**/*.js',\n    '!src/**/*.test.js',\n    '!src/**/index.js',\n    '!src/test-helpers/**'\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80\n    },\n    './src/tools/': {\n      branches: 90,\n      functions: 90,\n      lines: 90,\n      statements: 90\n    }\n  }\n};\n</code></pre>"},{"location":"develop/javascript/testing/#custom-test-reporters","title":"Custom Test Reporters","text":"<pre><code>// src/test-helpers/custom-reporter.js\nexport default class CustomReporter {\n  constructor(globalConfig, options) {\n    this._globalConfig = globalConfig;\n    this._options = options;\n  }\n\n  onRunComplete(contexts, results) {\n    const { numTotalTests, numPassedTests, numFailedTests, testResults } = results;\n    \n    console.log('\\n=== Test Summary ===');\n    console.log(`Total Tests: ${numTotalTests}`);\n    console.log(`Passed: ${numPassedTests}`);\n    console.log(`Failed: ${numFailedTests}`);\n    \n    if (numFailedTests &gt; 0) {\n      console.log('\\n=== Failed Tests ===');\n      testResults.forEach(suite =&gt; {\n        suite.testResults.forEach(test =&gt; {\n          if (test.status === 'failed') {\n            console.log(`\u274c ${suite.testFilePath}: ${test.fullName}`);\n            test.failureMessages.forEach(msg =&gt; {\n              console.log(`   ${msg}`);\n            });\n          }\n        });\n      });\n    }\n    \n    console.log(`\\nTest run ${numFailedTests === 0 ? '\u2705 PASSED' : '\u274c FAILED'}`);\n  }\n}\n</code></pre>"},{"location":"develop/javascript/testing/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"develop/javascript/testing/#github-actions-testing","title":"GitHub Actions Testing","text":"<pre><code># .github/workflows/test.yml\nname: Test\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    strategy:\n      matrix:\n        node-version: [18, 20, 21]\n    \n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: ${{ matrix.node-version }}\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Run linter\n      run: npm run lint\n    \n    - name: Run type check\n      run: npm run type-check\n    \n    - name: Run tests\n      run: npm test -- --coverage\n    \n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage/lcov.info\n</code></pre>"},{"location":"develop/javascript/testing/#best-practices","title":"Best Practices","text":""},{"location":"develop/javascript/testing/#test-organization","title":"Test Organization","text":"<ol> <li>Describe Blocks: Group related tests logically</li> <li>Clear Names: Use descriptive test names that explain the behavior</li> <li>Arrange-Act-Assert: Structure tests with clear setup, execution, and verification</li> <li>One Assertion: Focus each test on a single behavior</li> </ol>"},{"location":"develop/javascript/testing/#mocking-strategy","title":"Mocking Strategy","text":"<ol> <li>External Dependencies: Mock all external services and APIs</li> <li>Database: Use in-memory databases or mocks for testing</li> <li>File System: Mock file operations to avoid test pollution</li> <li>Time: Mock time-dependent functions for predictable tests</li> </ol>"},{"location":"develop/javascript/testing/#performance","title":"Performance","text":"<ol> <li>Parallel Execution: Run tests in parallel when possible</li> <li>Test Isolation: Ensure tests don't depend on each other</li> <li>Fast Feedback: Prioritize unit tests for quick feedback</li> <li>Resource Cleanup: Clean up resources after tests</li> </ol> <p>Testing is essential for building reliable MCP applications. Focus on comprehensive coverage, realistic scenarios, and maintainable test code.</p>"},{"location":"develop/javascript/typescript/","title":"TypeScript","text":""},{"location":"develop/javascript/typescript/#typescript-development","title":"TypeScript Development","text":""},{"location":"develop/javascript/typescript/#using-typescript-for-mcp-servers","title":"Using TypeScript for MCP Servers","text":"<p>TypeScript provides excellent type safety and developer experience for building MCP servers, with strong support for JSON Schema validation and async programming patterns.</p>"},{"location":"develop/javascript/typescript/#typescript-setup","title":"TypeScript Setup","text":""},{"location":"develop/javascript/typescript/#project-initialization","title":"Project Initialization","text":"<pre><code># Initialize new TypeScript project\nnpm init -y\nnpm install -D typescript @types/node ts-node\n\n# Create TypeScript configuration\nnpx tsc --init\n</code></pre>"},{"location":"develop/javascript/typescript/#typescript-configuration","title":"TypeScript Configuration","text":"<pre><code>// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"lib\": [\"ES2022\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"noEmitOnError\": true,\n    \"exactOptionalPropertyTypes\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"**/*.test.ts\"]\n}\n</code></pre>"},{"location":"develop/javascript/typescript/#basic-typescript-mcp-server","title":"Basic TypeScript MCP Server","text":""},{"location":"develop/javascript/typescript/#type-safe-server-implementation","title":"Type-Safe Server Implementation","text":"<pre><code>// src/server.ts\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  Tool,\n  TextContent\n} from '@modelcontextprotocol/sdk/types.js';\nimport { z } from 'zod';\n\n// Input validation schemas\nconst EchoToolInputSchema = z.object({\n  text: z.string().min(1, \"Text cannot be empty\")\n});\n\nconst CalculatorToolInputSchema = z.object({\n  operation: z.enum(['add', 'subtract', 'multiply', 'divide']),\n  a: z.number(),\n  b: z.number()\n});\n\n// Type definitions\ntype EchoToolInput = z.infer&lt;typeof EchoToolInputSchema&gt;;\ntype CalculatorToolInput = z.infer&lt;typeof CalculatorToolInputSchema&gt;;\n\nclass MCPServer {\n  private server: Server;\n\n  constructor(name: string, version: string) {\n    this.server = new Server(\n      { name, version },\n      {\n        capabilities: {\n          tools: {}\n        }\n      }\n    );\n\n    this.setupToolHandlers();\n  }\n\n  private setupToolHandlers(): void {\n    // List available tools\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      async (): Promise&lt;{ tools: Tool[] }&gt; =&gt; {\n        return {\n          tools: [\n            {\n              name: 'echo',\n              description: 'Echo back the provided text',\n              inputSchema: {\n                type: 'object',\n                properties: {\n                  text: {\n                    type: 'string',\n                    description: 'Text to echo back'\n                  }\n                },\n                required: ['text']\n              }\n            },\n            {\n              name: 'calculator',\n              description: 'Perform basic arithmetic operations',\n              inputSchema: {\n                type: 'object',\n                properties: {\n                  operation: {\n                    type: 'string',\n                    enum: ['add', 'subtract', 'multiply', 'divide'],\n                    description: 'The operation to perform'\n                  },\n                  a: {\n                    type: 'number',\n                    description: 'First number'\n                  },\n                  b: {\n                    type: 'number', \n                    description: 'Second number'\n                  }\n                },\n                required: ['operation', 'a', 'b']\n              }\n            }\n          ]\n        };\n      }\n    );\n\n    // Handle tool calls\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request): Promise&lt;{ content: TextContent[] }&gt; =&gt; {\n        const { name, arguments: args } = request.params;\n\n        try {\n          switch (name) {\n            case 'echo':\n              return await this.handleEchoTool(args);\n            case 'calculator':\n              return await this.handleCalculatorTool(args);\n            default:\n              throw new Error(`Unknown tool: ${name}`);\n          }\n        } catch (error) {\n          const errorMessage = error instanceof Error \n            ? error.message \n            : 'An unknown error occurred';\n          \n          return {\n            content: [{\n              type: 'text',\n              text: `Error: ${errorMessage}`\n            }]\n          };\n        }\n      }\n    );\n  }\n\n  private async handleEchoTool(args: unknown): Promise&lt;{ content: TextContent[] }&gt; {\n    const input = EchoToolInputSchema.parse(args);\n    \n    return {\n      content: [{\n        type: 'text',\n        text: `Echo: ${input.text}`\n      }]\n    };\n  }\n\n  private async handleCalculatorTool(args: unknown): Promise&lt;{ content: TextContent[] }&gt; {\n    const input = CalculatorToolInputSchema.parse(args);\n    \n    let result: number;\n    \n    switch (input.operation) {\n      case 'add':\n        result = input.a + input.b;\n        break;\n      case 'subtract':\n        result = input.a - input.b;\n        break;\n      case 'multiply':\n        result = input.a * input.b;\n        break;\n      case 'divide':\n        if (input.b === 0) {\n          throw new Error('Division by zero is not allowed');\n        }\n        result = input.a / input.b;\n        break;\n    }\n\n    return {\n      content: [{\n        type: 'text',\n        text: `Result: ${input.a} ${input.operation} ${input.b} = ${result}`\n      }]\n    };\n  }\n\n  async run(): Promise&lt;void&gt; {\n    const transport = new StdioServerTransport();\n    await this.server.connect(transport);\n  }\n}\n\n// Main execution\nasync function main(): Promise&lt;void&gt; {\n  const server = new MCPServer('typescript-mcp-server', '1.0.0');\n  await server.run();\n}\n\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main().catch(console.error);\n}\n</code></pre>"},{"location":"develop/javascript/typescript/#advanced-typescript-patterns","title":"Advanced TypeScript Patterns","text":""},{"location":"develop/javascript/typescript/#generic-tool-handler","title":"Generic Tool Handler","text":"<pre><code>// src/types.ts\nimport { z } from 'zod';\nimport { TextContent } from '@modelcontextprotocol/sdk/types.js';\n\n// Generic tool interface\nexport interface ToolHandler&lt;TInput, TOutput = TextContent[]&gt; {\n  name: string;\n  description: string;\n  inputSchema: z.ZodSchema&lt;TInput&gt;;\n  handler: (input: TInput) =&gt; Promise&lt;{ content: TOutput }&gt;;\n}\n\n// Tool factory function\nexport function createTool&lt;TInput&gt;(\n  config: {\n    name: string;\n    description: string;\n    inputSchema: z.ZodSchema&lt;TInput&gt;;\n    handler: (input: TInput) =&gt; Promise&lt;{ content: TextContent[] }&gt;;\n  }\n): ToolHandler&lt;TInput&gt; {\n  return config;\n}\n\n// Example usage\nconst echoTool = createTool({\n  name: 'echo',\n  description: 'Echo back text',\n  inputSchema: z.object({\n    text: z.string(),\n    uppercase: z.boolean().optional()\n  }),\n  handler: async (input) =&gt; {\n    const text = input.uppercase ? input.text.toUpperCase() : input.text;\n    return {\n      content: [{\n        type: 'text',\n        text: `Echo: ${text}`\n      }]\n    };\n  }\n});\n</code></pre>"},{"location":"develop/javascript/typescript/#database-integration-with-type-safety","title":"Database Integration with Type Safety","text":"<pre><code>// src/database.ts\nimport { z } from 'zod';\nimport { createTool } from './types.js';\n\n// Database schema validation\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string().email(),\n  created_at: z.string().datetime()\n});\n\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\n// Mock database interface\ninterface Database {\n  users: {\n    findMany(where?: Partial&lt;User&gt;): Promise&lt;User[]&gt;;\n    findById(id: number): Promise&lt;User | null&gt;;\n    create(data: Omit&lt;User, 'id' | 'created_at'&gt;): Promise&lt;User&gt;;\n  };\n}\n\n// Database tool implementation\nexport const queryUsersTool = createTool({\n  name: 'query_users',\n  description: 'Query users from database',\n  inputSchema: z.object({\n    search: z.string().optional(),\n    limit: z.number().int().positive().max(100).default(10)\n  }),\n  handler: async (input) =&gt; {\n    // Type-safe database interaction\n    const db: Database = getDatabase();\n    \n    const users = await db.users.findMany({\n      ...(input.search &amp;&amp; { name: input.search })\n    });\n\n    const limitedUsers = users.slice(0, input.limit);\n    \n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify(limitedUsers, null, 2)\n      }]\n    };\n  }\n});\n\n// Mock database implementation\nfunction getDatabase(): Database {\n  return {\n    users: {\n      async findMany(where) {\n        // Implementation would connect to real database\n        return [];\n      },\n      async findById(id) {\n        return null;\n      },\n      async create(data) {\n        return {\n          id: Date.now(),\n          created_at: new Date().toISOString(),\n          ...data\n        };\n      }\n    }\n  };\n}\n</code></pre>"},{"location":"develop/javascript/typescript/#configuration-management","title":"Configuration Management","text":""},{"location":"develop/javascript/typescript/#type-safe-configuration","title":"Type-Safe Configuration","text":"<pre><code>// src/config.ts\nimport { z } from 'zod';\n\nconst ConfigSchema = z.object({\n  server: z.object({\n    name: z.string().default('typescript-mcp-server'),\n    version: z.string().default('1.0.0'),\n    debug: z.boolean().default(false)\n  }),\n  database: z.object({\n    url: z.string().url().optional(),\n    timeout: z.number().int().positive().default(30000),\n    pool_size: z.number().int().positive().default(10)\n  }),\n  api: z.object({\n    base_url: z.string().url().default('https://api.example.com'),\n    timeout: z.number().int().positive().default(5000),\n    retries: z.number().int().non-negative().default(3)\n  })\n});\n\nexport type Config = z.infer&lt;typeof ConfigSchema&gt;;\n\nexport function loadConfig(): Config {\n  const rawConfig = {\n    server: {\n      name: process.env.MCP_SERVER_NAME,\n      version: process.env.MCP_SERVER_VERSION,\n      debug: process.env.MCP_DEBUG === 'true'\n    },\n    database: {\n      url: process.env.DATABASE_URL,\n      timeout: process.env.DATABASE_TIMEOUT ? \n        parseInt(process.env.DATABASE_TIMEOUT) : undefined,\n      pool_size: process.env.DATABASE_POOL_SIZE ? \n        parseInt(process.env.DATABASE_POOL_SIZE) : undefined\n    },\n    api: {\n      base_url: process.env.API_BASE_URL,\n      timeout: process.env.API_TIMEOUT ? \n        parseInt(process.env.API_TIMEOUT) : undefined,\n      retries: process.env.API_RETRIES ? \n        parseInt(process.env.API_RETRIES) : undefined\n    }\n  };\n\n  return ConfigSchema.parse(rawConfig);\n}\n</code></pre>"},{"location":"develop/javascript/typescript/#error-handling","title":"Error Handling","text":""},{"location":"develop/javascript/typescript/#custom-error-types","title":"Custom Error Types","text":"<pre><code>// src/errors.ts\nexport abstract class MCPError extends Error {\n  abstract readonly code: string;\n  \n  constructor(message: string, public readonly details?: unknown) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class ValidationError extends MCPError {\n  readonly code = 'VALIDATION_ERROR';\n  \n  constructor(message: string, public readonly field?: string) {\n    super(message, { field });\n  }\n}\n\nexport class DatabaseError extends MCPError {\n  readonly code = 'DATABASE_ERROR';\n  \n  constructor(message: string, public readonly query?: string) {\n    super(message, { query });\n  }\n}\n\nexport class ExternalAPIError extends MCPError {\n  readonly code = 'EXTERNAL_API_ERROR';\n  \n  constructor(\n    message: string, \n    public readonly statusCode?: number,\n    public readonly service?: string\n  ) {\n    super(message, { statusCode, service });\n  }\n}\n\n// Error handling utility\nexport function handleError(error: unknown): { content: TextContent[] } {\n  if (error instanceof MCPError) {\n    return {\n      content: [{\n        type: 'text',\n        text: `Error (${error.code}): ${error.message}`\n      }]\n    };\n  }\n  \n  if (error instanceof z.ZodError) {\n    const issues = error.errors.map(err =&gt; \n      `${err.path.join('.')}: ${err.message}`\n    ).join(', ');\n    \n    return {\n      content: [{\n        type: 'text',\n        text: `Validation Error: ${issues}`\n      }]\n    };\n  }\n  \n  return {\n    content: [{\n      type: 'text',\n      text: 'An unexpected error occurred'\n    }]\n  };\n}\n</code></pre>"},{"location":"develop/javascript/typescript/#testing-setup","title":"Testing Setup","text":""},{"location":"develop/javascript/typescript/#typescript-test-configuration","title":"TypeScript Test Configuration","text":"<pre><code>// src/__tests__/server.test.ts\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { MCPServer } from '../server.js';\n\ndescribe('MCPServer', () =&gt; {\n  let server: MCPServer;\n  \n  beforeEach(() =&gt; {\n    server = new MCPServer('test-server', '1.0.0');\n  });\n  \n  it('should handle echo tool correctly', async () =&gt; {\n    const result = await server.handleEchoTool({ text: 'Hello, World!' });\n    \n    expect(result.content).toHaveLength(1);\n    expect(result.content[0].text).toBe('Echo: Hello, World!');\n  });\n  \n  it('should validate input schemas', async () =&gt; {\n    await expect(\n      server.handleEchoTool({ text: '' })\n    ).rejects.toThrow('Text cannot be empty');\n  });\n  \n  it('should handle calculator operations', async () =&gt; {\n    const result = await server.handleCalculatorTool({\n      operation: 'add',\n      a: 5,\n      b: 3\n    });\n    \n    expect(result.content[0].text).toBe('Result: 5 add 3 = 8');\n  });\n});\n</code></pre>"},{"location":"develop/javascript/typescript/#build-and-development-scripts","title":"Build and Development Scripts","text":""},{"location":"develop/javascript/typescript/#packagejson-configuration","title":"Package.json Configuration","text":"<pre><code>{\n  \"name\": \"typescript-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"ts-node --esm src/server.ts\",\n    \"start\": \"node dist/server.js\",\n    \"test\": \"vitest\",\n    \"test:coverage\": \"vitest --coverage\",\n    \"lint\": \"eslint src/**/*.ts\",\n    \"lint:fix\": \"eslint src/**/*.ts --fix\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^0.1.0\",\n    \"zod\": \"^3.22.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.10.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\",\n    \"eslint\": \"^8.56.0\",\n    \"ts-node\": \"^10.9.0\",\n    \"typescript\": \"^5.3.0\",\n    \"vitest\": \"^1.0.0\",\n    \"@vitest/coverage-v8\": \"^1.0.0\"\n  }\n}\n</code></pre>"},{"location":"develop/javascript/typescript/#best-practices","title":"Best Practices","text":""},{"location":"develop/javascript/typescript/#code-organization","title":"Code Organization","text":"<ol> <li>Strict TypeScript: Use strict mode and exact optional properties</li> <li>Schema Validation: Validate all inputs with Zod schemas</li> <li>Error Handling: Use custom error types with proper context</li> <li>Type Safety: Leverage TypeScript's type system fully</li> </ol>"},{"location":"develop/javascript/typescript/#performance","title":"Performance","text":"<ol> <li>Compilation: Use incremental compilation for faster builds</li> <li>Tree Shaking: Structure code for optimal bundling</li> <li>Memory Management: Avoid memory leaks in long-running processes</li> </ol>"},{"location":"develop/javascript/typescript/#development-experience","title":"Development Experience","text":"<ol> <li>IDE Support: Configure proper TypeScript language server settings</li> <li>Debugging: Use source maps for better debugging experience</li> <li>Hot Reload: Use ts-node or similar for development</li> <li>Code Quality: Integrate ESLint and Prettier</li> </ol> <p>TypeScript provides excellent tooling and type safety for building robust MCP servers with confidence in your code's correctness.</p>"},{"location":"develop/python/","title":"Python Overview","text":""},{"location":"develop/python/#python-development","title":"Python Development","text":""},{"location":"develop/python/#mcp-server-development-with-python","title":"MCP Server Development with Python","text":"<p>Python is the recommended language for MCP server development, offering a mature SDK and extensive ecosystem.</p>"},{"location":"develop/python/#quick-start","title":"Quick Start","text":""},{"location":"develop/python/#installation","title":"Installation","text":"<pre><code># Using uv (recommended)\nuv add mcp\n\n# Using pip\npip install mcp\n</code></pre>"},{"location":"develop/python/#minimal-server","title":"Minimal Server","text":"<pre><code>import asyncio\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Tool, TextContent\n\n# Create server instance\nserver = Server(\"my-server\")\n\n@server.list_tools()\nasync def list_tools():\n    \"\"\"List available tools.\"\"\"\n    return [\n        Tool(\n            name=\"hello\",\n            description=\"Say hello to someone\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\"type\": \"string\"}\n                },\n                \"required\": [\"name\"]\n            }\n        )\n    ]\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict):\n    \"\"\"Execute a tool.\"\"\"\n    if name == \"hello\":\n        name_arg = arguments.get(\"name\", \"World\")\n        return [TextContent(type=\"text\", text=f\"Hello, {name_arg}!\")]\n    \n    raise ValueError(f\"Unknown tool: {name}\")\n\nasync def main():\n    async with stdio_server() as (read_stream, write_stream):\n        await server.run(read_stream, write_stream)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"develop/python/#python-mcp-features","title":"Python MCP Features","text":""},{"location":"develop/python/#type-hints","title":"Type Hints","text":"<p>Python's type hints automatically generate JSON schemas: </p><pre><code>def process(\n    text: str,\n    count: int = 10,\n    enabled: bool = True\n) -&gt; dict[str, Any]:\n    \"\"\"Type hints define the tool interface\"\"\"\n</code></pre><p></p>"},{"location":"develop/python/#async-support","title":"Async Support","text":"<p>Full async/await support for I/O operations: </p><pre><code>import aiohttp\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict):\n    if name == \"fetch_data\":\n        url = arguments.get(\"url\")\n        async with aiohttp.ClientSession() as session:\n            async with session.get(url) as response:\n                text = await response.text()\n                return [TextContent(type=\"text\", text=text)]\n</code></pre><p></p>"},{"location":"develop/python/#pydantic-integration","title":"Pydantic Integration","text":"<p>Use Pydantic for complex data validation: </p><pre><code>from pydantic import BaseModel, Field\n\nclass TaskInput(BaseModel):\n    title: str = Field(..., min_length=1, max_length=100)\n    priority: int = Field(default=1, ge=1, le=5)\n    tags: list[str] = Field(default_factory=list)\n\n@mcp.tool()\ndef create_task(task: TaskInput) -&gt; str:\n    \"\"\"Create a task with validation\"\"\"\n    return f\"Created: {task.title}\"\n</code></pre><p></p>"},{"location":"develop/python/#development-setup","title":"Development Setup","text":""},{"location":"develop/python/#virtual-environment","title":"Virtual Environment","text":"<pre><code># Create venv\npython -m venv .venv\nsource .venv/bin/activate  # Linux/macOS\n# .venv\\Scripts\\activate   # Windows\n\n# Install dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"develop/python/#project-structure","title":"Project Structure","text":"<pre><code>my-python-server/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_server/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 main.py\n\u2502       \u251c\u2500\u2500 tools.py\n\u2502       \u2514\u2500\u2500 resources.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_tools.py\n\u2502   \u2514\u2500\u2500 test_integration.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"develop/python/#testing","title":"Testing","text":""},{"location":"develop/python/#unit-tests-with-pytest","title":"Unit Tests with pytest","text":"<pre><code># tests/test_tools.py\nimport pytest\nfrom my_server.tools import process_data\n\ndef test_process_data():\n    result = process_data(\"test input\")\n    assert result == \"expected output\"\n\n@pytest.mark.asyncio\nasync def test_async_tool():\n    result = await fetch_data(\"http://example.com\")\n    assert result is not None\n</code></pre>"},{"location":"develop/python/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# With coverage\npytest --cov=my_server --cov-report=html\n\n# Specific test file\npytest tests/test_tools.py\n</code></pre>"},{"location":"develop/python/#dependency-management","title":"Dependency Management","text":""},{"location":"develop/python/#using-pyprojecttoml","title":"Using pyproject.toml","text":"<pre><code>[project]\nname = \"my-mcp-server\"\nversion = \"0.1.0\"\ndependencies = [\n    \"mcp[cli]&gt;=0.1.0\",\n    \"pydantic&gt;=2.0\",\n    \"aiohttp&gt;=3.9\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0\",\n    \"pytest-asyncio&gt;=0.21\",\n    \"pytest-cov&gt;=4.0\",\n    \"ruff&gt;=0.1\",\n]\n</code></pre>"},{"location":"develop/python/#best-practices","title":"Best Practices","text":""},{"location":"develop/python/#1-use-type-hints","title":"1. Use Type Hints","text":"<p>Always provide type hints for better IDE support and automatic validation.</p>"},{"location":"develop/python/#2-implement-logging","title":"2. Implement Logging","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\n@mcp.tool()\ndef my_tool(input: str) -&gt; str:\n    logger.info(f\"Processing: {input}\")\n    try:\n        result = process(input)\n        logger.debug(f\"Result: {result}\")\n        return result\n    except Exception as e:\n        logger.error(f\"Error: {e}\")\n        raise\n</code></pre>"},{"location":"develop/python/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>from mcp.server.exceptions import McpError\n\n@mcp.tool()\ndef safe_tool(data: str) -&gt; str:\n    if not data:\n        raise McpError(\"Data cannot be empty\")\n    \n    try:\n        return process(data)\n    except ProcessingError as e:\n        logger.error(f\"Processing failed: {e}\")\n        raise McpError(\"Failed to process data\")\n</code></pre>"},{"location":"develop/python/#4-use-environment-variables","title":"4. Use Environment Variables","text":"<pre><code>import os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nAPI_KEY = os.getenv(\"MCP_API_KEY\")\nif not API_KEY:\n    raise ValueError(\"MCP_API_KEY not set\")\n</code></pre>"},{"location":"develop/python/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use async for I/O: Network requests, file operations</li> <li>Cache expensive operations: Use <code>functools.lru_cache</code></li> <li>Connection pooling: Reuse database/HTTP connections</li> <li>Batch operations: Process multiple items together</li> <li>Profile your code: Use <code>cProfile</code> for bottlenecks</li> </ol>"},{"location":"develop/python/#common-patterns","title":"Common Patterns","text":""},{"location":"develop/python/#singleton-pattern-for-clients","title":"Singleton Pattern for Clients","text":"<pre><code>class DatabaseClient:\n    _instance = None\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance.initialize()\n        return cls._instance\n</code></pre>"},{"location":"develop/python/#context-manager-for-resources","title":"Context Manager for Resources","text":"<pre><code>from contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def get_connection():\n    conn = await create_connection()\n    try:\n        yield conn\n    finally:\n        await conn.close()\n</code></pre>"},{"location":"develop/python/#next-steps","title":"Next Steps","text":"<ul> <li>\u26a1 FastMCP Framework</li> <li>\ud83c\udfd7\ufe0f Project Structure</li> <li>\ud83e\uddea Testing Guide</li> <li>\ud83d\udce6 Packaging</li> <li>\ud83c\udfaf Best Practices</li> </ul>"},{"location":"develop/python/best-practices/","title":"Best Practices","text":""},{"location":"develop/python/best-practices/#python-best-practices","title":"Python Best Practices","text":""},{"location":"develop/python/best-practices/#python-specific-best-practices-for-mcp-servers","title":"Python-Specific Best Practices for MCP Servers","text":"<p>Following Python best practices ensures your MCP server is maintainable, performant, and follows community standards.</p>"},{"location":"develop/python/best-practices/#code-style-and-formatting","title":"Code Style and Formatting","text":""},{"location":"develop/python/best-practices/#use-black-and-ruff","title":"Use Black and Ruff","text":"<pre><code># Install formatting tools\nuv add --dev black ruff\n\n# Format code\nblack src tests\n\n# Lint and fix issues\nruff check --fix src tests\n</code></pre>"},{"location":"develop/python/best-practices/#configuration","title":"Configuration","text":"<pre><code># pyproject.toml\n[tool.black]\nline-length = 88\ntarget-version = ['py311']\ninclude = '\\.pyi?$'\nextend-exclude = '''\n/(\n  \\.eggs\n  | \\.git\n  | \\.venv\n  | build\n  | dist\n)/\n'''\n\n[tool.ruff]\ntarget-version = \"py311\"\nline-length = 88\nselect = [\n    \"E\",  # pycodestyle errors\n    \"W\",  # pycodestyle warnings\n    \"F\",  # pyflakes\n    \"I\",  # isort\n    \"B\",  # flake8-bugbear\n    \"C4\", # flake8-comprehensions\n    \"UP\", # pyupgrade\n]\nignore = [\n    \"E501\",  # line too long (handled by black)\n    \"B008\",  # do not perform function calls in argument defaults\n]\n\n[tool.ruff.per-file-ignores]\n\"__init__.py\" = [\"F401\"]\n\"tests/**/*.py\" = [\"S101\"]  # assert allowed in tests\n</code></pre>"},{"location":"develop/python/best-practices/#type-hints-and-mypy","title":"Type Hints and MyPy","text":""},{"location":"develop/python/best-practices/#comprehensive-type-hints","title":"Comprehensive Type Hints","text":"<pre><code>from typing import Any, Dict, List, Optional, Union\nfrom mcp.types import Tool, TextContent\nimport asyncio\n\nclass DatabaseTool:\n    def __init__(self, connection_string: str) -&gt; None:\n        self.connection_string = connection_string\n        self._connection: Optional[Any] = None\n    \n    async def execute_query(\n        self, \n        query: str, \n        params: Optional[Dict[str, Any]] = None\n    ) -&gt; List[TextContent]:\n        \"\"\"Execute database query with type safety.\"\"\"\n        results = await self._execute(query, params or {})\n        return [TextContent(type=\"text\", text=str(result)) for result in results]\n    \n    async def _execute(\n        self, \n        query: str, \n        params: Dict[str, Any]\n    ) -&gt; List[Dict[str, Any]]:\n        # Implementation details\n        return []\n</code></pre>"},{"location":"develop/python/best-practices/#mypy-configuration","title":"MyPy Configuration","text":"<pre><code># pyproject.toml\n[tool.mypy]\npython_version = \"3.11\"\nstrict = true\nwarn_return_any = true\nwarn_unused_configs = true\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_no_return = true\nwarn_unreachable = true\nshow_error_codes = true\n\n[[tool.mypy.overrides]]\nmodule = \"tests.*\"\nignore_errors = true\n</code></pre>"},{"location":"develop/python/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"develop/python/best-practices/#custom-exception-hierarchy","title":"Custom Exception Hierarchy","text":"<pre><code># src/my_mcp_server/exceptions.py\nclass MCPServerError(Exception):\n    \"\"\"Base exception for MCP server errors.\"\"\"\n    pass\n\nclass ValidationError(MCPServerError):\n    \"\"\"Raised when input validation fails.\"\"\"\n    def __init__(self, message: str, field: Optional[str] = None):\n        super().__init__(message)\n        self.field = field\n\nclass ExternalServiceError(MCPServerError):\n    \"\"\"Raised when external service calls fail.\"\"\"\n    def __init__(self, message: str, service: str, status_code: Optional[int] = None):\n        super().__init__(message)\n        self.service = service\n        self.status_code = status_code\n\nclass ConfigurationError(MCPServerError):\n    \"\"\"Raised when configuration is invalid.\"\"\"\n    pass\n</code></pre>"},{"location":"develop/python/best-practices/#error-handling-patterns","title":"Error Handling Patterns","text":"<pre><code>import logging\nfrom typing import NoReturn\n\nlogger = logging.getLogger(__name__)\n\nasync def safe_tool_execution(\n    tool_name: str, \n    arguments: Dict[str, Any]\n) -&gt; List[TextContent]:\n    \"\"\"Execute tool with comprehensive error handling.\"\"\"\n    try:\n        # Validate inputs first\n        validated_args = validate_tool_arguments(tool_name, arguments)\n        \n        # Execute with timeout\n        result = await asyncio.wait_for(\n            execute_tool_impl(tool_name, validated_args),\n            timeout=30.0\n        )\n        \n        return result\n        \n    except ValidationError as e:\n        logger.warning(f\"Validation failed for {tool_name}: {e}\")\n        raise  # Re-raise for proper MCP error response\n        \n    except ExternalServiceError as e:\n        logger.error(f\"External service error in {tool_name}: {e}\")\n        # Convert to user-friendly message\n        raise MCPServerError(f\"Service temporarily unavailable: {e.service}\")\n        \n    except asyncio.TimeoutError:\n        logger.error(f\"Timeout executing {tool_name}\")\n        raise MCPServerError(\"Operation timed out\")\n        \n    except Exception as e:\n        logger.exception(f\"Unexpected error in {tool_name}\")\n        raise MCPServerError(\"Internal server error\")\n\ndef validate_tool_arguments(tool_name: str, arguments: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Validate and sanitize tool arguments.\"\"\"\n    if not isinstance(arguments, dict):\n        raise ValidationError(\"Arguments must be a dictionary\")\n    \n    # Tool-specific validation\n    validators = {\n        \"database_query\": validate_database_query,\n        \"file_operation\": validate_file_operation,\n    }\n    \n    validator = validators.get(tool_name)\n    if validator:\n        return validator(arguments)\n    \n    return arguments\n</code></pre>"},{"location":"develop/python/best-practices/#async-programming","title":"Async Programming","text":""},{"location":"develop/python/best-practices/#proper-async-patterns","title":"Proper Async Patterns","text":"<pre><code>import asyncio\nimport aiohttp\nimport aiofiles\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\nclass AsyncResourceManager:\n    \"\"\"Manage async resources properly.\"\"\"\n    \n    def __init__(self):\n        self._session: Optional[aiohttp.ClientSession] = None\n        self._db_pool: Optional[Any] = None\n    \n    async def __aenter__(self):\n        await self.initialize()\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.cleanup()\n    \n    async def initialize(self):\n        \"\"\"Initialize async resources.\"\"\"\n        self._session = aiohttp.ClientSession(\n            timeout=aiohttp.ClientTimeout(total=30)\n        )\n        # Initialize database pool\n        \n    async def cleanup(self):\n        \"\"\"Clean up async resources.\"\"\"\n        if self._session:\n            await self._session.close()\n        # Clean up database pool\n\n@asynccontextmanager\nasync def get_file_content(file_path: str) -&gt; AsyncGenerator[str, None]:\n    \"\"\"Async context manager for file operations.\"\"\"\n    async with aiofiles.open(file_path, 'r') as f:\n        content = await f.read()\n        yield content\n\n# Concurrent operations\nasync def process_multiple_requests(requests: List[Dict[str, Any]]) -&gt; List[Any]:\n    \"\"\"Process multiple requests concurrently.\"\"\"\n    semaphore = asyncio.Semaphore(10)  # Limit concurrent operations\n    \n    async def process_single(request: Dict[str, Any]) -&gt; Any:\n        async with semaphore:\n            return await process_request(request)\n    \n    # Use gather for concurrent execution\n    results = await asyncio.gather(\n        *[process_single(req) for req in requests],\n        return_exceptions=True  # Handle exceptions gracefully\n    )\n    \n    return results\n</code></pre>"},{"location":"develop/python/best-practices/#configuration-management","title":"Configuration Management","text":""},{"location":"develop/python/best-practices/#pydantic-settings","title":"Pydantic Settings","text":"<pre><code># src/my_mcp_server/config.py\nfrom pydantic import BaseSettings, Field, validator\nfrom typing import Optional, List\nimport os\n\nclass Settings(BaseSettings):\n    \"\"\"Application settings with validation.\"\"\"\n    \n    # Server settings\n    server_name: str = Field(default=\"my-mcp-server\", description=\"Server name\")\n    debug: bool = Field(default=False, description=\"Debug mode\")\n    log_level: str = Field(default=\"INFO\", description=\"Log level\")\n    \n    # Database settings\n    database_url: Optional[str] = Field(None, description=\"Database connection URL\")\n    database_pool_size: int = Field(default=10, ge=1, le=50)\n    database_timeout: int = Field(default=30, ge=1, le=300)\n    \n    # API settings\n    api_key: Optional[str] = Field(None, description=\"External API key\")\n    api_base_url: str = Field(default=\"https://api.example.com\")\n    api_timeout: int = Field(default=30, ge=1, le=300)\n    \n    # Feature flags\n    enable_caching: bool = Field(default=True)\n    enable_metrics: bool = Field(default=False)\n    allowed_operations: List[str] = Field(default_factory=lambda: [\"read\", \"write\"])\n    \n    @validator('log_level')\n    def validate_log_level(cls, v):\n        valid_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']\n        if v.upper() not in valid_levels:\n            raise ValueError(f'Invalid log level. Must be one of: {valid_levels}')\n        return v.upper()\n    \n    @validator('database_url')\n    def validate_database_url(cls, v):\n        if v and not v.startswith(('postgresql://', 'sqlite:///', 'mysql://')):\n            raise ValueError('Invalid database URL scheme')\n        return v\n    \n    class Config:\n        env_prefix = 'MCP_'\n        env_file = '.env'\n        case_sensitive = False\n\n# Global settings instance\nsettings = Settings()\n</code></pre>"},{"location":"develop/python/best-practices/#logging","title":"Logging","text":""},{"location":"develop/python/best-practices/#structured-logging","title":"Structured Logging","text":"<pre><code># src/my_mcp_server/logging_config.py\nimport logging\nimport sys\nfrom typing import Any, Dict\nimport json\nfrom datetime import datetime\n\nclass StructuredFormatter(logging.Formatter):\n    \"\"\"JSON formatter for structured logging.\"\"\"\n    \n    def format(self, record: logging.LogRecord) -&gt; str:\n        log_data: Dict[str, Any] = {\n            'timestamp': datetime.utcnow().isoformat() + 'Z',\n            'level': record.levelname,\n            'logger': record.name,\n            'message': record.getMessage(),\n            'module': record.module,\n            'function': record.funcName,\n            'line': record.lineno,\n        }\n        \n        # Add exception info if present\n        if record.exc_info:\n            log_data['exception'] = self.formatException(record.exc_info)\n        \n        # Add extra fields\n        if hasattr(record, 'extra_fields'):\n            log_data.update(record.extra_fields)\n        \n        return json.dumps(log_data, separators=(',', ':'))\n\ndef setup_logging(level: str = 'INFO') -&gt; None:\n    \"\"\"Configure application logging.\"\"\"\n    root_logger = logging.getLogger()\n    root_logger.setLevel(level)\n    \n    # Remove existing handlers\n    for handler in root_logger.handlers[:]:\n        root_logger.removeHandler(handler)\n    \n    # Console handler with structured format\n    handler = logging.StreamHandler(sys.stderr)\n    handler.setFormatter(StructuredFormatter())\n    root_logger.addHandler(handler)\n    \n    # Suppress noisy third-party loggers\n    logging.getLogger('aiohttp').setLevel(logging.WARNING)\n    logging.getLogger('asyncio').setLevel(logging.WARNING)\n\n# Usage\nlogger = logging.getLogger(__name__)\n\nasync def example_with_logging():\n    \"\"\"Example function with structured logging.\"\"\"\n    logger.info(\n        \"Processing request\", \n        extra={'extra_fields': {\n            'tool_name': 'database_query',\n            'user_id': 'user123',\n            'request_id': 'req-456'\n        }}\n    )\n</code></pre>"},{"location":"develop/python/best-practices/#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"develop/python/best-practices/#fixtures-and-test-organization","title":"Fixtures and Test Organization","text":"<pre><code># tests/conftest.py\nimport pytest\nimport asyncio\nfrom unittest.mock import AsyncMock\nfrom my_mcp_server.config import Settings\nfrom my_mcp_server.server import MCPServer\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create event loop for async tests.\"\"\"\n    loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\ndef test_settings():\n    \"\"\"Test configuration settings.\"\"\"\n    return Settings(\n        server_name=\"test-server\",\n        debug=True,\n        database_url=\"sqlite:///:memory:\",\n        api_key=\"test-key\"\n    )\n\n@pytest.fixture\nasync def mock_external_service():\n    \"\"\"Mock external service dependencies.\"\"\"\n    mock = AsyncMock()\n    mock.get_data.return_value = {\"test\": \"data\"}\n    return mock\n\n@pytest.fixture\nasync def test_server(test_settings, mock_external_service):\n    \"\"\"Create test server instance.\"\"\"\n    server = MCPServer(test_settings.server_name)\n    # Inject mocked dependencies\n    server._external_service = mock_external_service\n    return server\n</code></pre>"},{"location":"develop/python/best-practices/#test-categories","title":"Test Categories","text":"<pre><code># tests/test_tools.py\nimport pytest\nfrom my_mcp_server.tools import DatabaseTool\n\nclass TestDatabaseTool:\n    \"\"\"Test database tool functionality.\"\"\"\n    \n    @pytest.mark.asyncio\n    async def test_valid_query(self, test_server):\n        \"\"\"Test successful query execution.\"\"\"\n        result = await test_server.execute_query(\"SELECT 1\")\n        assert len(result) &gt; 0\n    \n    @pytest.mark.asyncio\n    async def test_invalid_query_raises_error(self, test_server):\n        \"\"\"Test error handling for invalid queries.\"\"\"\n        with pytest.raises(ValidationError):\n            await test_server.execute_query(\"INVALID SQL\")\n    \n    @pytest.mark.parametrize(\"query,expected_error\", [\n        (\"\", \"Query cannot be empty\"),\n        (\"DROP TABLE users\", \"DROP statements not allowed\"),\n        (\"SELECT * FROM users; DELETE FROM users\", \"Multiple statements not allowed\"),\n    ])\n    @pytest.mark.asyncio\n    async def test_query_validation(self, test_server, query, expected_error):\n        \"\"\"Test various query validation scenarios.\"\"\"\n        with pytest.raises(ValidationError, match=expected_error):\n            await test_server.execute_query(query)\n</code></pre>"},{"location":"develop/python/best-practices/#performance-optimization","title":"Performance Optimization","text":""},{"location":"develop/python/best-practices/#caching","title":"Caching","text":"<pre><code>from functools import lru_cache\nfrom typing import Dict, Any\nimport asyncio\nimport time\n\n# Simple in-memory cache\nclass TTLCache:\n    \"\"\"Time-to-live cache implementation.\"\"\"\n    \n    def __init__(self, ttl: int = 300):\n        self.ttl = ttl\n        self._cache: Dict[str, tuple] = {}\n    \n    def get(self, key: str) -&gt; Any:\n        if key in self._cache:\n            value, timestamp = self._cache[key]\n            if time.time() - timestamp &lt; self.ttl:\n                return value\n            else:\n                del self._cache[key]\n        return None\n    \n    def set(self, key: str, value: Any) -&gt; None:\n        self._cache[key] = (value, time.time())\n    \n    def clear(self) -&gt; None:\n        self._cache.clear()\n\n# Usage with async functions\ncache = TTLCache(ttl=300)  # 5 minutes\n\nasync def cached_api_call(endpoint: str) -&gt; Dict[str, Any]:\n    \"\"\"API call with caching.\"\"\"\n    cached_result = cache.get(endpoint)\n    if cached_result is not None:\n        return cached_result\n    \n    result = await make_api_call(endpoint)\n    cache.set(endpoint, result)\n    return result\n</code></pre>"},{"location":"develop/python/best-practices/#connection-pooling","title":"Connection Pooling","text":"<pre><code>import aiohttp\nfrom contextlib import asynccontextmanager\n\nclass ConnectionManager:\n    \"\"\"Manage HTTP connection pools.\"\"\"\n    \n    def __init__(self):\n        self._session: Optional[aiohttp.ClientSession] = None\n    \n    async def get_session(self) -&gt; aiohttp.ClientSession:\n        if self._session is None or self._session.closed:\n            connector = aiohttp.TCPConnector(\n                limit=100,  # Total connection pool size\n                limit_per_host=30,  # Per-host connection limit\n                keepalive_timeout=30,\n                enable_cleanup_closed=True\n            )\n            \n            timeout = aiohttp.ClientTimeout(\n                total=30,\n                connect=5,\n                sock_read=10\n            )\n            \n            self._session = aiohttp.ClientSession(\n                connector=connector,\n                timeout=timeout\n            )\n        \n        return self._session\n    \n    async def close(self):\n        if self._session and not self._session.closed:\n            await self._session.close()\n\n# Global connection manager\nconnection_manager = ConnectionManager()\n</code></pre>"},{"location":"develop/python/best-practices/#security-best-practices","title":"Security Best Practices","text":""},{"location":"develop/python/best-practices/#input-sanitization","title":"Input Sanitization","text":"<pre><code>import re\nfrom pathlib import Path\nfrom typing import Any\n\ndef sanitize_file_path(file_path: str, allowed_dirs: List[str]) -&gt; Path:\n    \"\"\"Sanitize file path to prevent directory traversal.\"\"\"\n    # Remove any path traversal attempts\n    clean_path = re.sub(r'\\.\\./+', '', file_path)\n    \n    # Convert to absolute path\n    abs_path = Path(clean_path).resolve()\n    \n    # Check if path is within allowed directories\n    for allowed_dir in allowed_dirs:\n        allowed_path = Path(allowed_dir).resolve()\n        try:\n            abs_path.relative_to(allowed_path)\n            return abs_path\n        except ValueError:\n            continue\n    \n    raise ValidationError(f\"File path not allowed: {file_path}\")\n\ndef sanitize_sql_identifier(identifier: str) -&gt; str:\n    \"\"\"Sanitize SQL identifier to prevent injection.\"\"\"\n    if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', identifier):\n        raise ValidationError(f\"Invalid SQL identifier: {identifier}\")\n    return identifier\n</code></pre>"},{"location":"develop/python/best-practices/#environment-variable-handling","title":"Environment Variable Handling","text":"<pre><code># Never log sensitive data\ndef safe_log_config(config: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Log configuration with sensitive data masked.\"\"\"\n    sensitive_keys = {'password', 'token', 'key', 'secret'}\n    safe_config = {}\n    \n    for key, value in config.items():\n        if any(sensitive in key.lower() for sensitive in sensitive_keys):\n            safe_config[key] = \"***MASKED***\"\n        else:\n            safe_config[key] = value\n    \n    return safe_config\n</code></pre> <p>Following these Python-specific best practices will help you create robust, maintainable, and secure MCP servers that integrate well with the Python ecosystem.</p>"},{"location":"develop/python/developing-your-mcp-server-python/","title":"Write an MCP Server in Python","text":""},{"location":"develop/python/developing-your-mcp-server-python/#developing-your-mcp-server","title":"Developing Your MCP Server","text":"Abstract <p>This guide walks you through creating a minimal but functional MCP server using Python and the official MCP SDK. You'll build an echo server that demonstrates the key concepts and patterns for MCP development.</p> <p>For more information on Development best practices see this MCP Server Best Practices Guide</p>"},{"location":"develop/python/developing-your-mcp-server-python/#1-prerequisites","title":"1. Prerequisites","text":"<p>Environment setup</p> <p>Create a new virtual environment for your project to keep dependencies isolated.</p> Create virtual environment<pre><code># Create and manage virtual environments\nuv venv mcp-server-example\nsource mcp-server-example/bin/activate  # Linux/macOS\n# mcp-server-example\\Scripts\\activate   # Windows\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#11-install-mcp-sdk","title":"1.1 Install MCP SDK","text":"Install MCP SDK<pre><code>uv add \"mcp[cli]\"\n# or with pip: pip install \"mcp[cli]\"\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#12-verify-installation","title":"1.2 Verify Installation","text":"Verify MCP installation<pre><code>python -c \"import mcp; print('MCP SDK installed successfully')\"\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#2-write-a-minimal-echo-server","title":"2. Write a Minimal Echo Server","text":""},{"location":"develop/python/developing-your-mcp-server-python/#21-basic-server-structure","title":"2.1 Basic Server Structure","text":"<p>Simple echo server implementation</p> <p>Create <code>my_echo_server.py</code> with this minimal implementation:</p> my_echo_server.py<pre><code>from mcp.server.fastmcp import FastMCP\n\n# Create an MCP server\nmcp = FastMCP(\"my_echo_server\", port=\"8000\")\n\n@mcp.tool()\ndef echo(text: str) -&gt; str:\n    \"\"\"Echo the provided text back to the caller\"\"\"\n    return text\n\nif __name__ == \"__main__\":\n    mcp.run()  # STDIO mode by default\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#22-understanding-the-code","title":"2.2 Understanding the Code","text":"<p>Code breakdown</p> <ul> <li>FastMCP: Main application class that handles MCP protocol</li> <li>@mcp.tool(): Decorator that registers the function as an MCP tool</li> <li>Type hints: Python type hints define input/output schemas automatically</li> <li>mcp.run(): Starts the server (defaults to STDIO transport)</li> </ul>"},{"location":"develop/python/developing-your-mcp-server-python/#23-test-stdio-mode","title":"2.3 Test STDIO Mode","text":"Start server in STDIO mode<pre><code>python my_echo_server.py            # waits on stdin/stdout\n</code></pre> <p>Testing with MCP CLI</p> <p>Use the built-in development tools for easier testing:</p> Test with MCP Inspector<pre><code># Test with the MCP development tools\nuv run mcp dev my_echo_server.py\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#3-switch-to-http-transport","title":"3. Switch to HTTP Transport","text":""},{"location":"develop/python/developing-your-mcp-server-python/#31-enable-http-mode","title":"3.1 Enable HTTP Mode","text":"<p>Streamable HTTP transport</p> <p>Update the main block to use HTTP transport for network accessibility:</p> Enable HTTP transport<pre><code>if __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#32-start-http-server","title":"3.2 Start HTTP Server","text":"Run HTTP server<pre><code>python my_echo_server.py            # now at http://localhost:8000/mcp\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#33-test-http-endpoint","title":"3.3 Test HTTP Endpoint","text":"<p>Direct HTTP testing</p> <p>Test the server directly with curl:</p> Test HTTP endpoint<pre><code>curl -X POST http://localhost:8000/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}'\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#4-register-with-the-gateway","title":"4. Register with the Gateway","text":""},{"location":"develop/python/developing-your-mcp-server-python/#41-server-registration","title":"4.1 Server Registration","text":"<p>Register your server with the gateway</p> <p>Use the gateway API to register your running server:</p> Register server with gateway<pre><code>curl -X POST http://127.0.0.1:4444/gateways \\\n  -H \"Authorization: Bearer $MCPGATEWAY_BEARER_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"my_echo_server\",\"url\":\"http://127.0.0.1:8000/mcp\",\"transport\":\"streamablehttp\"}'\n</code></pre> <p>For instructions on registering your server via the UI, please see Register with the Gateway UI.</p>"},{"location":"develop/python/developing-your-mcp-server-python/#42-verify-registration","title":"4.2 Verify Registration","text":"Check registered gateways<pre><code>curl -H \"Authorization: Bearer $MCPGATEWAY_BEARER_TOKEN\" \\\n     http://127.0.0.1:4444/gateways\n</code></pre> <p>Expected response</p> <p>You should see your server listed as active:</p> Server registration response<pre><code>{\n  \"servers\": [\n    {\n      \"name\": \"my_echo_server\",\n      \"url\": \"http://127.0.0.1:8000/mcp\",\n      \"status\": \"active\"\n    }\n  ]\n}\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#5-end-to-end-validation","title":"5. End-to-End Validation","text":""},{"location":"develop/python/developing-your-mcp-server-python/#51-test-with-mcp-cli","title":"5.1 Test with mcp-cli","text":"<p>Test complete workflow</p> <p>Verify the full chain from CLI to gateway to your server:</p> List and call tools<pre><code># List tools to see your echo tool\nmcp-cli tools --server gateway\n\n# Call the echo tool\nmcp-cli cmd --server gateway \\\n  --tool echo \\\n  --tool-args '{\"text\":\"Round-trip success!\"}'\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#52-test-with-curl","title":"5.2 Test with curl","text":"<p>Direct gateway testing</p> <p>Test the gateway RPC endpoint directly:</p> Test via gateway RPC<pre><code>curl -X POST http://127.0.0.1:4444/rpc \\\n  -H \"Authorization: Bearer $MCPGATEWAY_BEARER_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"my-echo-server-echo\",\"params\":{\"text\":\"Hello!\"},\"id\":1}'\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#53-expected-response","title":"5.3 Expected Response","text":"<p>Validation complete</p> <p>If you see this response, the full path (CLI \u2192 Gateway \u2192 Echo Server) is working correctly:</p> Successful echo response<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Hello!\"\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#6-enhanced-server-features","title":"6. Enhanced Server Features","text":""},{"location":"develop/python/developing-your-mcp-server-python/#61-multiple-tools","title":"6.1 Multiple Tools","text":"<p>Multi-tool server</p> <p>Extend your server with additional functionality:</p> Enhanced server with multiple tools<pre><code>from mcp.server.fastmcp import FastMCP\nimport datetime\n\n# Create an MCP server\nmcp = FastMCP(\"my_enhanced_server\", port=\"8000\")\n\n@mcp.tool()\ndef echo(text: str) -&gt; str:\n    \"\"\"Echo the provided text back to the caller\"\"\"\n    return text\n\n@mcp.tool()\ndef get_timestamp() -&gt; str:\n    \"\"\"Get the current timestamp\"\"\"\n    return datetime.datetime.now().isoformat()\n\n@mcp.tool()\ndef calculate(a: float, b: float, operation: str) -&gt; float:\n    \"\"\"Perform basic math operations: add, subtract, multiply, divide\"\"\"\n    operations = {\n        \"add\": a + b,\n        \"subtract\": a - b,\n        \"multiply\": a * b,\n        \"divide\": a / b if b != 0 else float('inf')\n    }\n\n    if operation not in operations:\n        raise ValueError(f\"Unknown operation: {operation}\")\n\n    return operations[operation]\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre> <p>Update the MCP Server in the Gateway</p> <p>Delete the current Server and register the new Server:</p> Register server with gateway<pre><code>curl -X POST http://127.0.0.1:4444/gateways \\\n  -H \"Authorization: Bearer $MCPGATEWAY_BEARER_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"my_echo_server\",\"url\":\"http://127.0.0.1:8000/mcp\",\"transport\":\"streamablehttp\"}'\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#62-structured-output-with-pydantic","title":"6.2 Structured Output with Pydantic","text":"<p>Rich data structures</p> <p>Use Pydantic models for complex structured responses:</p> Structured output server<pre><code>from mcp.server.fastmcp import FastMCP\nfrom pydantic import BaseModel, Field\nimport datetime\n\nmcp = FastMCP(\"structured_server\", port=\"8000\")\n\nclass EchoResponse(BaseModel):\n    \"\"\"Response structure for echo tool\"\"\"\n    original_text: str = Field(description=\"The original input text\")\n    echo_text: str = Field(description=\"The echoed text\")\n    length: int = Field(description=\"Length of the text\")\n    timestamp: str = Field(description=\"When the echo was processed\")\n\n@mcp.tool()\ndef structured_echo(text: str) -&gt; EchoResponse:\n    \"\"\"Echo with structured response data\"\"\"\n    return EchoResponse(\n        original_text=text,\n        echo_text=text,\n        length=len(text),\n        timestamp=datetime.datetime.now().isoformat()\n    )\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#63-error-handling-and-validation","title":"6.3 Error Handling and Validation","text":"<p>Production considerations</p> <p>Add proper error handling and validation for production use:</p> Robust error handling<pre><code>from mcp.server.fastmcp import FastMCP\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nmcp = FastMCP(\"robust_server\", port=\"8000\")\n\n@mcp.tool()\ndef safe_echo(text: str) -&gt; str:\n    \"\"\"Echo with validation and error handling\"\"\"\n    try:\n        # Log the request\n        logger.info(f\"Processing echo request for text of length {len(text)}\")\n\n        # Validate input\n        if not text.strip():\n            raise ValueError(\"Text cannot be empty\")\n\n        if len(text) &gt; 1000:\n            raise ValueError(\"Text too long (max 1000 characters)\")\n\n        # Process and return\n        return text\n\n    except Exception as e:\n        logger.error(f\"Error in safe_echo: {e}\")\n        raise\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#7-testing-your-server","title":"7. Testing Your Server","text":""},{"location":"develop/python/developing-your-mcp-server-python/#71-development-testing","title":"7.1 Development Testing","text":"<p>Interactive development</p> <p>Use the MCP Inspector for rapid testing and debugging:</p> Development testing with MCP Inspector<pre><code># Use the built-in development tools\nuv run mcp dev my_echo_server.py\n\n# Test with dependencies\nuv run mcp dev my_echo_server.py --with pandas --with numpy\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#72-unit-testing","title":"7.2 Unit Testing","text":"<p>Testing considerations</p> <p>For unit testing, focus on business logic rather than MCP protocol:</p> test_echo_server.py<pre><code>import pytest\nfrom my_echo_server import mcp\n\n@pytest.mark.asyncio\nasync def test_echo_tool():\n    \"\"\"Test the echo tool directly\"\"\"\n    # This would require setting up the MCP server context\n    # For integration testing, use the MCP Inspector instead\n    pass\n\ndef test_basic_functionality():\n    \"\"\"Test basic server setup\"\"\"\n    assert mcp.name == \"my_echo_server\"\n    # Add more server validation tests\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#73-integration-testing","title":"7.3 Integration Testing","text":"<p>End-to-end testing</p> <p>Test the complete workflow with a simple script:</p> Integration test script<pre><code>#!/bin/bash\n\n# Start server in background\npython my_echo_server.py &amp;\nSERVER_PID=$!\n\n# Wait for server to start\nsleep 2\n\n# Test server registration\necho \"Testing server registration...\"\ncurl -X POST http://127.0.0.1:4444/servers \\\n  -H \"Authorization: Bearer $MCPGATEWAY_BEARER_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"test_echo_server\",\"url\":\"http://127.0.0.1:8000/mcp\"}'\n\n# Test tool call\necho \"Testing tool call...\"\nmcp-cli cmd --server gateway \\\n  --tool echo \\\n  --tool-args '{\"text\":\"Integration test success!\"}'\n\n# Cleanup\nkill $SERVER_PID\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#8-deployment-considerations","title":"8. Deployment Considerations","text":""},{"location":"develop/python/developing-your-mcp-server-python/#81-production-configuration","title":"8.1 Production Configuration","text":"<p>Environment-based configuration</p> <p>Use environment variables for production settings:</p> Production-ready server<pre><code>import os\nfrom mcp.server.fastmcp import FastMCP\n\n# Configuration from environment\nSERVER_NAME = os.getenv(\"MCP_SERVER_NAME\", \"my_echo_server\")\nPORT = os.getenv(\"MCP_SERVER_PORT\", \"8000\")\nDEBUG_MODE = os.getenv(\"MCP_DEBUG\", \"false\").lower() == \"true\"\n\nmcp = FastMCP(SERVER_NAME, port=PORT)\n\n@mcp.tool()\ndef echo(text: str) -&gt; str:\n    \"\"\"Echo the provided text\"\"\"\n    if DEBUG_MODE:\n        print(f\"Debug: Processing text of length {len(text)}\")\n    return text\n\nif __name__ == \"__main__\":\n    transport = os.getenv(\"MCP_TRANSPORT\", \"streamable-http\")\n    print(f\"Starting {SERVER_NAME} with {transport} transport\")\n    mcp.run(transport=transport)\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#82-container-podmandocker-support","title":"8.2 Container (Podman/Docker) Support","text":"<p>Containerization</p> <p>Package your server for easy deployment by creating a Containerfile:</p> Dockerfile<pre><code>FROM python:3.11-slim\n\nWORKDIR /app\n\n# Install uv\nRUN pip install uv\n\n# Copy requirements\nCOPY pyproject.toml .\nRUN uv pip install --system -e .\n\nCOPY my_echo_server.py .\n\nEXPOSE 8000\n\nCMD [\"python\", \"my_echo_server.py\"]\n</code></pre> pyproject.toml<pre><code>[project]\nname = \"my-echo-server\"\nversion = \"0.1.0\"\ndependencies = [\n    \"mcp[cli]\",\n]\n\n[project.scripts]\necho-server = \"my_echo_server:main\"\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#9-advanced-features","title":"9. Advanced Features","text":""},{"location":"develop/python/developing-your-mcp-server-python/#91-resources","title":"9.1 Resources","text":"<p>Exposing data via resources</p> <p>Resources provide contextual data to LLMs:</p> Server with resources<pre><code>from mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"resource_server\", port=\"8000\")\n\n@mcp.resource(\"config://settings\")\ndef get_settings() -&gt; str:\n    \"\"\"Provide server configuration as a resource\"\"\"\n    return \"\"\"{\n  \"server_name\": \"my_echo_server\",\n  \"version\": \"1.0.0\",\n  \"features\": [\"echo\", \"timestamp\"]\n}\"\"\"\n\n@mcp.resource(\"status://health\")\ndef get_health() -&gt; str:\n    \"\"\"Provide server health status\"\"\"\n    return \"Server is running normally\"\n\n@mcp.tool()\ndef echo(text: str) -&gt; str:\n    \"\"\"Echo the provided text\"\"\"\n    return text\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#92-context-and-logging","title":"9.2 Context and Logging","text":"<p>Enhanced observability</p> <p>Use context for logging and progress tracking:</p> Server with context and logging<pre><code>from mcp.server.fastmcp import FastMCP, Context\n\nmcp = FastMCP(\"context_server\", port=\"8000\")\n\n@mcp.tool()\nasync def echo_with_logging(text: str, ctx: Context) -&gt; str:\n    \"\"\"Echo with context logging\"\"\"\n    await ctx.info(f\"Processing echo request for: {text[:50]}...\")\n    await ctx.debug(f\"Full text length: {len(text)}\")\n\n    result = text\n\n    await ctx.info(\"Echo completed successfully\")\n    return result\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#10-installation-and-distribution","title":"10. Installation and Distribution","text":""},{"location":"develop/python/developing-your-mcp-server-python/#101-install-in-claude-desktop","title":"10.1 Install in Claude Desktop","text":"<p>Claude Desktop integration</p> <p>Install your server directly in Claude Desktop:</p> Claude Desktop installation<pre><code># Install your server in Claude Desktop\nuv run mcp install my_echo_server.py --name \"My Echo Server\"\n\n# With environment variables\nuv run mcp install my_echo_server.py -v DEBUG=true -v LOG_LEVEL=info\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#102-package-distribution","title":"10.2 Package Distribution","text":"<p>Creating distributable packages</p> <p>Build packages for easy distribution:</p> Package building and distribution<pre><code># Build distributable package\nuv build\n\n# Install from package\npip install dist/my_echo_server-0.1.0-py3-none-any.whl\n</code></pre>"},{"location":"develop/python/developing-your-mcp-server-python/#11-troubleshooting","title":"11. Troubleshooting","text":""},{"location":"develop/python/developing-your-mcp-server-python/#111-common-issues","title":"11.1 Common Issues","text":"<p>Import errors</p> <p></p><pre><code>ModuleNotFoundError: No module named 'mcp'\n</code></pre> Solution: Install MCP SDK: <code>uv add \"mcp[cli]\"</code><p></p> <p>Port conflicts</p> <p></p><pre><code>OSError: [Errno 48] Address already in use\n</code></pre> Solution: The default port is 8000. Change it or kill the process using the port<p></p> <p>Registration failures</p> <p></p><pre><code>Error registering server with gateway\n</code></pre> Solution: Ensure gateway is running, listening on the correct port and the server URL is correct (<code>/mcp</code> endpoint)<p></p>"},{"location":"develop/python/developing-your-mcp-server-python/#112-debugging-tips","title":"11.2 Debugging Tips","text":"<p>Debugging strategies</p> <p>Use these approaches for troubleshooting:</p> Debug your server<pre><code># Use the MCP Inspector for interactive debugging\nuv run mcp dev my_echo_server.py\n\n# Enable debug logging\nMCP_DEBUG=true python my_echo_server.py\n</code></pre>"},{"location":"develop/python/packaging/","title":"Packaging","text":""},{"location":"develop/python/packaging/#python-packaging","title":"Python Packaging","text":""},{"location":"develop/python/packaging/#packaging-mcp-servers-for-distribution","title":"Packaging MCP Servers for Distribution","text":"<p>Properly packaged MCP servers are easy to install, distribute, and maintain.</p>"},{"location":"develop/python/packaging/#package-structure","title":"Package Structure","text":""},{"location":"develop/python/packaging/#modern-python-packaging","title":"Modern Python Packaging","text":"<p>Use <code>pyproject.toml</code> for modern Python packaging:</p> <pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-mcp-server\"\nversion = \"0.1.0\"\ndescription = \"An MCP server for [specific purpose]\"\nreadme = \"README.md\"\nlicense = {text = \"MIT\"}\nauthors = [\n    {name = \"Your Name\", email = \"you@example.com\"},\n]\nmaintainers = [\n    {name = \"Your Name\", email = \"you@example.com\"},\n]\nkeywords = [\"mcp\", \"model-context-protocol\", \"ai\", \"assistant\"]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\",\n    \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n]\nrequires-python = \"&gt;=3.11\"\ndependencies = [\n    \"mcp&gt;=0.1.0\",\n    \"pydantic&gt;=2.0.0\",\n    \"aiofiles&gt;=23.0.0\",\n    \"aiohttp&gt;=3.9.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0.0\",\n    \"pytest-asyncio&gt;=0.21.0\",\n    \"pytest-cov&gt;=4.0.0\",\n    \"black&gt;=23.0.0\",\n    \"ruff&gt;=0.1.0\",\n    \"mypy&gt;=1.0.0\",\n    \"build&gt;=0.10.0\",\n]\ntest = [\n    \"pytest&gt;=7.0.0\",\n    \"pytest-asyncio&gt;=0.21.0\",\n    \"pytest-cov&gt;=4.0.0\",\n]\nlint = [\n    \"black&gt;=23.0.0\",\n    \"ruff&gt;=0.1.0\",\n    \"mypy&gt;=1.0.0\",\n]\n\n[project.urls]\n\"Homepage\" = \"https://github.com/yourusername/my-mcp-server\"\n\"Bug Reports\" = \"https://github.com/yourusername/my-mcp-server/issues\"\n\"Source\" = \"https://github.com/yourusername/my-mcp-server\"\n\"Documentation\" = \"https://my-mcp-server.readthedocs.io/\"\n\n[project.scripts]\nmy-mcp-server = \"my_mcp_server.server:main\"\n\n[project.entry-points.\"mcp.servers\"]\nmy-server = \"my_mcp_server.server:create_server\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n[tool.setuptools.package-data]\n\"my_mcp_server\" = [\"py.typed\", \"*.json\", \"*.yaml\"]\n</code></pre>"},{"location":"develop/python/packaging/#entry-points","title":"Entry Points","text":""},{"location":"develop/python/packaging/#script-entry-points","title":"Script Entry Points","text":"<pre><code># src/my_mcp_server/server.py\ndef main():\n    \"\"\"Main entry point for the CLI command.\"\"\"\n    import asyncio\n    from .server import MCPServer\n    \n    server = MCPServer(\"my-mcp-server\")\n    asyncio.run(server.run())\n\ndef create_server():\n    \"\"\"Factory function for programmatic server creation.\"\"\"\n    return MCPServer(\"my-mcp-server\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"develop/python/packaging/#building-packages","title":"Building Packages","text":""},{"location":"develop/python/packaging/#build-tools-setup","title":"Build Tools Setup","text":"<pre><code># Install build tools\nuv add --dev build twine\n\n# Or with pip\npip install build twine\n</code></pre>"},{"location":"develop/python/packaging/#building-the-package","title":"Building the Package","text":"<pre><code># Clean previous builds\nrm -rf dist/ build/ *.egg-info/\n\n# Build the package\npython -m build\n\n# This creates:\n# dist/my_mcp_server-0.1.0.tar.gz (source distribution)\n# dist/my_mcp_server-0.1.0-py3-none-any.whl (wheel)\n</code></pre>"},{"location":"develop/python/packaging/#package-validation","title":"Package Validation","text":"<pre><code># Check package contents\ntar -tzf dist/my_mcp_server-0.1.0.tar.gz\nunzip -l dist/my_mcp_server-0.1.0-py3-none-any.whl\n\n# Validate package metadata\ntwine check dist/*\n\n# Test installation\npip install dist/my_mcp_server-0.1.0-py3-none-any.whl\n</code></pre>"},{"location":"develop/python/packaging/#publishing","title":"Publishing","text":""},{"location":"develop/python/packaging/#pypi-publishing","title":"PyPI Publishing","text":"<pre><code># Configure PyPI token\n# Create .pypirc or use environment variables\nexport TWINE_USERNAME=__token__\nexport TWINE_PASSWORD=pypi-your-api-token-here\n\n# Upload to Test PyPI first\ntwine upload --repository testpypi dist/*\n\n# Test install from Test PyPI\npip install --index-url https://test.pypi.org/simple/ my-mcp-server\n\n# Upload to production PyPI\ntwine upload dist/*\n</code></pre>"},{"location":"develop/python/packaging/#automated-publishing","title":"Automated Publishing","text":"<pre><code># .github/workflows/publish.yml\nname: Publish Python Package\n\non:\n  release:\n    types: [published]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n    \n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install build twine\n    \n    - name: Build package\n      run: python -m build\n    \n    - name: Publish to PyPI\n      env:\n        TWINE_USERNAME: __token__\n        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}\n      run: |\n        twine upload dist/*\n</code></pre>"},{"location":"develop/python/packaging/#version-management","title":"Version Management","text":""},{"location":"develop/python/packaging/#semantic-versioning","title":"Semantic Versioning","text":"<p>Follow semantic versioning (semver): - <code>MAJOR.MINOR.PATCH</code> - <code>1.0.0</code> - Initial stable release - <code>1.0.1</code> - Bug fixes - <code>1.1.0</code> - New features (backward compatible) - <code>2.0.0</code> - Breaking changes</p>"},{"location":"develop/python/packaging/#dynamic-versioning","title":"Dynamic Versioning","text":"<pre><code># src/my_mcp_server/__init__.py\n__version__ = \"0.1.0\"\n__all__ = [\"__version__\"]\n</code></pre> <pre><code># pyproject.toml - dynamic version\n[project]\ndynamic = [\"version\"]\n\n[tool.setuptools.dynamic]\nversion = {attr = \"my_mcp_server.__version__\"}\n</code></pre>"},{"location":"develop/python/packaging/#documentation-packaging","title":"Documentation Packaging","text":""},{"location":"develop/python/packaging/#include-documentation","title":"Include Documentation","text":"<pre><code># Include documentation in package\n[tool.setuptools]\ninclude-package-data = true\n\n[tool.setuptools.package-data]\n\"my_mcp_server\" = [\"docs/*.md\", \"examples/*.py\"]\n</code></pre>"},{"location":"develop/python/packaging/#readme-and-changelog","title":"README and Changelog","text":"<pre><code># Use README as long description\n[project]\nreadme = \"README.md\"\n\n# Or dynamically read README\n[tool.setuptools.dynamic]\nreadme = {file = [\"README.md\"], content-type = \"text/markdown\"}\n</code></pre>"},{"location":"develop/python/packaging/#type-information","title":"Type Information","text":""},{"location":"develop/python/packaging/#include-type-information","title":"Include Type Information","text":"<pre><code># src/my_mcp_server/py.typed\n# Empty file to indicate package includes type information\n</code></pre> <pre><code># Include py.typed in package\n[tool.setuptools.package-data]\n\"my_mcp_server\" = [\"py.typed\"]\n</code></pre>"},{"location":"develop/python/packaging/#development-installation","title":"Development Installation","text":""},{"location":"develop/python/packaging/#editable-installation","title":"Editable Installation","text":"<pre><code># Install in development mode\npip install -e .\n\n# With development dependencies\npip install -e \".[dev]\"\n\n# Using uv\nuv pip install -e \".[dev]\"\n</code></pre>"},{"location":"develop/python/packaging/#development-workflow","title":"Development Workflow","text":"<pre><code># Setup development environment\ngit clone https://github.com/yourusername/my-mcp-server\ncd my-mcp-server\npython -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\npip install -e \".[dev]\"\n\n# Run tests\npytest\n\n# Format code\nblack src tests\nruff check src tests\n\n# Type checking\nmypy src\n\n# Build package\npython -m build\n</code></pre>"},{"location":"develop/python/packaging/#makefile-automation","title":"Makefile Automation","text":"<pre><code># Makefile\n.PHONY: install dev test lint format build clean publish\n\ninstall:\n\tpip install .\n\ndev:\n\tpip install -e \".[dev]\"\n\ntest:\n\tpytest --cov=src --cov-report=term-missing\n\nlint:\n\truff check src tests\n\tmypy src\n\nformat:\n\tblack src tests\n\truff check --fix src tests\n\nbuild: clean\n\tpython -m build\n\nclean:\n\trm -rf dist/ build/ *.egg-info/ .coverage htmlcov/\n\npublish: build\n\ttwine upload dist/*\n\ntest-publish: build\n\ttwine upload --repository testpypi dist/*\n</code></pre>"},{"location":"develop/python/packaging/#docker-packaging","title":"Docker Packaging","text":""},{"location":"develop/python/packaging/#dockerfile-for-distribution","title":"Dockerfile for Distribution","text":"<pre><code>FROM python:3.11-slim\n\nWORKDIR /app\n\n# Copy package files\nCOPY dist/my_mcp_server-*.whl .\n\n# Install package\nRUN pip install --no-cache-dir my_mcp_server-*.whl\n\n# Create non-root user\nRUN useradd -m -u 1000 mcp\nUSER mcp\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD python -c \"import my_mcp_server; print('OK')\"\n\nCMD [\"my-mcp-server\"]\n</code></pre>"},{"location":"develop/python/packaging/#best-practices","title":"Best Practices","text":""},{"location":"develop/python/packaging/#package-metadata","title":"Package Metadata","text":"<ol> <li>Descriptive Name: Clear, searchable package name</li> <li>Good Description: Explain what the server does</li> <li>Proper Classifiers: Help users find your package</li> <li>Version Pinning: Pin major versions, allow minor updates</li> </ol>"},{"location":"develop/python/packaging/#dependencies","title":"Dependencies","text":"<ol> <li>Minimal Dependencies: Only include necessary packages</li> <li>Version Constraints: Use <code>&gt;=</code> for minimum versions</li> <li>Optional Dependencies: Group related optional features</li> <li>Security: Regularly update dependencies</li> </ol>"},{"location":"develop/python/packaging/#distribution","title":"Distribution","text":"<ol> <li>Test First: Always test on Test PyPI first</li> <li>Automated Builds: Use CI/CD for consistent builds</li> <li>Signed Packages: Sign packages for security</li> <li>Documentation: Include comprehensive documentation</li> </ol>"},{"location":"develop/python/packaging/#maintenance","title":"Maintenance","text":"<ol> <li>Semantic Versioning: Follow semver strictly</li> <li>Changelog: Maintain detailed changelog</li> <li>Backward Compatibility: Avoid breaking changes in minor versions</li> <li>Deprecation Warnings: Warn before removing features</li> </ol> <p>Proper packaging makes your MCP server accessible to the community and easy to integrate into various environments.</p>"},{"location":"develop/python/structure/","title":"Project Structure","text":""},{"location":"develop/python/structure/#python-project-structure","title":"Python Project Structure","text":""},{"location":"develop/python/structure/#recommended-project-layout","title":"Recommended Project Layout","text":"<p>A well-structured MCP server project follows Python packaging standards and best practices.</p>"},{"location":"develop/python/structure/#standard-structure","title":"Standard Structure","text":"<pre><code>my-mcp-server/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_mcp_server/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 server.py          # Main server implementation\n\u2502       \u251c\u2500\u2500 tools/             # Tool implementations\n\u2502       \u2502   \u251c\u2500\u2500 __init__.py\n\u2502       \u2502   \u251c\u2500\u2500 database.py\n\u2502       \u2502   \u2514\u2500\u2500 file_ops.py\n\u2502       \u251c\u2500\u2500 resources/         # Resource providers\n\u2502       \u2502   \u251c\u2500\u2500 __init__.py\n\u2502       \u2502   \u2514\u2500\u2500 config.py\n\u2502       \u2514\u2500\u2500 utils/            # Shared utilities\n\u2502           \u251c\u2500\u2500 __init__.py\n\u2502           \u2514\u2500\u2500 helpers.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_server.py\n\u2502   \u251c\u2500\u2500 test_tools/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 test_database.py\n\u2502   \u2502   \u2514\u2500\u2500 test_file_ops.py\n\u2502   \u2514\u2500\u2500 fixtures/\n\u2502       \u2514\u2500\u2500 sample_data.json\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 api.md\n\u2502   \u2514\u2500\u2500 usage.md\n\u251c\u2500\u2500 scripts/\n\u2502   \u251c\u2500\u2500 run_server.py\n\u2502   \u2514\u2500\u2500 setup_dev.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 LICENSE\n\u2514\u2500\u2500 .gitignore\n</code></pre>"},{"location":"develop/python/structure/#core-components","title":"Core Components","text":""},{"location":"develop/python/structure/#server-module-serverpy","title":"Server Module (<code>server.py</code>)","text":"<pre><code>import asyncio\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom .tools import register_tools\nfrom .resources import register_resources\n\nclass MCPServer:\n    def __init__(self, name: str):\n        self.server = Server(name)\n        self._register_handlers()\n    \n    def _register_handlers(self):\n        register_tools(self.server)\n        register_resources(self.server)\n    \n    async def run(self):\n        async with stdio_server() as (read_stream, write_stream):\n            await self.server.run(read_stream, write_stream)\n\ndef main():\n    server = MCPServer(\"my-mcp-server\")\n    asyncio.run(server.run())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"develop/python/structure/#tool-organization-tools__init__py","title":"Tool Organization (<code>tools/__init__.py</code>)","text":"<pre><code>from mcp.server import Server\nfrom .database import register_database_tools\nfrom .file_ops import register_file_tools\n\ndef register_tools(server: Server):\n    \"\"\"Register all tools with the server.\"\"\"\n    register_database_tools(server)\n    register_file_tools(server)\n</code></pre>"},{"location":"develop/python/structure/#individual-tool-modules-toolsdatabasepy","title":"Individual Tool Modules (<code>tools/database.py</code>)","text":"<pre><code>from mcp.server import Server\nfrom mcp.types import Tool, TextContent\nimport json\n\ndef register_database_tools(server: Server):\n    \"\"\"Register database-related tools.\"\"\"\n    \n    @server.list_tools()\n    async def list_tools():\n        return [\n            Tool(\n                name=\"query_database\",\n                description=\"Execute a SQL query\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"query\": {\"type\": \"string\"},\n                        \"limit\": {\"type\": \"integer\", \"default\": 100}\n                    },\n                    \"required\": [\"query\"]\n                }\n            )\n        ]\n    \n    @server.call_tool()\n    async def call_tool(name: str, arguments: dict):\n        if name == \"query_database\":\n            return await _execute_query(arguments)\n        raise ValueError(f\"Unknown tool: {name}\")\n\nasync def _execute_query(args: dict):\n    \"\"\"Execute database query (implementation).\"\"\"\n    query = args[\"query\"]\n    limit = args.get(\"limit\", 100)\n    \n    # Your database logic here\n    result = {\"query\": query, \"limit\": limit, \"results\": []}\n    \n    return [TextContent(type=\"text\", text=json.dumps(result))]\n</code></pre>"},{"location":"develop/python/structure/#configuration-management","title":"Configuration Management","text":""},{"location":"develop/python/structure/#settings-module-utilsconfigpy","title":"Settings Module (<code>utils/config.py</code>)","text":"<pre><code>import os\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n@dataclass\nclass Settings:\n    \"\"\"Application settings from environment variables.\"\"\"\n    \n    # Server settings\n    server_name: str = \"my-mcp-server\"\n    debug: bool = False\n    \n    # Database settings\n    database_url: Optional[str] = None\n    database_timeout: int = 30\n    \n    # API settings\n    api_key: Optional[str] = None\n    api_base_url: str = \"https://api.example.com\"\n    \n    @classmethod\n    def from_env(cls) -&gt; 'Settings':\n        \"\"\"Load settings from environment variables.\"\"\"\n        return cls(\n            server_name=os.getenv(\"MCP_SERVER_NAME\", cls.server_name),\n            debug=os.getenv(\"MCP_DEBUG\", \"false\").lower() == \"true\",\n            database_url=os.getenv(\"DATABASE_URL\"),\n            database_timeout=int(os.getenv(\"DATABASE_TIMEOUT\", \"30\")),\n            api_key=os.getenv(\"API_KEY\"),\n            api_base_url=os.getenv(\"API_BASE_URL\", cls.api_base_url)\n        )\n\n# Global settings instance\nsettings = Settings.from_env()\n</code></pre>"},{"location":"develop/python/structure/#package-configuration","title":"Package Configuration","text":""},{"location":"develop/python/structure/#pyprojecttoml","title":"pyproject.toml","text":"<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-mcp-server\"\nversion = \"0.1.0\"\ndescription = \"My MCP Server implementation\"\nreadme = \"README.md\"\nlicense = {text = \"MIT\"}\nauthors = [{name = \"Your Name\", email = \"you@example.com\"}]\nrequires-python = \"&gt;=3.11\"\ndependencies = [\n    \"mcp&gt;=0.1.0\",\n    \"aiofiles&gt;=23.0.0\",\n    \"pydantic&gt;=2.0.0\",\n]\nclassifiers = [\n    \"Development Status :: 3 - Alpha\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0.0\",\n    \"pytest-asyncio&gt;=0.21.0\",\n    \"pytest-cov&gt;=4.0.0\",\n    \"black&gt;=23.0.0\",\n    \"ruff&gt;=0.1.0\",\n    \"mypy&gt;=1.0.0\",\n]\n\n[project.scripts]\nmy-mcp-server = \"my_mcp_server.server:main\"\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n[tool.black]\nline-length = 88\ntarget-version = ['py311']\n\n[tool.ruff]\ntarget-version = \"py311\"\nline-length = 88\n\n[tool.mypy]\npython_version = \"3.11\"\nstrict = true\nwarn_return_any = true\nwarn_unused_configs = true\n</code></pre>"},{"location":"develop/python/structure/#development-scripts","title":"Development Scripts","text":""},{"location":"develop/python/structure/#development-runner-scriptsrun_serverpy","title":"Development Runner (<code>scripts/run_server.py</code>)","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Development server runner with hot reload.\"\"\"\n\nimport sys\nimport os\nfrom pathlib import Path\n\n# Add src to path\nsrc_path = Path(__file__).parent.parent / \"src\"\nsys.path.insert(0, str(src_path))\n\nfrom my_mcp_server.server import main\n\nif __name__ == \"__main__\":\n    # Set development environment\n    os.environ.setdefault(\"MCP_DEBUG\", \"true\")\n    main()\n</code></pre>"},{"location":"develop/python/structure/#best-practices","title":"Best Practices","text":""},{"location":"develop/python/structure/#code-organization","title":"Code Organization","text":"<ol> <li>Separation of Concerns: Keep tools, resources, and utilities in separate modules</li> <li>Type Hints: Use comprehensive type annotations</li> <li>Error Handling: Implement proper exception handling</li> <li>Logging: Use structured logging throughout</li> </ol>"},{"location":"develop/python/structure/#dependencies","title":"Dependencies","text":"<ol> <li>Minimal Dependencies: Only include necessary packages</li> <li>Version Pinning: Pin major versions, allow minor updates</li> <li>Development Dependencies: Separate dev dependencies from runtime</li> </ol>"},{"location":"develop/python/structure/#testing-structure","title":"Testing Structure","text":"<ol> <li>Mirror Source Structure: Tests should mirror the src/ structure</li> <li>Fixtures: Use pytest fixtures for common test data</li> <li>Integration Tests: Test the full server integration</li> </ol>"},{"location":"develop/python/structure/#documentation","title":"Documentation","text":"<ol> <li>Docstrings: Document all public functions and classes</li> <li>Type Hints: Use as documentation for function signatures</li> <li>README: Include setup, usage, and configuration instructions</li> </ol> <p>This structure provides a solid foundation for maintainable, testable MCP servers in Python.</p>"},{"location":"develop/python/testing/","title":"Testing","text":""},{"location":"develop/python/testing/#python-testing","title":"Python Testing","text":""},{"location":"develop/python/testing/#testing-strategy-for-mcp-servers","title":"Testing Strategy for MCP Servers","text":"<p>Comprehensive testing ensures your MCP server is reliable and maintainable.</p>"},{"location":"develop/python/testing/#testing-stack","title":"Testing Stack","text":""},{"location":"develop/python/testing/#core-testing-tools","title":"Core Testing Tools","text":"<pre><code># Install testing dependencies\nuv add --dev pytest pytest-asyncio pytest-cov pytest-mock\n</code></pre>"},{"location":"develop/python/testing/#testing-configuration","title":"Testing Configuration","text":"<pre><code># pyproject.toml\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\", \"*_test.py\"]\npython_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = \"-v --tb=short --cov=src --cov-report=term-missing\"\nasyncio_mode = \"auto\"\n</code></pre>"},{"location":"develop/python/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"develop/python/testing/#testing-tools","title":"Testing Tools","text":"<pre><code># tests/test_tools.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\nfrom mcp.types import TextContent\n\nfrom my_mcp_server.tools.database import _execute_query\n\n@pytest.mark.asyncio\nasync def test_execute_query():\n    \"\"\"Test database query execution.\"\"\"\n    args = {\"query\": \"SELECT * FROM users\", \"limit\": 10}\n    \n    with patch(\"my_mcp_server.tools.database.db_client\") as mock_db:\n        mock_db.execute.return_value = [{\"id\": 1, \"name\": \"Alice\"}]\n        \n        result = await _execute_query(args)\n        \n        assert len(result) == 1\n        assert isinstance(result[0], TextContent)\n        assert \"Alice\" in result[0].text\n</code></pre>"},{"location":"develop/python/testing/#testing-server-handlers","title":"Testing Server Handlers","text":"<pre><code># tests/test_server.py\nimport pytest\nfrom mcp.server import Server\nfrom my_mcp_server.server import MCPServer\n\n@pytest.fixture\ndef server():\n    \"\"\"Create test server instance.\"\"\"\n    return MCPServer(\"test-server\")\n\n@pytest.mark.asyncio\nasync def test_server_initialization(server):\n    \"\"\"Test server initializes correctly.\"\"\"\n    assert server.server.name == \"test-server\"\n    # Test that handlers are registered\n    tools = await server.server._list_tools_handler()\n    assert len(tools) &gt; 0\n</code></pre>"},{"location":"develop/python/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"develop/python/testing/#testing-with-real-mcp-protocol","title":"Testing with Real MCP Protocol","text":"<pre><code># tests/test_integration.py\nimport asyncio\nimport json\nfrom io import StringIO\nfrom mcp.server.stdio import stdio_server\n\n@pytest.mark.asyncio\nasync def test_mcp_protocol_integration():\n    \"\"\"Test full MCP protocol integration.\"\"\"\n    from my_mcp_server.server import MCPServer\n    \n    server = MCPServer(\"test-server\")\n    \n    # Simulate stdin/stdout\n    stdin_data = json.dumps({\n        \"jsonrpc\": \"2.0\",\n        \"method\": \"tools/list\",\n        \"id\": 1\n    }) + \"\\n\"\n    \n    stdin = StringIO(stdin_data)\n    stdout = StringIO()\n    \n    # This would require custom stdio handling for testing\n    # In practice, use MCP test utilities when available\n</code></pre>"},{"location":"develop/python/testing/#mock-external-dependencies","title":"Mock External Dependencies","text":""},{"location":"develop/python/testing/#database-mocking","title":"Database Mocking","text":"<pre><code># tests/conftest.py\nimport pytest\nfrom unittest.mock import AsyncMock\n\n@pytest.fixture\ndef mock_database():\n    \"\"\"Mock database client.\"\"\"\n    mock_client = AsyncMock()\n    mock_client.execute.return_value = [{\"id\": 1, \"name\": \"test\"}]\n    mock_client.connect.return_value = True\n    return mock_client\n\n@pytest.fixture(autouse=True)\ndef patch_database(mock_database, monkeypatch):\n    \"\"\"Automatically patch database in all tests.\"\"\"\n    monkeypatch.setattr(\n        \"my_mcp_server.tools.database.get_db_client\",\n        lambda: mock_database\n    )\n</code></pre>"},{"location":"develop/python/testing/#api-client-mocking","title":"API Client Mocking","text":"<pre><code># tests/test_api_tools.py\nimport pytest\nimport aiohttp\nfrom aioresponses import aioresponses\n\n@pytest.mark.asyncio\nasync def test_api_call():\n    \"\"\"Test external API calls.\"\"\"\n    with aioresponses() as m:\n        m.get(\n            \"https://api.example.com/users/1\",\n            payload={\"id\": 1, \"name\": \"Alice\"}\n        )\n        \n        result = await fetch_user_data(1)\n        assert result[\"name\"] == \"Alice\"\n</code></pre>"},{"location":"develop/python/testing/#testing-utilities","title":"Testing Utilities","text":""},{"location":"develop/python/testing/#test-fixtures","title":"Test Fixtures","text":"<pre><code># tests/fixtures.py\nimport pytest\nfrom pathlib import Path\n\n@pytest.fixture\ndef sample_data():\n    \"\"\"Load sample test data.\"\"\"\n    fixture_path = Path(__file__).parent / \"fixtures\" / \"sample_data.json\"\n    with open(fixture_path) as f:\n        return json.load(f)\n\n@pytest.fixture\ndef temp_file(tmp_path):\n    \"\"\"Create temporary test file.\"\"\"\n    test_file = tmp_path / \"test.txt\"\n    test_file.write_text(\"test content\")\n    return test_file\n</code></pre>"},{"location":"develop/python/testing/#custom-assertions","title":"Custom Assertions","text":"<pre><code># tests/assertions.py\ndef assert_valid_mcp_response(response):\n    \"\"\"Assert response is valid MCP format.\"\"\"\n    assert isinstance(response, list)\n    for item in response:\n        assert hasattr(item, 'type')\n        if item.type == 'text':\n            assert hasattr(item, 'text')\n            assert isinstance(item.text, str)\n</code></pre>"},{"location":"develop/python/testing/#error-testing","title":"Error Testing","text":""},{"location":"develop/python/testing/#testing-error-conditions","title":"Testing Error Conditions","text":"<pre><code>@pytest.mark.asyncio\nasync def test_invalid_tool_name():\n    \"\"\"Test error handling for invalid tool names.\"\"\"\n    server = MCPServer(\"test-server\")\n    \n    with pytest.raises(ValueError, match=\"Unknown tool\"):\n        await server.server._call_tool_handler(\n            \"nonexistent_tool\",\n            {\"arg\": \"value\"}\n        )\n\n@pytest.mark.asyncio\nasync def test_missing_required_argument():\n    \"\"\"Test error handling for missing arguments.\"\"\"\n    with pytest.raises(ValueError, match=\"required\"):\n        await call_tool_with_validation(\"query_database\", {})\n</code></pre>"},{"location":"develop/python/testing/#testing-input-validation","title":"Testing Input Validation","text":"<pre><code>@pytest.mark.parametrize(\"invalid_input,expected_error\", [\n    (\"\", \"Query cannot be empty\"),\n    (None, \"Query is required\"),\n    (\"SELECT * FROM users; DROP TABLE users;\", \"Invalid query\"),\n])\n@pytest.mark.asyncio\nasync def test_query_validation(invalid_input, expected_error):\n    \"\"\"Test query validation.\"\"\"\n    with pytest.raises(ValueError, match=expected_error):\n        await validate_query(invalid_input)\n</code></pre>"},{"location":"develop/python/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"develop/python/testing/#timing-tests","title":"Timing Tests","text":"<pre><code>import time\n\n@pytest.mark.asyncio\nasync def test_response_time():\n    \"\"\"Test response time requirements.\"\"\"\n    start_time = time.time()\n    \n    result = await execute_expensive_operation()\n    \n    elapsed = time.time() - start_time\n    assert elapsed &lt; 1.0  # Should complete within 1 second\n</code></pre>"},{"location":"develop/python/testing/#load-testing","title":"Load Testing","text":"<pre><code>@pytest.mark.asyncio\nasync def test_concurrent_requests():\n    \"\"\"Test handling multiple concurrent requests.\"\"\"\n    server = MCPServer(\"test-server\")\n    \n    # Create 10 concurrent requests\n    tasks = [\n        server.call_tool(\"simple_tool\", {\"id\": i})\n        for i in range(10)\n    ]\n    \n    results = await asyncio.gather(*tasks)\n    assert len(results) == 10\n</code></pre>"},{"location":"develop/python/testing/#test-coverage","title":"Test Coverage","text":""},{"location":"develop/python/testing/#running-coverage","title":"Running Coverage","text":"<pre><code># Run tests with coverage\npytest --cov=src --cov-report=html --cov-report=term-missing\n\n# View HTML coverage report\nopen htmlcov/index.html\n</code></pre>"},{"location":"develop/python/testing/#coverage-configuration","title":"Coverage Configuration","text":"<pre><code># pyproject.toml\n[tool.coverage.run]\nsource = [\"src\"]\nomit = [\n    \"tests/*\",\n    \"*/test_*.py\",\n    \"src/*/__main__.py\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"if __name__ == .__main__.:\",\n]\n</code></pre>"},{"location":"develop/python/testing/#continuous-integration","title":"Continuous Integration","text":""},{"location":"develop/python/testing/#github-actions-testing","title":"GitHub Actions Testing","text":"<pre><code># .github/workflows/test.yml\nname: Test\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.11\", \"3.12\"]\n    \n    steps:\n    - uses: actions/checkout@v4\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: ${{ matrix.python-version }}\n    \n    - name: Install dependencies\n      run: |\n        pip install -e \".[dev]\"\n    \n    - name: Run tests\n      run: |\n        pytest --cov=src --cov-report=xml\n    \n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n</code></pre>"},{"location":"develop/python/testing/#best-practices","title":"Best Practices","text":""},{"location":"develop/python/testing/#test-organization","title":"Test Organization","text":"<ol> <li>Mirror Structure: Test files mirror source structure</li> <li>Clear Names: Descriptive test function names</li> <li>Single Responsibility: One test per behavior</li> <li>Setup/Teardown: Use fixtures for common setup</li> </ol>"},{"location":"develop/python/testing/#test-quality","title":"Test Quality","text":"<ol> <li>Fast Tests: Unit tests should run quickly</li> <li>Isolated Tests: Tests don't depend on each other</li> <li>Deterministic: Tests produce same results every time</li> <li>Comprehensive: Cover happy path, edge cases, and errors</li> </ol>"},{"location":"develop/python/testing/#debugging-tests","title":"Debugging Tests","text":"<pre><code># Run specific test with verbose output\npytest tests/test_specific.py::test_function -v -s\n\n# Run with debugging on first failure\npytest --pdb\n\n# Run with coverage and open report\npytest --cov=src --cov-report=html &amp;&amp; open htmlcov/index.html\n</code></pre> <p>Testing is crucial for maintaining reliable MCP servers. Focus on testing your business logic, error handling, and integration points.</p>"},{"location":"develop/rust/best-practices/","title":"Rust Best Practices for MCP Servers","text":""},{"location":"develop/rust/best-practices/#rust-best-practices-for-mcp-servers","title":"Rust Best Practices for MCP Servers","text":""},{"location":"develop/rust/best-practices/#rust-specific-best-practices","title":"Rust-Specific Best Practices","text":"<p>This guide covers Rust-specific best practices, patterns, and idioms for building robust, efficient, and maintainable MCP servers that leverage Rust's unique strengths.</p>"},{"location":"develop/rust/best-practices/#code-organization-and-architecture","title":"Code Organization and Architecture","text":""},{"location":"develop/rust/best-practices/#module-structure-and-visibility","title":"Module Structure and Visibility","text":"<pre><code>// \u2705 Good: Clear module hierarchy with appropriate visibility\npub mod server {\n    pub mod handlers;\n    pub mod transport;\n    \n    // Re-export public API\n    pub use handlers::Handlers;\n    pub use transport::Transport;\n}\n\npub mod tools {\n    mod database;   // Private implementation\n    mod http;       // Private implementation\n    \n    pub use database::DatabaseTool;\n    pub use http::HttpTool;\n    \n    // Trait for tool implementations\n    pub trait ToolExecutor: Send + Sync {\n        // Method definitions\n    }\n}\n\n// \u274c Bad: Everything public or unclear hierarchy\npub mod everything {\n    pub mod database;\n    pub mod http;\n    pub mod utils;\n    pub mod helpers;\n    pub mod stuff;\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#error-handling-with-thiserror-and-anyhow","title":"Error Handling with thiserror and anyhow","text":"<pre><code>// \u2705 Good: Structured error types with context\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum McpError {\n    #[error(\"Configuration error: {message}\")]\n    Config { message: String },\n    \n    #[error(\"Tool '{tool_name}' execution failed: {source}\")]\n    ToolExecution {\n        tool_name: String,\n        #[source]\n        source: Box&lt;dyn std::error::Error + Send + Sync&gt;,\n    },\n    \n    #[error(\"Validation failed for field '{field}': {message}\")]\n    Validation { field: String, message: String },\n    \n    #[error(\"Resource '{uri}' not found\")]\n    ResourceNotFound { uri: String },\n    \n    #[error(\"Permission denied: {operation}\")]\n    PermissionDenied { operation: String },\n    \n    #[error(\"I/O error\")]\n    Io(#[from] std::io::Error),\n    \n    #[error(\"HTTP request failed\")]\n    Http(#[from] reqwest::Error),\n    \n    #[error(\"JSON serialization error\")]\n    Json(#[from] serde_json::Error),\n}\n\n// Extension trait for better error context\npub trait McpErrorExt&lt;T&gt; {\n    fn with_tool_context(self, tool_name: &amp;str) -&gt; Result&lt;T, McpError&gt;;\n    fn with_validation_context(self, field: &amp;str) -&gt; Result&lt;T, McpError&gt;;\n}\n\nimpl&lt;T, E&gt; McpErrorExt&lt;T&gt; for Result&lt;T, E&gt;\nwhere\n    E: std::error::Error + Send + Sync + 'static,\n{\n    fn with_tool_context(self, tool_name: &amp;str) -&gt; Result&lt;T, McpError&gt; {\n        self.map_err(|e| McpError::ToolExecution {\n            tool_name: tool_name.to_string(),\n            source: Box::new(e),\n        })\n    }\n    \n    fn with_validation_context(self, field: &amp;str) -&gt; Result&lt;T, McpError&gt; {\n        self.map_err(|e| McpError::Validation {\n            field: field.to_string(),\n            message: e.to_string(),\n        })\n    }\n}\n\n// Usage\nfn execute_tool(name: &amp;str) -&gt; Result&lt;String, McpError&gt; {\n    some_operation()\n        .with_tool_context(name)?\n        .into_string()\n        .with_validation_context(\"result\")\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#type-safety-with-newtypes","title":"Type Safety with Newtypes","text":"<pre><code>// \u2705 Good: Strong typing with newtypes\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ToolName(String);\n\nimpl ToolName {\n    pub fn new(name: impl Into&lt;String&gt;) -&gt; Result&lt;Self, McpError&gt; {\n        let name = name.into();\n        if name.is_empty() {\n            return Err(McpError::Validation {\n                field: \"tool_name\".to_string(),\n                message: \"Tool name cannot be empty\".to_string(),\n            });\n        }\n        if name.len() &gt; 100 {\n            return Err(McpError::Validation {\n                field: \"tool_name\".to_string(),\n                message: \"Tool name too long\".to_string(),\n            });\n        }\n        Ok(Self(name))\n    }\n    \n    pub fn as_str(&amp;self) -&gt; &amp;str {\n        &amp;self.0\n    }\n}\n\nimpl std::fmt::Display for ToolName {\n    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourceUri(String);\n\nimpl ResourceUri {\n    pub fn new(uri: impl Into&lt;String&gt;) -&gt; Result&lt;Self, McpError&gt; {\n        let uri = uri.into();\n        url::Url::parse(&amp;uri)\n            .map_err(|e| McpError::Validation {\n                field: \"resource_uri\".to_string(),\n                message: format!(\"Invalid URI: {}\", e),\n            })?;\n        Ok(Self(uri))\n    }\n}\n\n// \u274c Bad: Stringly typed parameters\nfn execute_tool(name: String, uri: String) -&gt; Result&lt;String, McpError&gt; {\n    // No compile-time guarantees about validity\n    unimplemented!()\n}\n\n// \u2705 Good: Type-safe parameters\nfn execute_tool(name: ToolName, uri: ResourceUri) -&gt; Result&lt;String, McpError&gt; {\n    // Guaranteed valid at compile time\n    unimplemented!()\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#async-programming-best-practices","title":"Async Programming Best Practices","text":""},{"location":"develop/rust/best-practices/#structured-concurrency","title":"Structured Concurrency","text":"<pre><code>// \u2705 Good: Structured concurrency with proper error handling\nuse tokio::select;\nuse tokio::sync::mpsc;\nuse tokio::time::{timeout, Duration};\n\npub struct ToolExecutorPool {\n    workers: Vec&lt;tokio::task::JoinHandle&lt;()&gt;&gt;,\n    task_tx: mpsc::UnboundedSender&lt;ToolTask&gt;,\n    shutdown_tx: mpsc::Sender&lt;()&gt;,\n}\n\nimpl ToolExecutorPool {\n    pub async fn new(worker_count: usize) -&gt; Self {\n        let (task_tx, task_rx) = mpsc::unbounded_channel();\n        let (shutdown_tx, shutdown_rx) = mpsc::channel(1);\n        let task_rx = Arc::new(Mutex::new(task_rx));\n        let shutdown_rx = Arc::new(Mutex::new(shutdown_rx));\n        \n        let mut workers = Vec::new();\n        \n        for worker_id in 0..worker_count {\n            let task_rx = task_rx.clone();\n            let shutdown_rx = shutdown_rx.clone();\n            \n            let handle = tokio::spawn(async move {\n                Self::worker_loop(worker_id, task_rx, shutdown_rx).await;\n            });\n            \n            workers.push(handle);\n        }\n        \n        Self {\n            workers,\n            task_tx,\n            shutdown_tx,\n        }\n    }\n    \n    async fn worker_loop(\n        worker_id: usize,\n        task_rx: Arc&lt;Mutex&lt;mpsc::UnboundedReceiver&lt;ToolTask&gt;&gt;&gt;,\n        shutdown_rx: Arc&lt;Mutex&lt;mpsc::Receiver&lt;()&gt;&gt;&gt;,\n    ) {\n        tracing::info!(\"Worker {} started\", worker_id);\n        \n        loop {\n            select! {\n                // Receive shutdown signal\n                _ = async {\n                    let mut rx = shutdown_rx.lock().await;\n                    rx.recv().await\n                } =&gt; {\n                    tracing::info!(\"Worker {} shutting down\", worker_id);\n                    break;\n                }\n                \n                // Process task\n                task = async {\n                    let mut rx = task_rx.lock().await;\n                    rx.recv().await\n                } =&gt; {\n                    match task {\n                        Some(task) =&gt; {\n                            if let Err(e) = Self::process_task(task).await {\n                                tracing::error!(\"Worker {} task failed: {}\", worker_id, e);\n                            }\n                        }\n                        None =&gt; break, // Channel closed\n                    }\n                }\n            }\n        }\n        \n        tracing::info!(\"Worker {} stopped\", worker_id);\n    }\n    \n    async fn process_task(task: ToolTask) -&gt; Result&lt;(), McpError&gt; {\n        // Add timeout to prevent hanging\n        let result = timeout(Duration::from_secs(30), async {\n            task.tool.execute(task.arguments).await\n        }).await;\n        \n        match result {\n            Ok(Ok(result)) =&gt; {\n                let _ = task.response_tx.send(Ok(result));\n            }\n            Ok(Err(e)) =&gt; {\n                let _ = task.response_tx.send(Err(e));\n            }\n            Err(_) =&gt; {\n                let _ = task.response_tx.send(Err(McpError::ToolExecution {\n                    tool_name: \"unknown\".to_string(),\n                    source: Box::new(std::io::Error::new(\n                        std::io::ErrorKind::TimedOut,\n                        \"Task execution timed out\"\n                    )),\n                }));\n            }\n        }\n        \n        Ok(())\n    }\n    \n    pub async fn execute_tool(\n        &amp;self,\n        tool: Arc&lt;dyn ToolExecutor&gt;,\n        arguments: HashMap&lt;String, Value&gt;,\n    ) -&gt; Result&lt;ToolResult, McpError&gt; {\n        let (response_tx, mut response_rx) = mpsc::channel(1);\n        \n        let task = ToolTask {\n            tool,\n            arguments,\n            response_tx,\n        };\n        \n        self.task_tx.send(task)\n            .map_err(|_| McpError::Config {\n                message: \"Tool executor pool is shut down\".to_string(),\n            })?;\n        \n        response_rx.recv().await\n            .ok_or_else(|| McpError::Config {\n                message: \"Failed to receive task result\".to_string(),\n            })?\n    }\n    \n    pub async fn shutdown(self) {\n        // Signal shutdown\n        let _ = self.shutdown_tx.send(()).await;\n        \n        // Wait for all workers to finish\n        for handle in self.workers {\n            let _ = handle.await;\n        }\n    }\n}\n\nstruct ToolTask {\n    tool: Arc&lt;dyn ToolExecutor&gt;,\n    arguments: HashMap&lt;String, Value&gt;,\n    response_tx: mpsc::Sender&lt;Result&lt;ToolResult, McpError&gt;&gt;,\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#resource-management-with-raii","title":"Resource Management with RAII","text":"<pre><code>// \u2705 Good: RAII pattern with proper cleanup\npub struct DatabaseConnection {\n    pool: sqlx::PgPool,\n    connection_id: uuid::Uuid,\n    acquired_at: std::time::Instant,\n}\n\nimpl DatabaseConnection {\n    pub async fn acquire(pool: &amp;sqlx::PgPool) -&gt; Result&lt;Self, McpError&gt; {\n        let connection_id = uuid::Uuid::new_v4();\n        let acquired_at = std::time::Instant::now();\n        \n        tracing::debug!(\"Acquiring database connection {}\", connection_id);\n        \n        Ok(Self {\n            pool: pool.clone(),\n            connection_id,\n            acquired_at,\n        })\n    }\n    \n    pub async fn execute_query(&amp;self, query: &amp;str) -&gt; Result&lt;Vec&lt;serde_json::Value&gt;, McpError&gt; {\n        tracing::debug!(\"Executing query on connection {}\", self.connection_id);\n        \n        let rows = sqlx::query(query)\n            .fetch_all(&amp;self.pool)\n            .await\n            .map_err(|e| McpError::ToolExecution {\n                tool_name: \"database\".to_string(),\n                source: Box::new(e),\n            })?;\n        \n        // Convert rows to JSON...\n        Ok(vec![])\n    }\n}\n\nimpl Drop for DatabaseConnection {\n    fn drop(&amp;mut self) {\n        let duration = self.acquired_at.elapsed();\n        tracing::debug!(\n            \"Releasing database connection {} after {:?}\",\n            self.connection_id,\n            duration\n        );\n    }\n}\n\n// Usage ensures automatic cleanup\nasync fn use_database() -&gt; Result&lt;(), McpError&gt; {\n    let pool = get_pool().await?;\n    let conn = DatabaseConnection::acquire(&amp;pool).await?;\n    \n    conn.execute_query(\"SELECT 1\").await?;\n    // Connection automatically cleaned up when `conn` goes out of scope\n    \n    Ok(())\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#memory-management-and-performance","title":"Memory Management and Performance","text":""},{"location":"develop/rust/best-practices/#zero-copy-operations","title":"Zero-Copy Operations","text":"<pre><code>// \u2705 Good: Zero-copy string handling\nuse std::borrow::Cow;\n\npub fn process_content&lt;'a&gt;(input: &amp;'a str, should_transform: bool) -&gt; Cow&lt;'a, str&gt; {\n    if should_transform {\n        // Only allocate when transformation is needed\n        Cow::Owned(input.to_uppercase())\n    } else {\n        // Return borrowed reference\n        Cow::Borrowed(input)\n    }\n}\n\n// \u2705 Good: Efficient JSON handling with serde_json::RawValue\nuse serde_json::value::RawValue;\n\npub struct ToolArguments&lt;'a&gt; {\n    // Store raw JSON to avoid unnecessary parsing\n    raw: &amp;'a RawValue,\n}\n\nimpl&lt;'a&gt; ToolArguments&lt;'a&gt; {\n    pub fn get_string(&amp;self, key: &amp;str) -&gt; Result&lt;Option&lt;&amp;str&gt;, McpError&gt; {\n        let obj: serde_json::Map&lt;String, serde_json::Value&gt; = \n            serde_json::from_str(self.raw.get())?;\n        \n        Ok(obj.get(key).and_then(|v| v.as_str()))\n    }\n    \n    pub fn parse_into&lt;T: serde::de::DeserializeOwned&gt;(&amp;self) -&gt; Result&lt;T, McpError&gt; {\n        serde_json::from_str(self.raw.get())\n            .map_err(|e| McpError::Json(e))\n    }\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#custom-allocators-and-memory-pools","title":"Custom Allocators and Memory Pools","text":"<pre><code>// \u2705 Good: Object pooling for frequently allocated objects\nuse std::sync::{Arc, Mutex};\n\npub struct BufferPool {\n    buffers: Arc&lt;Mutex&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;&gt;,\n    max_capacity: usize,\n    buffer_size: usize,\n}\n\nimpl BufferPool {\n    pub fn new(max_capacity: usize, buffer_size: usize) -&gt; Self {\n        Self {\n            buffers: Arc::new(Mutex::new(Vec::new())),\n            max_capacity,\n            buffer_size,\n        }\n    }\n    \n    pub fn get(&amp;self) -&gt; PooledBuffer {\n        let mut pool = self.buffers.lock().unwrap();\n        let buffer = pool.pop().unwrap_or_else(|| Vec::with_capacity(self.buffer_size));\n        \n        PooledBuffer {\n            buffer: Some(buffer),\n            pool: self.buffers.clone(),\n        }\n    }\n}\n\npub struct PooledBuffer {\n    buffer: Option&lt;Vec&lt;u8&gt;&gt;,\n    pool: Arc&lt;Mutex&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;&gt;,\n}\n\nimpl PooledBuffer {\n    pub fn as_mut(&amp;mut self) -&gt; &amp;mut Vec&lt;u8&gt; {\n        self.buffer.as_mut().unwrap()\n    }\n}\n\nimpl Drop for PooledBuffer {\n    fn drop(&amp;mut self) {\n        if let Some(mut buffer) = self.buffer.take() {\n            buffer.clear(); // Reset but keep capacity\n            \n            let mut pool = self.pool.lock().unwrap();\n            if pool.len() &lt; pool.capacity() {\n                pool.push(buffer);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#security-best-practices","title":"Security Best Practices","text":""},{"location":"develop/rust/best-practices/#input-validation-with-type-system","title":"Input Validation with Type System","text":"<pre><code>// \u2705 Good: Validation at type level\nuse serde::{Deserialize, Deserializer};\nuse std::fmt;\n\n#[derive(Debug, Clone)]\npub struct SafeFilePath(std::path::PathBuf);\n\nimpl SafeFilePath {\n    pub fn new(path: impl AsRef&lt;std::path::Path&gt;) -&gt; Result&lt;Self, McpError&gt; {\n        let path = path.as_ref();\n        \n        // Prevent path traversal\n        if path.to_string_lossy().contains(\"..\") {\n            return Err(McpError::ValidationError {\n                field: \"path\".to_string(),\n                message: \"Path traversal not allowed\".to_string(),\n            });\n        }\n        \n        // Ensure absolute path\n        let canonical = path.canonicalize()\n            .map_err(|e| McpError::ValidationError {\n                field: \"path\".to_string(),\n                message: format!(\"Invalid path: {}\", e),\n            })?;\n        \n        Ok(Self(canonical))\n    }\n    \n    pub fn as_path(&amp;self) -&gt; &amp;std::path::Path {\n        &amp;self.0\n    }\n}\n\nimpl&lt;'de&gt; Deserialize&lt;'de&gt; for SafeFilePath {\n    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Self, D::Error&gt;\n    where\n        D: Deserializer&lt;'de&gt;,\n    {\n        let s = String::deserialize(deserializer)?;\n        SafeFilePath::new(s).map_err(serde::de::Error::custom)\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct SafeUrl(url::Url);\n\nimpl SafeUrl {\n    pub fn new(url_str: &amp;str, allowed_schemes: &amp;[&amp;str]) -&gt; Result&lt;Self, McpError&gt; {\n        let url = url::Url::parse(url_str)\n            .map_err(|e| McpError::ValidationError {\n                field: \"url\".to_string(),\n                message: format!(\"Invalid URL: {}\", e),\n            })?;\n        \n        if !allowed_schemes.contains(&amp;url.scheme()) {\n            return Err(McpError::ValidationError {\n                field: \"url\".to_string(),\n                message: format!(\"Scheme '{}' not allowed\", url.scheme()),\n            });\n        }\n        \n        Ok(Self(url))\n    }\n    \n    pub fn as_url(&amp;self) -&gt; &amp;url::Url {\n        &amp;self.0\n    }\n}\n\n// Usage in tool arguments\n#[derive(Deserialize)]\npub struct FileReadArgs {\n    pub path: SafeFilePath,\n}\n\n#[derive(Deserialize)]\npub struct HttpRequestArgs {\n    pub url: SafeUrl,\n    pub method: Option&lt;HttpMethod&gt;,\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#secure-default-configurations","title":"Secure Default Configurations","text":"<pre><code>// \u2705 Good: Secure defaults with explicit opt-in for permissive settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SecurityConfig {\n    /// Allow dangerous operations (default: false)\n    #[serde(default)]\n    pub allow_dangerous_operations: bool,\n    \n    /// Maximum request size in bytes (default: 1MB)\n    #[serde(default = \"default_max_request_size\")]\n    pub max_request_size: u64,\n    \n    /// Request timeout in seconds (default: 30)\n    #[serde(default = \"default_request_timeout\")]\n    pub request_timeout: u64,\n    \n    /// Allowed file extensions (default: empty = all allowed)\n    #[serde(default)]\n    pub allowed_file_extensions: Vec&lt;String&gt;,\n    \n    /// Rate limiting (requests per minute, default: 60)\n    #[serde(default = \"default_rate_limit\")]\n    pub rate_limit: u32,\n}\n\nfn default_max_request_size() -&gt; u64 { 1024 * 1024 } // 1MB\nfn default_request_timeout() -&gt; u64 { 30 }\nfn default_rate_limit() -&gt; u32 { 60 }\n\nimpl Default for SecurityConfig {\n    fn default() -&gt; Self {\n        Self {\n            allow_dangerous_operations: false,\n            max_request_size: default_max_request_size(),\n            request_timeout: default_request_timeout(),\n            allowed_file_extensions: Vec::new(), // Empty = all allowed\n            rate_limit: default_rate_limit(),\n        }\n    }\n}\n\nimpl SecurityConfig {\n    /// Validate security configuration\n    pub fn validate(&amp;self) -&gt; Result&lt;(), McpError&gt; {\n        if self.max_request_size &gt; 100 * 1024 * 1024 {\n            return Err(McpError::ValidationError {\n                field: \"max_request_size\".to_string(),\n                message: \"Maximum request size too large (&gt;100MB)\".to_string(),\n            });\n        }\n        \n        if self.request_timeout &gt; 300 {\n            return Err(McpError::ValidationError {\n                field: \"request_timeout\".to_string(),\n                message: \"Request timeout too long (&gt;5 minutes)\".to_string(),\n            });\n        }\n        \n        Ok(())\n    }\n    \n    /// Check if file extension is allowed\n    pub fn is_file_extension_allowed(&amp;self, path: &amp;std::path::Path) -&gt; bool {\n        if self.allowed_file_extensions.is_empty() {\n            return true; // All extensions allowed\n        }\n        \n        path.extension()\n            .and_then(|ext| ext.to_str())\n            .map(|ext| self.allowed_file_extensions.contains(&amp;ext.to_string()))\n            .unwrap_or(false)\n    }\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#testing-patterns","title":"Testing Patterns","text":""},{"location":"develop/rust/best-practices/#property-based-testing","title":"Property-Based Testing","text":"<pre><code>// \u2705 Good: Property-based testing for robust validation\nuse quickcheck::{quickcheck, TestResult};\nuse quickcheck_macros::quickcheck;\n\n#[quickcheck]\nfn prop_safe_file_path_prevents_traversal(input: String) -&gt; TestResult {\n    // Skip inputs that are valid paths to focus on traversal attempts\n    if !input.contains(\"..\") {\n        return TestResult::discard();\n    }\n    \n    let result = SafeFilePath::new(&amp;input);\n    TestResult::from_bool(result.is_err())\n}\n\n#[quickcheck]\nfn prop_tool_name_length_limits(input: String) -&gt; TestResult {\n    let result = ToolName::new(input.clone());\n    \n    if input.is_empty() || input.len() &gt; 100 {\n        TestResult::from_bool(result.is_err())\n    } else {\n        TestResult::from_bool(result.is_ok())\n    }\n}\n\n// Test tool execution properties\n#[quickcheck]\nfn prop_tool_execution_timeout(name: String, args: HashMap&lt;String, Value&gt;) -&gt; TestResult {\n    // Create a slow tool for testing\n    struct SlowTool;\n    \n    #[async_trait::async_trait]\n    impl ToolExecutor for SlowTool {\n        fn name(&amp;self) -&gt; &amp;str { \"slow_tool\" }\n        \n        async fn execute(&amp;self, _args: HashMap&lt;String, Value&gt;) -&gt; Result&lt;ToolResult, McpError&gt; {\n            tokio::time::sleep(Duration::from_secs(10)).await;\n            Ok(ToolResult { content: vec![], is_error: None })\n        }\n    }\n    \n    // Test should complete within reasonable time due to timeout\n    let rt = tokio::runtime::Runtime::new().unwrap();\n    let result = rt.block_on(async {\n        let tool = Arc::new(SlowTool);\n        \n        tokio::time::timeout(\n            Duration::from_secs(1),\n            execute_tool_with_timeout(tool, args, Duration::from_millis(500))\n        ).await\n    });\n    \n    TestResult::from_bool(result.is_ok())\n}\n\nasync fn execute_tool_with_timeout(\n    tool: Arc&lt;dyn ToolExecutor&gt;,\n    args: HashMap&lt;String, Value&gt;,\n    timeout: Duration,\n) -&gt; Result&lt;ToolResult, McpError&gt; {\n    tokio::time::timeout(timeout, tool.execute(args))\n        .await\n        .map_err(|_| McpError::ToolExecution {\n            tool_name: tool.name().to_string(),\n            source: Box::new(std::io::Error::new(\n                std::io::ErrorKind::TimedOut,\n                \"Tool execution timed out\"\n            )),\n        })?\n}\n</code></pre>"},{"location":"develop/rust/best-practices/#fuzzing-integration","title":"Fuzzing Integration","text":"<pre><code>// \u2705 Good: Fuzz testing for security-critical components\n#[cfg(fuzzing)]\npub mod fuzz {\n    use super::*;\n    \n    pub fn fuzz_json_parsing(data: &amp;[u8]) {\n        if let Ok(s) = std::str::from_utf8(data) {\n            let _ = serde_json::from_str::&lt;serde_json::Value&gt;(s);\n        }\n    }\n    \n    pub fn fuzz_tool_arguments(data: &amp;[u8]) {\n        if let Ok(s) = std::str::from_utf8(data) {\n            if let Ok(value) = serde_json::from_str::&lt;serde_json::Value&gt;(s) {\n                if let Ok(map) = serde_json::from_value::&lt;HashMap&lt;String, serde_json::Value&gt;&gt;(value) {\n                    // Test validation doesn't panic\n                    for tool in get_all_tools() {\n                        let _ = tool.validate_arguments(&amp;map);\n                    }\n                }\n            }\n        }\n    }\n    \n    pub fn fuzz_url_validation(data: &amp;[u8]) {\n        if let Ok(s) = std::str::from_utf8(data) {\n            let _ = SafeUrl::new(s, &amp;[\"http\", \"https\"]);\n        }\n    }\n}\n\n// Cargo.toml should include:\n// [dependencies]\n// afl = { version = \"0.12\", optional = true }\n// \n// [features]\n// fuzzing = [\"afl\"]\n</code></pre>"},{"location":"develop/rust/best-practices/#performance-optimization","title":"Performance Optimization","text":""},{"location":"develop/rust/best-practices/#compile-time-optimizations","title":"Compile-Time Optimizations","text":"<pre><code>// \u2705 Good: Compile-time string interning\nuse std::sync::LazyLock;\nuse std::collections::HashMap;\n\nstatic TOOL_SCHEMAS: LazyLock&lt;HashMap&lt;&amp;'static str, serde_json::Value&gt;&gt; = LazyLock::new(|| {\n    let mut schemas = HashMap::new();\n    \n    schemas.insert(\"http_request\", serde_json::json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"url\": {\"type\": \"string\", \"format\": \"uri\"},\n            \"method\": {\"type\": \"string\", \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]}\n        },\n        \"required\": [\"url\"]\n    }));\n    \n    schemas.insert(\"read_file\", serde_json::json!({\n        \"type\": \"object\",\n        \"properties\": {\n            \"path\": {\"type\": \"string\"}\n        },\n        \"required\": [\"path\"]\n    }));\n    \n    schemas\n});\n\n// \u2705 Good: Const generics for compile-time validation\npub struct BoundedString&lt;const MAX_LEN: usize&gt; {\n    value: String,\n}\n\nimpl&lt;const MAX_LEN: usize&gt; BoundedString&lt;MAX_LEN&gt; {\n    pub fn new(value: String) -&gt; Result&lt;Self, McpError&gt; {\n        if value.len() &gt; MAX_LEN {\n            return Err(McpError::ValidationError {\n                field: \"bounded_string\".to_string(),\n                message: format!(\"String too long: {} &gt; {}\", value.len(), MAX_LEN),\n            });\n        }\n        Ok(Self { value })\n    }\n    \n    pub fn as_str(&amp;self) -&gt; &amp;str {\n        &amp;self.value\n    }\n}\n\n// Usage with different bounds\ntype ToolName = BoundedString&lt;100&gt;;\ntype Description = BoundedString&lt;1000&gt;;\n</code></pre> <p>These Rust-specific best practices ensure your MCP server leverages Rust's unique strengths in memory safety, performance, and concurrent programming while maintaining code clarity and maintainability.</p>"},{"location":"develop/rust/building/","title":"Rust Building and Deployment","text":""},{"location":"develop/rust/building/#rust-building-and-deployment","title":"Rust Building and Deployment","text":""},{"location":"develop/rust/building/#building-rust-mcp-servers-for-production","title":"Building Rust MCP Servers for Production","text":"<p>This guide covers building, optimizing, and deploying Rust MCP servers with proper cross-compilation, optimization, and containerization strategies.</p>"},{"location":"develop/rust/building/#build-configuration","title":"Build Configuration","text":""},{"location":"develop/rust/building/#cargotoml-optimization","title":"Cargo.toml Optimization","text":"<pre><code>[package]\nname = \"mcp-server-rust\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# Build profiles\n[profile.release]\n# Enable link-time optimization\nlto = \"fat\"\n# Use only one codegen unit for maximum optimization\ncodegen-units = 1\n# Abort on panic instead of unwinding (smaller binary)\npanic = \"abort\"\n# Strip debug info and symbols\nstrip = true\n# Optimize for size\nopt-level = \"z\"\n\n[profile.dev]\n# Enable debug info for development\ndebug = true\n# Don't optimize for faster builds\nopt-level = 0\n# Enable overflow checks\noverflow-checks = true\n\n# Custom profile for size-optimized release\n[profile.release-size]\ninherits = \"release\"\nopt-level = \"z\"\nlto = \"fat\"\ncodegen-units = 1\npanic = \"abort\"\nstrip = \"symbols\"\n\n# Custom profile for performance-optimized release\n[profile.release-perf]\ninherits = \"release\"\nopt-level = 3\nlto = \"fat\"\ncodegen-units = 1\n</code></pre>"},{"location":"develop/rust/building/#build-scripts-and-automation","title":"Build Scripts and Automation","text":"<pre><code>#!/bin/bash\n# scripts/build.sh\n\nset -e\n\n# Configuration\nBINARY_NAME=\"mcp-server\"\nTARGET_DIR=\"target\"\nDIST_DIR=\"dist\"\n\n# Parse command line arguments\nPROFILE=\"release\"\nTARGET=\"\"\nFEATURES=\"\"\n\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --profile)\n            PROFILE=\"$2\"\n            shift 2\n            ;;\n        --target)\n            TARGET=\"$2\"\n            shift 2\n            ;;\n        --features)\n            FEATURES=\"$2\"\n            shift 2\n            ;;\n        *)\n            echo \"Unknown option $1\"\n            exit 1\n            ;;\n    esac\ndone\n\n# Set build info\nexport BUILD_TIME=$(date -u '+%Y-%m-%dT%H:%M:%SZ')\nexport GIT_COMMIT=$(git rev-parse HEAD 2&gt;/dev/null || echo \"unknown\")\nexport GIT_TAG=$(git describe --tags --exact-match 2&gt;/dev/null || echo \"\")\nexport VERSION=${GIT_TAG:-\"dev\"}\n\necho \"Building ${BINARY_NAME} (profile: ${PROFILE}, version: ${VERSION})\"\n\n# Build command\nCARGO_CMD=\"cargo build --profile ${PROFILE}\"\n\nif [[ -n \"$TARGET\" ]]; then\n    CARGO_CMD=\"${CARGO_CMD} --target ${TARGET}\"\nfi\n\nif [[ -n \"$FEATURES\" ]]; then\n    CARGO_CMD=\"${CARGO_CMD} --features ${FEATURES}\"\nfi\n\n# Execute build\neval $CARGO_CMD\n\n# Create distribution directory\nmkdir -p \"$DIST_DIR\"\n\n# Copy binary to dist\nif [[ -n \"$TARGET\" ]]; then\n    BINARY_PATH=\"${TARGET_DIR}/${TARGET}/${PROFILE}/${BINARY_NAME}\"\n    DIST_BINARY=\"${DIST_DIR}/${BINARY_NAME}-${TARGET}\"\nelse\n    BINARY_PATH=\"${TARGET_DIR}/${PROFILE}/${BINARY_NAME}\"\n    DIST_BINARY=\"${DIST_DIR}/${BINARY_NAME}\"\nfi\n\n# Add .exe extension for Windows\nif [[ \"$TARGET\" == *\"windows\"* ]]; then\n    BINARY_PATH=\"${BINARY_PATH}.exe\"\n    DIST_BINARY=\"${DIST_BINARY}.exe\"\nfi\n\ncp \"$BINARY_PATH\" \"$DIST_BINARY\"\n\necho \"Binary built: $DIST_BINARY\"\n\n# Print binary info\necho \"Binary size: $(du -h $DIST_BINARY | cut -f1)\"\necho \"Binary info:\"\nfile \"$DIST_BINARY\" || true\n</code></pre>"},{"location":"develop/rust/building/#cross-compilation-configuration","title":"Cross-Compilation Configuration","text":"<pre><code># .cargo/config.toml\n[target.x86_64-unknown-linux-gnu]\nlinker = \"x86_64-linux-gnu-gcc\"\n\n[target.x86_64-unknown-linux-musl]\nlinker = \"x86_64-linux-musl-gcc\"\n\n[target.aarch64-unknown-linux-gnu]\nlinker = \"aarch64-linux-gnu-gcc\"\n\n[target.x86_64-pc-windows-gnu]\nlinker = \"x86_64-w64-mingw32-gcc\"\n\n[target.x86_64-apple-darwin]\nlinker = \"x86_64-apple-darwin-clang\"\n\n# Environment variables for build\n[env]\nRUSTFLAGS = \"-C target-cpu=native\"\n</code></pre>"},{"location":"develop/rust/building/#multi-target-build-script","title":"Multi-Target Build Script","text":"<pre><code>#!/bin/bash\n# scripts/build-all.sh\n\nset -e\n\n# Define targets\nTARGETS=(\n    \"x86_64-unknown-linux-gnu\"\n    \"x86_64-unknown-linux-musl\" \n    \"aarch64-unknown-linux-gnu\"\n    \"x86_64-pc-windows-gnu\"\n    \"x86_64-apple-darwin\"\n    \"aarch64-apple-darwin\"\n)\n\nBINARY_NAME=\"mcp-server\"\nFEATURES=\"database,metrics\"\n\n# Install targets if not already installed\necho \"Installing Rust targets...\"\nfor target in \"${TARGETS[@]}\"; do\n    rustup target add \"$target\" || true\ndone\n\n# Build for each target\nfor target in \"${TARGETS[@]}\"; do\n    echo \"Building for $target...\"\n    \n    # Skip targets that require special setup\n    if [[ \"$target\" == *\"windows\"* ]] &amp;&amp; ! command -v x86_64-w64-mingw32-gcc &amp;&gt; /dev/null; then\n        echo \"Skipping $target (mingw-w64 not installed)\"\n        continue\n    fi\n    \n    if [[ \"$target\" == *\"apple\"* ]] &amp;&amp; [[ \"$OSTYPE\" != \"darwin\"* ]]; then\n        echo \"Skipping $target (requires macOS)\"\n        continue\n    fi\n    \n    # Static linking for musl\n    if [[ \"$target\" == *\"musl\"* ]]; then\n        export RUSTFLAGS=\"-C target-feature=+crt-static\"\n    else\n        export RUSTFLAGS=\"\"\n    fi\n    \n    cargo build \\\n        --profile release-size \\\n        --target \"$target\" \\\n        --features \"$FEATURES\" \\\n        --locked\n    \n    # Copy to dist directory\n    mkdir -p \"dist/$target\"\n    \n    BINARY_SRC=\"target/$target/release-size/$BINARY_NAME\"\n    BINARY_DEST=\"dist/$target/$BINARY_NAME\"\n    \n    if [[ \"$target\" == *\"windows\"* ]]; then\n        BINARY_SRC=\"${BINARY_SRC}.exe\"\n        BINARY_DEST=\"${BINARY_DEST}.exe\"\n    fi\n    \n    cp \"$BINARY_SRC\" \"$BINARY_DEST\"\n    \n    echo \"Built: $BINARY_DEST ($(du -h $BINARY_DEST | cut -f1))\"\ndone\n\necho \"All builds completed!\"\nls -la dist/*/\n</code></pre>"},{"location":"develop/rust/building/#container-building","title":"Container Building","text":""},{"location":"develop/rust/building/#multi-stage-dockerfile","title":"Multi-Stage Dockerfile","text":"<pre><code># Multi-stage Dockerfile for Rust MCP server\nFROM rust:1.75-slim as builder\n\n# Install build dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    pkg-config \\\n    libssl-dev \\\n    ca-certificates \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Create app user\nRUN useradd -m -u 1001 appuser\n\nWORKDIR /app\n\n# Copy manifests\nCOPY Cargo.toml Cargo.lock ./\n\n# Create dummy main to cache dependencies\nRUN mkdir src &amp;&amp; \\\n    echo \"fn main() {}\" &gt; src/main.rs &amp;&amp; \\\n    echo '' &gt; src/lib.rs\n\n# Build dependencies (this layer will be cached)\nRUN cargo build --profile release-size --locked\nRUN rm src/*.rs\n\n# Copy source code\nCOPY src ./src\n\n# Build arguments for versioning\nARG VERSION=dev\nARG BUILD_TIME\nARG GIT_COMMIT\n\n# Build the actual application\nRUN touch src/main.rs &amp;&amp; \\\n    cargo build --profile release-size --locked\n\n# Runtime stage\nFROM debian:bookworm-slim\n\n# Install runtime dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    ca-certificates \\\n    libssl3 \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Create app user\nRUN useradd -m -u 1001 appuser\n\n# Copy the binary from builder stage\nCOPY --from=builder /app/target/release-size/mcp-server /usr/local/bin/mcp-server\n\n# Set ownership\nRUN chown appuser:appuser /usr/local/bin/mcp-server\n\n# Switch to non-root user\nUSER appuser\n\n# Create directories\nWORKDIR /home/appuser\nRUN mkdir -p logs data config\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n    CMD /usr/local/bin/mcp-server --version || exit 1\n\nEXPOSE 8000\n\n# Default command\nCMD [\"mcp-server\", \"--config\", \"/home/appuser/config/config.yaml\"]\n</code></pre>"},{"location":"develop/rust/building/#optimized-dockerfile-with-static-binary","title":"Optimized Dockerfile with Static Binary","text":"<pre><code># Static binary Dockerfile\nFROM rust:1.75-alpine as builder\n\n# Install musl development tools\nRUN apk add --no-cache musl-dev pkgconfig openssl-dev openssl-libs-static\n\nWORKDIR /app\n\n# Copy manifests\nCOPY Cargo.toml Cargo.lock ./\n\n# Copy source\nCOPY src ./src\n\n# Build static binary\nENV RUSTFLAGS=\"-C target-feature=+crt-static\"\nRUN cargo build \\\n    --profile release-size \\\n    --target x86_64-unknown-linux-musl \\\n    --locked\n\n# Runtime stage - using scratch for minimal image\nFROM scratch\n\n# Copy CA certificates\nCOPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/\n\n# Copy the static binary\nCOPY --from=builder /app/target/x86_64-unknown-linux-musl/release-size/mcp-server /mcp-server\n\n# Create minimal filesystem\nCOPY --from=builder /etc/passwd /etc/passwd\nCOPY --from=builder /etc/group /etc/group\n\n# Use non-root user (create entry in builder stage if needed)\nUSER 1001:1001\n\nEXPOSE 8000\n\nENTRYPOINT [\"/mcp-server\"]\n</code></pre>"},{"location":"develop/rust/building/#docker-compose-for-development","title":"Docker Compose for Development","text":"<pre><code># docker-compose.dev.yml\nversion: '3.8'\n\nservices:\n  mcp-server:\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    ports:\n      - \"8000:8000\"\n    environment:\n      - RUST_LOG=debug\n      - DATABASE_URL=postgres://postgres:password@postgres:5432/mcp_dev\n    volumes:\n      - .:/app\n      - cargo-cache:/usr/local/cargo/registry\n      - target-cache:/app/target\n    depends_on:\n      - postgres\n    command: cargo watch -x 'run --bin mcp-server'\n\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: mcp_dev\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: password\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  cargo-cache:\n  target-cache:\n  postgres_data:\n</code></pre>"},{"location":"develop/rust/building/#development-dockerfile","title":"Development Dockerfile","text":"<pre><code># Dockerfile.dev - for development with hot reload\nFROM rust:1.75-slim\n\n# Install development dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    pkg-config \\\n    libssl-dev \\\n    ca-certificates \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install cargo-watch for hot reloading\nRUN cargo install cargo-watch\n\nWORKDIR /app\n\n# Copy manifests\nCOPY Cargo.toml Cargo.lock ./\n\n# Pre-build dependencies\nRUN mkdir src &amp;&amp; \\\n    echo \"fn main() {}\" &gt; src/main.rs &amp;&amp; \\\n    cargo build &amp;&amp; \\\n    rm -rf src\n\n# Expose port\nEXPOSE 8000\n\n# Default command for development\nCMD [\"cargo\", \"watch\", \"-x\", \"run\"]\n</code></pre>"},{"location":"develop/rust/building/#github-actions-cicd","title":"GitHub Actions CI/CD","text":""},{"location":"develop/rust/building/#complete-build-pipeline","title":"Complete Build Pipeline","text":"<pre><code># .github/workflows/build.yml\nname: Build and Release\n\non:\n  push:\n    branches: [main]\n    tags: ['v*']\n  pull_request:\n    branches: [main]\n\nenv:\n  CARGO_TERM_COLOR: always\n\njobs:\n  test:\n    name: Test Suite\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Install Rust\n      uses: dtolnay/rust-toolchain@stable\n      with:\n        components: rustfmt, clippy\n    \n    - name: Cache dependencies\n      uses: actions/cache@v3\n      with:\n        path: |\n          ~/.cargo/registry\n          ~/.cargo/git\n          target\n        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n    \n    - name: Check formatting\n      run: cargo fmt -- --check\n    \n    - name: Run clippy\n      run: cargo clippy -- -D warnings\n    \n    - name: Run tests\n      run: cargo test --all-features\n\n  build:\n    name: Build Release\n    needs: test\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        include:\n          - os: ubuntu-latest\n            target: x86_64-unknown-linux-gnu\n          - os: ubuntu-latest\n            target: x86_64-unknown-linux-musl\n          - os: ubuntu-latest\n            target: aarch64-unknown-linux-gnu\n          - os: windows-latest\n            target: x86_64-pc-windows-msvc\n          - os: macos-latest\n            target: x86_64-apple-darwin\n          - os: macos-latest\n            target: aarch64-apple-darwin\n\n    steps:\n    - uses: actions/checkout@v4\n      with:\n        fetch-depth: 0\n    \n    - name: Install Rust\n      uses: dtolnay/rust-toolchain@stable\n      with:\n        targets: ${{ matrix.target }}\n    \n    - name: Install cross-compilation tools\n      if: matrix.target == 'aarch64-unknown-linux-gnu'\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y gcc-aarch64-linux-gnu\n    \n    - name: Install musl tools\n      if: matrix.target == 'x86_64-unknown-linux-musl'\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y musl-tools\n    \n    - name: Cache dependencies\n      uses: actions/cache@v3\n      with:\n        path: |\n          ~/.cargo/registry\n          ~/.cargo/git\n          target\n        key: ${{ runner.os }}-${{ matrix.target }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n    \n    - name: Build binary\n      run: |\n        cargo build --profile release-size --target ${{ matrix.target }} --locked\n    \n    - name: Package binary\n      shell: bash\n      run: |\n        VERSION=${GITHUB_REF#refs/tags/}\n        if [[ \"$VERSION\" == \"refs/heads/main\" ]]; then\n          VERSION=\"main-$(git rev-parse --short HEAD)\"\n        fi\n        \n        BINARY_NAME=\"mcp-server\"\n        if [[ \"${{ matrix.target }}\" == *\"windows\"* ]]; then\n          BINARY_NAME=\"${BINARY_NAME}.exe\"\n        fi\n        \n        ARCHIVE_NAME=\"mcp-server-${VERSION}-${{ matrix.target }}\"\n        \n        mkdir -p dist\n        cp target/${{ matrix.target }}/release-size/${BINARY_NAME} dist/\n        \n        cd dist\n        if [[ \"${{ matrix.target }}\" == *\"windows\"* ]]; then\n          7z a ${ARCHIVE_NAME}.zip ${BINARY_NAME}\n        else\n          tar czf ${ARCHIVE_NAME}.tar.gz ${BINARY_NAME}\n        fi\n    \n    - name: Upload artifacts\n      uses: actions/upload-artifact@v3\n      with:\n        name: binaries-${{ matrix.target }}\n        path: dist/*\n\n  docker:\n    name: Build Docker Image\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')\n    \n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v3\n    \n    - name: Login to DockerHub\n      uses: docker/login-action@v3\n      with:\n        username: ${{ secrets.DOCKER_USERNAME }}\n        password: ${{ secrets.DOCKER_PASSWORD }}\n    \n    - name: Extract metadata\n      id: meta\n      uses: docker/metadata-action@v5\n      with:\n        images: your-org/mcp-server-rust\n        tags: |\n          type=ref,event=branch\n          type=ref,event=pr\n          type=semver,pattern={{version}}\n          type=semver,pattern={{major}}.{{minor}}\n    \n    - name: Build and push\n      uses: docker/build-push-action@v5\n      with:\n        context: .\n        push: true\n        tags: ${{ steps.meta.outputs.tags }}\n        labels: ${{ steps.meta.outputs.labels }}\n        build-args: |\n          VERSION=${{ steps.meta.outputs.version }}\n          BUILD_TIME=${{ steps.meta.outputs.date }}\n          GIT_COMMIT=${{ github.sha }}\n\n  release:\n    name: Create Release\n    needs: [test, build]\n    runs-on: ubuntu-latest\n    if: startsWith(github.ref, 'refs/tags/')\n    \n    steps:\n    - name: Download artifacts\n      uses: actions/download-artifact@v3\n    \n    - name: Create release\n      uses: softprops/action-gh-release@v1\n      with:\n        files: |\n          binaries-*/mcp-server-*\n        generate_release_notes: true\n        draft: false\n        prerelease: false\n</code></pre>"},{"location":"develop/rust/building/#binary-optimization-techniques","title":"Binary Optimization Techniques","text":""},{"location":"develop/rust/building/#size-optimization-script","title":"Size Optimization Script","text":"<pre><code>#!/bin/bash\n# scripts/optimize.sh\n\nset -e\n\nBINARY_NAME=\"mcp-server\"\nBINARY_PATH=\"target/release-size/$BINARY_NAME\"\n\necho \"Original binary size:\"\nls -lh \"$BINARY_PATH\"\n\n# Strip additional symbols\necho \"Stripping symbols...\"\nstrip \"$BINARY_PATH\"\n\necho \"Stripped binary size:\"\nls -lh \"$BINARY_PATH\"\n\n# Compress with UPX (optional)\nif command -v upx &amp;&gt; /dev/null; then\n    echo \"Compressing with UPX...\"\n    cp \"$BINARY_PATH\" \"${BINARY_PATH}.backup\"\n    upx --best \"$BINARY_PATH\"\n    \n    echo \"Compressed binary size:\"\n    ls -lh \"$BINARY_PATH\"\n    \n    echo \"Testing compressed binary...\"\n    if ! \"$BINARY_PATH\" --version; then\n        echo \"Compressed binary is corrupted, restoring backup\"\n        mv \"${BINARY_PATH}.backup\" \"$BINARY_PATH\"\n    else\n        rm -f \"${BINARY_PATH}.backup\"\n        echo \"Compression successful\"\n    fi\nfi\n\n# Analyze binary\necho \"Binary analysis:\"\nfile \"$BINARY_PATH\"\n\nif command -v bloaty &amp;&gt; /dev/null; then\n    echo \"Size breakdown:\"\n    bloaty \"$BINARY_PATH\"\nfi\n</code></pre>"},{"location":"develop/rust/building/#performance-profiling","title":"Performance Profiling","text":"<pre><code>#!/bin/bash\n# scripts/profile.sh\n\nBINARY_NAME=\"mcp-server\"\n\n# Build with profiling enabled\necho \"Building with profiling...\"\nRUSTFLAGS=\"-C profile-generate=/tmp/pgo-data\" \\\n    cargo build --release --target-dir target/pgo\n\n# Run training workload\necho \"Running training workload...\"\n./target/pgo/release/$BINARY_NAME --config config/profile.yaml &amp;\nSERVER_PID=$!\n\n# Generate some load\nsleep 2\ncurl http://localhost:8000/health\n# Add more representative workload here\n\nkill $SERVER_PID\nwait\n\n# Build optimized binary\necho \"Building optimized binary...\"\nRUSTFLAGS=\"-C profile-use=/tmp/pgo-data -C llvm-args=-pgo-warn-missing-function\" \\\n    cargo build --release --target-dir target/pgo-optimized\n\necho \"PGO optimization complete\"\nls -lh target/pgo-optimized/release/$BINARY_NAME\n</code></pre> <p>This comprehensive Rust building guide ensures your MCP server is optimized, cross-platform compatible, and ready for production deployment with minimal resource usage and maximum performance.</p>"},{"location":"develop/rust/implementation/","title":"Rust Implementation Guide","text":""},{"location":"develop/rust/implementation/#rust-implementation-guide","title":"Rust Implementation Guide","text":""},{"location":"develop/rust/implementation/#building-mcp-servers-in-rust","title":"Building MCP Servers in Rust","text":"<p>This guide covers implementation patterns, best practices, and examples for building robust MCP servers using Rust's type system and async capabilities.</p>"},{"location":"develop/rust/implementation/#core-mcp-types","title":"Core MCP Types","text":"<pre><code>// src/mcp/types.rs\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// MCP protocol version\npub const MCP_VERSION: &amp;str = \"2024-11-05\";\n\n/// JSON-RPC 2.0 request\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Request {\n    pub jsonrpc: String,\n    pub id: Option&lt;serde_json::Value&gt;,\n    pub method: String,\n    pub params: Option&lt;serde_json::Value&gt;,\n}\n\n/// JSON-RPC 2.0 response\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Response {\n    pub jsonrpc: String,\n    pub id: Option&lt;serde_json::Value&gt;,\n    #[serde(flatten)]\n    pub result: ResponseResult,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum ResponseResult {\n    Success { result: serde_json::Value },\n    Error { error: ErrorObject },\n}\n\n/// JSON-RPC error object\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ErrorObject {\n    pub code: i32,\n    pub message: String,\n    pub data: Option&lt;serde_json::Value&gt;,\n}\n\n/// Tool definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Tool {\n    pub name: String,\n    pub description: String,\n    #[serde(rename = \"inputSchema\")]\n    pub input_schema: serde_json::Value,\n}\n\n/// Tool execution result\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolResult {\n    pub content: Vec&lt;Content&gt;,\n    #[serde(rename = \"isError\", skip_serializing_if = \"Option::is_none\")]\n    pub is_error: Option&lt;bool&gt;,\n}\n\n/// Content types\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum Content {\n    #[serde(rename = \"text\")]\n    Text { text: String },\n    #[serde(rename = \"image\")]\n    Image { data: String, mime_type: String },\n    #[serde(rename = \"resource\")]\n    Resource { resource: ResourceContent },\n}\n\n/// Resource definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Resource {\n    pub uri: String,\n    pub name: String,\n    pub description: Option&lt;String&gt;,\n    #[serde(rename = \"mimeType\", skip_serializing_if = \"Option::is_none\")]\n    pub mime_type: Option&lt;String&gt;,\n}\n\n/// Resource content\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourceContent {\n    pub uri: String,\n    #[serde(rename = \"mimeType\")]\n    pub mime_type: String,\n    pub text: Option&lt;String&gt;,\n    pub blob: Option&lt;String&gt;,\n}\n</code></pre>"},{"location":"develop/rust/implementation/#tool-implementation-framework","title":"Tool Implementation Framework","text":"<pre><code>// src/tools/mod.rs\nuse async_trait::async_trait;\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse crate::{\n    mcp::types::{Content, Tool, ToolResult},\n    error::Result,\n};\n\n/// Tool execution trait\n#[async_trait]\npub trait ToolExecutor: Send + Sync {\n    /// Get tool definition\n    fn definition(&amp;self) -&gt; Tool;\n    \n    /// Execute the tool with given arguments\n    async fn execute(\n        &amp;self,\n        arguments: HashMap&lt;String, Value&gt;,\n    ) -&gt; Result&lt;ToolResult&gt;;\n    \n    /// Get tool name\n    fn name(&amp;self) -&gt; &amp;str;\n    \n    /// Validate arguments before execution\n    fn validate_arguments(&amp;self, arguments: &amp;HashMap&lt;String, Value&gt;) -&gt; Result&lt;()&gt; {\n        // Default implementation - tools can override\n        Ok(())\n    }\n}\n\n/// Tool registry for managing available tools\npub struct ToolRegistry {\n    tools: HashMap&lt;String, Arc&lt;dyn ToolExecutor&gt;&gt;,\n}\n\nimpl ToolRegistry {\n    pub fn new() -&gt; Self {\n        Self {\n            tools: HashMap::new(),\n        }\n    }\n    \n    /// Register a tool\n    pub fn register&lt;T&gt;(&amp;mut self, tool: T) \n    where \n        T: ToolExecutor + 'static \n    {\n        let name = tool.name().to_string();\n        self.tools.insert(name, Arc::new(tool));\n    }\n    \n    /// Get all available tools\n    pub fn list_tools(&amp;self) -&gt; Vec&lt;Tool&gt; {\n        self.tools.values()\n            .map(|tool| tool.definition())\n            .collect()\n    }\n    \n    /// Execute a tool by name\n    pub async fn execute_tool(\n        &amp;self,\n        name: &amp;str,\n        arguments: HashMap&lt;String, Value&gt;,\n    ) -&gt; Result&lt;ToolResult&gt; {\n        let tool = self.tools.get(name)\n            .ok_or_else(|| crate::Error::not_found(format!(\"Tool not found: {}\", name)))?;\n        \n        // Validate arguments\n        tool.validate_arguments(&amp;arguments)?;\n        \n        // Execute tool\n        tool.execute(arguments).await\n    }\n    \n    /// Check if tool exists\n    pub fn has_tool(&amp;self, name: &amp;str) -&gt; bool {\n        self.tools.contains_key(name)\n    }\n}\n</code></pre>"},{"location":"develop/rust/implementation/#database-tool-implementation","title":"Database Tool Implementation","text":"<pre><code>// src/tools/database.rs\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\nuse sqlx::{PgPool, Row};\nuse std::collections::HashMap;\nuse tracing::{info, warn};\n\nuse crate::{\n    mcp::types::{Content, Tool, ToolResult},\n    tools::ToolExecutor,\n    error::{Result, Error},\n    config::DatabaseToolConfig,\n};\n\n/// Database query tool\npub struct DatabaseTool {\n    pool: PgPool,\n    config: DatabaseToolConfig,\n}\n\nimpl DatabaseTool {\n    pub async fn new(database_url: &amp;str, config: DatabaseToolConfig) -&gt; Result&lt;Self&gt; {\n        let pool = PgPool::connect(database_url).await?;\n        \n        Ok(Self { pool, config })\n    }\n    \n    fn validate_query(&amp;self, query: &amp;str) -&gt; Result&lt;()&gt; {\n        let query_upper = query.trim().to_uppercase();\n        \n        // Only allow SELECT statements if read_only is true\n        if self.config.read_only &amp;&amp; !query_upper.starts_with(\"SELECT\") {\n            return Err(Error::permission_denied(\n                \"Only SELECT statements are allowed in read-only mode\"\n            ));\n        }\n        \n        // Block dangerous operations\n        let dangerous_keywords = [\n            \"DROP\", \"DELETE\", \"INSERT\", \"UPDATE\", \"ALTER\", \n            \"CREATE\", \"TRUNCATE\", \"REPLACE\", \"MERGE\"\n        ];\n        \n        for keyword in &amp;dangerous_keywords {\n            if query_upper.contains(keyword) &amp;&amp; self.config.read_only {\n                return Err(Error::permission_denied(\n                    format!(\"Query contains forbidden keyword: {}\", keyword)\n                ));\n            }\n        }\n        \n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl ToolExecutor for DatabaseTool {\n    fn definition(&amp;self) -&gt; Tool {\n        Tool {\n            name: \"query_database\".to_string(),\n            description: \"Execute SQL queries against the database\".to_string(),\n            input_schema: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"query\": {\n                        \"type\": \"string\",\n                        \"description\": \"SQL query to execute\"\n                    },\n                    \"limit\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Maximum number of rows to return\",\n                        \"default\": self.config.max_rows,\n                        \"minimum\": 1,\n                        \"maximum\": self.config.max_rows\n                    }\n                },\n                \"required\": [\"query\"]\n            }),\n        }\n    }\n    \n    fn name(&amp;self) -&gt; &amp;str {\n        \"query_database\"\n    }\n    \n    fn validate_arguments(&amp;self, arguments: &amp;HashMap&lt;String, Value&gt;) -&gt; Result&lt;()&gt; {\n        let query = arguments.get(\"query\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| Error::validation(\"query parameter is required and must be a string\"))?;\n        \n        self.validate_query(query)?;\n        \n        if let Some(limit) = arguments.get(\"limit\") {\n            let limit = limit.as_u64()\n                .ok_or_else(|| Error::validation(\"limit must be a positive integer\"))?;\n                \n            if limit &gt; self.config.max_rows as u64 {\n                return Err(Error::validation(\n                    format!(\"limit cannot exceed {}\", self.config.max_rows)\n                ));\n            }\n        }\n        \n        Ok(())\n    }\n    \n    async fn execute(&amp;self, arguments: HashMap&lt;String, Value&gt;) -&gt; Result&lt;ToolResult&gt; {\n        let query = arguments[\"query\"].as_str().unwrap();\n        let limit = arguments.get(\"limit\")\n            .and_then(|v| v.as_u64())\n            .unwrap_or(self.config.max_rows as u64) as i64;\n        \n        info!(\"Executing database query: {}\", query);\n        \n        // Add LIMIT clause if not present\n        let final_query = if query.to_uppercase().contains(\"LIMIT\") {\n            query.to_string()\n        } else {\n            format!(\"{} LIMIT {}\", query, limit)\n        };\n        \n        // Execute query with timeout\n        let rows = tokio::time::timeout(\n            std::time::Duration::from_secs(self.config.timeout),\n            sqlx::query(&amp;final_query).fetch_all(&amp;self.pool)\n        ).await\n        .map_err(|_| Error::internal(\"Query timeout\"))?\n        .map_err(|e| Error::tool_error(\"query_database\", e.to_string()))?;\n        \n        // Convert rows to JSON\n        let mut results = Vec::new();\n        for row in rows {\n            let mut row_map = serde_json::Map::new();\n            \n            for (i, column) in row.columns().iter().enumerate() {\n                let column_name = column.name();\n                let value: Value = match column.type_info().name() {\n                    \"TEXT\" | \"VARCHAR\" | \"CHAR\" =&gt; {\n                        row.try_get::&lt;Option&lt;String&gt;, _&gt;(i)\n                            .map(|v| v.map(Value::String).unwrap_or(Value::Null))\n                            .unwrap_or(Value::Null)\n                    }\n                    \"INTEGER\" | \"INT4\" | \"INT8\" | \"BIGINT\" =&gt; {\n                        row.try_get::&lt;Option&lt;i64&gt;, _&gt;(i)\n                            .map(|v| v.map(|n| Value::Number(n.into())).unwrap_or(Value::Null))\n                            .unwrap_or(Value::Null)\n                    }\n                    \"REAL\" | \"FLOAT4\" | \"FLOAT8\" | \"DOUBLE\" =&gt; {\n                        row.try_get::&lt;Option&lt;f64&gt;, _&gt;(i)\n                            .map(|v| v.and_then(|n| serde_json::Number::from_f64(n).map(Value::Number)).unwrap_or(Value::Null))\n                            .unwrap_or(Value::Null)\n                    }\n                    \"BOOLEAN\" | \"BOOL\" =&gt; {\n                        row.try_get::&lt;Option&lt;bool&gt;, _&gt;(i)\n                            .map(|v| v.map(Value::Bool).unwrap_or(Value::Null))\n                            .unwrap_or(Value::Null)\n                    }\n                    _ =&gt; Value::Null, // Fallback for unsupported types\n                };\n                \n                row_map.insert(column_name.to_string(), value);\n            }\n            \n            results.push(Value::Object(row_map));\n        }\n        \n        let results_json = serde_json::to_string_pretty(&amp;results)\n            .map_err(|e| Error::internal(format!(\"Failed to serialize results: {}\", e)))?;\n        \n        Ok(ToolResult {\n            content: vec![Content::Text { text: results_json }],\n            is_error: None,\n        })\n    }\n}\n</code></pre>"},{"location":"develop/rust/implementation/#http-client-tool","title":"HTTP Client Tool","text":"<pre><code>// src/tools/http.rs\nuse async_trait::async_trait;\nuse reqwest::{Client, Method, Url};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse std::time::Duration;\nuse tracing::{info, warn};\n\nuse crate::{\n    mcp::types::{Content, Tool, ToolResult},\n    tools::ToolExecutor,\n    error::{Result, Error},\n    config::HttpToolConfig,\n};\n\n/// HTTP request tool\npub struct HttpTool {\n    client: Client,\n    config: HttpToolConfig,\n}\n\nimpl HttpTool {\n    pub fn new(config: HttpToolConfig) -&gt; Result&lt;Self&gt; {\n        let client = Client::builder()\n            .timeout(Duration::from_secs(config.timeout))\n            .build()\n            .map_err(|e| Error::internal(format!(\"Failed to create HTTP client: {}\", e)))?;\n        \n        Ok(Self { client, config })\n    }\n    \n    fn validate_url(&amp;self, url: &amp;str) -&gt; Result&lt;Url&gt; {\n        let parsed_url = Url::parse(url)\n            .map_err(|e| Error::validation(format!(\"Invalid URL: {}\", e)))?;\n        \n        // Check scheme\n        if !matches!(parsed_url.scheme(), \"http\" | \"https\") {\n            return Err(Error::validation(\"URL must use http or https scheme\"));\n        }\n        \n        // Check allowed/blocked domains\n        if let Some(host) = parsed_url.host_str() {\n            if let Some(blocked) = &amp;self.config.blocked_domains {\n                if blocked.iter().any(|domain| host.contains(domain)) {\n                    return Err(Error::permission_denied(\n                        format!(\"Domain {} is blocked\", host)\n                    ));\n                }\n            }\n            \n            if let Some(allowed) = &amp;self.config.allowed_domains {\n                if !allowed.iter().any(|domain| host.contains(domain)) {\n                    return Err(Error::permission_denied(\n                        format!(\"Domain {} is not allowed\", host)\n                    ));\n                }\n            }\n        }\n        \n        Ok(parsed_url)\n    }\n}\n\n#[async_trait]\nimpl ToolExecutor for HttpTool {\n    fn definition(&amp;self) -&gt; Tool {\n        Tool {\n            name: \"http_request\".to_string(),\n            description: \"Make HTTP requests to external APIs\".to_string(),\n            input_schema: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"method\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\"],\n                        \"description\": \"HTTP method to use\",\n                        \"default\": \"GET\"\n                    },\n                    \"url\": {\n                        \"type\": \"string\",\n                        \"description\": \"URL to make the request to\",\n                        \"format\": \"uri\"\n                    },\n                    \"headers\": {\n                        \"type\": \"object\",\n                        \"description\": \"HTTP headers to include\",\n                        \"additionalProperties\": {\"type\": \"string\"}\n                    },\n                    \"body\": {\n                        \"type\": \"string\",\n                        \"description\": \"Request body (for POST/PUT/PATCH requests)\"\n                    },\n                    \"timeout\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Request timeout in seconds\",\n                        \"default\": self.config.timeout,\n                        \"minimum\": 1,\n                        \"maximum\": 300\n                    }\n                },\n                \"required\": [\"url\"]\n            }),\n        }\n    }\n    \n    fn name(&amp;self) -&gt; &amp;str {\n        \"http_request\"\n    }\n    \n    fn validate_arguments(&amp;self, arguments: &amp;HashMap&lt;String, Value&gt;) -&gt; Result&lt;()&gt; {\n        let url = arguments.get(\"url\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| Error::validation(\"url parameter is required and must be a string\"))?;\n        \n        self.validate_url(url)?;\n        \n        if let Some(method) = arguments.get(\"method\") {\n            let method_str = method.as_str()\n                .ok_or_else(|| Error::validation(\"method must be a string\"))?;\n                \n            if !matches!(method_str, \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\") {\n                return Err(Error::validation(\"Invalid HTTP method\"));\n            }\n        }\n        \n        if let Some(timeout) = arguments.get(\"timeout\") {\n            let timeout = timeout.as_u64()\n                .ok_or_else(|| Error::validation(\"timeout must be a positive integer\"))?;\n                \n            if timeout &gt; 300 {\n                return Err(Error::validation(\"timeout cannot exceed 300 seconds\"));\n            }\n        }\n        \n        Ok(())\n    }\n    \n    async fn execute(&amp;self, arguments: HashMap&lt;String, Value&gt;) -&gt; Result&lt;ToolResult&gt; {\n        let url = self.validate_url(arguments[\"url\"].as_str().unwrap())?;\n        \n        let method_str = arguments.get(\"method\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"GET\");\n            \n        let method = method_str.parse::&lt;Method&gt;()\n            .map_err(|e| Error::validation(format!(\"Invalid method: {}\", e)))?;\n        \n        info!(\"Making {} request to {}\", method, url);\n        \n        let mut request = self.client.request(method, url.clone());\n        \n        // Add headers\n        if let Some(headers) = arguments.get(\"headers\").and_then(|v| v.as_object()) {\n            for (key, value) in headers {\n                if let Some(value_str) = value.as_str() {\n                    request = request.header(key, value_str);\n                }\n            }\n        }\n        \n        // Add body if present\n        if let Some(body) = arguments.get(\"body\").and_then(|v| v.as_str()) {\n            request = request.body(body.to_string());\n            \n            // Set content-type if not already set\n            if !arguments.get(\"headers\")\n                .and_then(|v| v.as_object())\n                .map(|h| h.contains_key(\"content-type\") || h.contains_key(\"Content-Type\"))\n                .unwrap_or(false)\n            {\n                request = request.header(\"content-type\", \"application/json\");\n            }\n        }\n        \n        // Set timeout if specified\n        if let Some(timeout) = arguments.get(\"timeout\").and_then(|v| v.as_u64()) {\n            request = request.timeout(Duration::from_secs(timeout));\n        }\n        \n        // Execute request\n        let response = request.send().await\n            .map_err(|e| Error::tool_error(\"http_request\", e.to_string()))?;\n        \n        let status = response.status();\n        let headers: HashMap&lt;String, String&gt; = response.headers()\n            .iter()\n            .map(|(k, v)| (k.to_string(), v.to_str().unwrap_or(\"\").to_string()))\n            .collect();\n        \n        // Read response body with size limit\n        let body_bytes = response.bytes().await\n            .map_err(|e| Error::tool_error(\"http_request\", e.to_string()))?;\n        \n        if body_bytes.len() &gt; self.config.max_response_size as usize {\n            warn!(\"Response body too large: {} bytes\", body_bytes.len());\n            return Err(Error::tool_error(\"http_request\", \n                format!(\"Response body too large: {} bytes\", body_bytes.len())));\n        }\n        \n        let body = String::from_utf8_lossy(&amp;body_bytes).into_owned();\n        \n        let result = json!({\n            \"status_code\": status.as_u16(),\n            \"status\": status.to_string(),\n            \"headers\": headers,\n            \"body\": body,\n            \"url\": url.to_string()\n        });\n        \n        let result_text = serde_json::to_string_pretty(&amp;result)\n            .map_err(|e| Error::internal(format!(\"Failed to serialize response: {}\", e)))?;\n        \n        Ok(ToolResult {\n            content: vec![Content::Text { text: result_text }],\n            is_error: Some(status.is_client_error() || status.is_server_error()),\n        })\n    }\n}\n</code></pre>"},{"location":"develop/rust/implementation/#file-system-tool","title":"File System Tool","text":"<pre><code>// src/tools/filesystem.rs\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse tokio::fs;\nuse tracing::{info, warn};\n\nuse crate::{\n    mcp::types::{Content, Tool, ToolResult},\n    tools::ToolExecutor,\n    error::{Result, Error},\n    config::FilesystemToolConfig,\n};\n\n/// Filesystem operations tool\npub struct FilesystemTool {\n    config: FilesystemToolConfig,\n}\n\nimpl FilesystemTool {\n    pub fn new(config: FilesystemToolConfig) -&gt; Self {\n        Self { config }\n    }\n    \n    fn validate_path(&amp;self, path: &amp;str) -&gt; Result&lt;PathBuf&gt; {\n        // Prevent path traversal\n        if path.contains(\"..\") {\n            return Err(Error::permission_denied(\"Path traversal not allowed\"));\n        }\n        \n        let path_buf = PathBuf::from(path);\n        let canonical_path = path_buf.canonicalize()\n            .map_err(|_| Error::not_found(format!(\"Path does not exist: {}\", path)))?;\n        \n        // Check if path is within allowed directories\n        let mut allowed = false;\n        for allowed_path in &amp;self.config.allowed_paths {\n            let allowed_canonical = PathBuf::from(allowed_path).canonicalize()\n                .map_err(|_| Error::internal(format!(\"Invalid allowed path: {}\", allowed_path)))?;\n            \n            if canonical_path.starts_with(&amp;allowed_canonical) {\n                allowed = true;\n                break;\n            }\n        }\n        \n        if !allowed {\n            return Err(Error::permission_denied(\n                format!(\"Path not in allowed directories: {}\", path)\n            ));\n        }\n        \n        Ok(canonical_path)\n    }\n}\n\n#[async_trait]\nimpl ToolExecutor for FilesystemTool {\n    fn definition(&amp;self) -&gt; Tool {\n        let mut operations = vec![\"read_file\", \"list_directory\"];\n        if !self.config.read_only {\n            operations.extend_from_slice(&amp;[\"write_file\", \"create_directory\", \"delete_file\"]);\n        }\n        \n        Tool {\n            name: \"filesystem\".to_string(),\n            description: \"Perform filesystem operations\".to_string(),\n            input_schema: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"operation\": {\n                        \"type\": \"string\",\n                        \"enum\": operations,\n                        \"description\": \"Filesystem operation to perform\"\n                    },\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"File or directory path\"\n                    },\n                    \"content\": {\n                        \"type\": \"string\",\n                        \"description\": \"Content to write (for write_file operation)\"\n                    }\n                },\n                \"required\": [\"operation\", \"path\"]\n            }),\n        }\n    }\n    \n    fn name(&amp;self) -&gt; &amp;str {\n        \"filesystem\"\n    }\n    \n    fn validate_arguments(&amp;self, arguments: &amp;HashMap&lt;String, Value&gt;) -&gt; Result&lt;()&gt; {\n        let operation = arguments.get(\"operation\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| Error::validation(\"operation parameter is required\"))?;\n        \n        let path = arguments.get(\"path\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| Error::validation(\"path parameter is required\"))?;\n        \n        self.validate_path(path)?;\n        \n        // Check if write operations are allowed\n        if self.config.read_only &amp;&amp; matches!(operation, \"write_file\" | \"create_directory\" | \"delete_file\") {\n            return Err(Error::permission_denied(\n                format!(\"Operation {} not allowed in read-only mode\", operation)\n            ));\n        }\n        \n        // Validate content for write operations\n        if operation == \"write_file\" &amp;&amp; !arguments.contains_key(\"content\") {\n            return Err(Error::validation(\"content parameter is required for write_file operation\"));\n        }\n        \n        Ok(())\n    }\n    \n    async fn execute(&amp;self, arguments: HashMap&lt;String, Value&gt;) -&gt; Result&lt;ToolResult&gt; {\n        let operation = arguments[\"operation\"].as_str().unwrap();\n        let path = self.validate_path(arguments[\"path\"].as_str().unwrap())?;\n        \n        info!(\"Performing filesystem operation: {} on {}\", operation, path.display());\n        \n        let result_text = match operation {\n            \"read_file\" =&gt; {\n                let metadata = fs::metadata(&amp;path).await\n                    .map_err(|e| Error::tool_error(\"filesystem\", e.to_string()))?;\n                \n                if metadata.len() &gt; self.config.max_file_size {\n                    return Err(Error::permission_denied(\n                        format!(\"File too large: {} bytes\", metadata.len())\n                    ));\n                }\n                \n                let content = fs::read_to_string(&amp;path).await\n                    .map_err(|e| Error::tool_error(\"filesystem\", e.to_string()))?;\n                \n                json!({\n                    \"operation\": \"read_file\",\n                    \"path\": path.to_string_lossy(),\n                    \"content\": content,\n                    \"size\": metadata.len()\n                }).to_string()\n            },\n            \n            \"list_directory\" =&gt; {\n                let mut entries = Vec::new();\n                let mut dir = fs::read_dir(&amp;path).await\n                    .map_err(|e| Error::tool_error(\"filesystem\", e.to_string()))?;\n                \n                while let Some(entry) = dir.next_entry().await\n                    .map_err(|e| Error::tool_error(\"filesystem\", e.to_string()))? {\n                    \n                    let metadata = entry.metadata().await\n                        .map_err(|e| Error::tool_error(\"filesystem\", e.to_string()))?;\n                    \n                    entries.push(json!({\n                        \"name\": entry.file_name().to_string_lossy(),\n                        \"path\": entry.path().to_string_lossy(),\n                        \"is_file\": metadata.is_file(),\n                        \"is_dir\": metadata.is_dir(),\n                        \"size\": metadata.len()\n                    }));\n                }\n                \n                json!({\n                    \"operation\": \"list_directory\",\n                    \"path\": path.to_string_lossy(),\n                    \"entries\": entries\n                }).to_string()\n            },\n            \n            \"write_file\" =&gt; {\n                if self.config.read_only {\n                    return Err(Error::permission_denied(\"Write operations not allowed\"));\n                }\n                \n                let content = arguments[\"content\"].as_str()\n                    .ok_or_else(|| Error::validation(\"content parameter is required\"))?;\n                \n                if content.len() &gt; self.config.max_file_size as usize {\n                    return Err(Error::permission_denied(\n                        format!(\"Content too large: {} bytes\", content.len())\n                    ));\n                }\n                \n                fs::write(&amp;path, content).await\n                    .map_err(|e| Error::tool_error(\"filesystem\", e.to_string()))?;\n                \n                json!({\n                    \"operation\": \"write_file\",\n                    \"path\": path.to_string_lossy(),\n                    \"bytes_written\": content.len()\n                }).to_string()\n            },\n            \n            _ =&gt; {\n                return Err(Error::validation(format!(\"Unknown operation: {}\", operation)));\n            }\n        };\n        \n        Ok(ToolResult {\n            content: vec![Content::Text { text: result_text }],\n            is_error: None,\n        })\n    }\n}\n</code></pre> <p>This Rust implementation provides a robust foundation for building MCP servers with strong type safety, comprehensive error handling, and async support for high-performance operations.</p>"},{"location":"develop/rust/structure/","title":"Rust Project Structure","text":""},{"location":"develop/rust/structure/#rust-project-structure","title":"Rust Project Structure","text":""},{"location":"develop/rust/structure/#recommended-structure-for-mcp-servers-in-rust","title":"Recommended Structure for MCP Servers in Rust","text":"<p>This guide outlines the optimal project structure for building MCP servers using Rust, focusing on modularity, testability, and maintainability.</p>"},{"location":"develop/rust/structure/#basic-project-layout","title":"Basic Project Layout","text":"<pre><code>mcp-server-rust/\n\u251c\u2500\u2500 Cargo.toml              # Project manifest\n\u251c\u2500\u2500 Cargo.lock              # Dependency lockfile\n\u251c\u2500\u2500 README.md               # Project documentation\n\u251c\u2500\u2500 LICENSE                 # License file\n\u251c\u2500\u2500 .gitignore              # Git ignore rules\n\u251c\u2500\u2500 .rustfmt.toml           # Code formatting config\n\u251c\u2500\u2500 clippy.toml             # Linter configuration\n\u251c\u2500\u2500 src/                    # Source code\n\u2502   \u251c\u2500\u2500 main.rs             # Application entry point\n\u2502   \u251c\u2500\u2500 lib.rs              # Library root\n\u2502   \u251c\u2500\u2500 config/             # Configuration handling\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2514\u2500\u2500 settings.rs\n\u2502   \u251c\u2500\u2500 server/             # MCP server implementation\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 handlers.rs\n\u2502   \u2502   \u2514\u2500\u2500 transport.rs\n\u2502   \u251c\u2500\u2500 tools/              # Tool implementations\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 database.rs\n\u2502   \u2502   \u251c\u2500\u2500 http.rs\n\u2502   \u2502   \u2514\u2500\u2500 filesystem.rs\n\u2502   \u251c\u2500\u2500 resources/          # Resource implementations\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2514\u2500\u2500 config.rs\n\u2502   \u251c\u2500\u2500 error/              # Error handling\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2514\u2500\u2500 types.rs\n\u2502   \u2514\u2500\u2500 utils/              # Utility functions\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u2514\u2500\u2500 validation.rs\n\u251c\u2500\u2500 tests/                  # Integration tests\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 server_tests.rs\n\u2502   \u2502   \u2514\u2500\u2500 tool_tests.rs\n\u2502   \u2514\u2500\u2500 common/\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u2514\u2500\u2500 fixtures.rs\n\u251c\u2500\u2500 benches/                # Benchmarks\n\u2502   \u2514\u2500\u2500 tool_benchmarks.rs\n\u251c\u2500\u2500 examples/               # Example code\n\u2502   \u251c\u2500\u2500 basic_server.rs\n\u2502   \u2514\u2500\u2500 custom_tools.rs\n\u2514\u2500\u2500 docs/                   # Documentation\n    \u251c\u2500\u2500 api.md\n    \u2514\u2500\u2500 deployment.md\n</code></pre>"},{"location":"develop/rust/structure/#cargotoml-configuration","title":"Cargo.toml Configuration","text":"<pre><code>[package]\nname = \"mcp-server-rust\"\nversion = \"0.1.0\"\nedition = \"2021\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\ndescription = \"A Model Context Protocol server implementation in Rust\"\nrepository = \"https://github.com/your-org/mcp-server-rust\"\nlicense = \"MIT\"\nkeywords = [\"mcp\", \"ai\", \"protocol\", \"server\"]\ncategories = [\"web-programming\", \"api-bindings\"]\n\n[[bin]]\nname = \"mcp-server\"\npath = \"src/main.rs\"\n\n[lib]\nname = \"mcp_server_rust\"\npath = \"src/lib.rs\"\n\n[dependencies]\n# Async runtime\ntokio = { version = \"1.0\", features = [\"full\"] }\ntokio-util = \"0.7\"\n\n# HTTP and networking\nreqwest = { version = \"0.11\", features = [\"json\"] }\nhyper = { version = \"0.14\", features = [\"full\"] }\ntower = \"0.4\"\ntower-http = { version = \"0.4\", features = [\"cors\", \"trace\"] }\n\n# Serialization\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nserde_yaml = \"0.9\"\n\n# Database (optional)\nsqlx = { version = \"0.7\", features = [\"runtime-tokio-rustls\", \"postgres\", \"uuid\", \"chrono\"], optional = true }\n\n# Logging and tracing\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n\n# Error handling\nanyhow = \"1.0\"\nthiserror = \"1.0\"\n\n# Configuration\nconfig = \"0.13\"\nclap = { version = \"4.0\", features = [\"derive\"] }\n\n# Utilities\nuuid = { version = \"1.0\", features = [\"v4\"] }\nchrono = { version = \"0.4\", features = [\"serde\"] }\nurl = \"2.0\"\n\n[dev-dependencies]\n# Testing\ntokio-test = \"0.4\"\nassert_matches = \"1.5\"\ntempfile = \"3.0\"\nmockall = \"0.11\"\n\n# Benchmarking\ncriterion = { version = \"0.5\", features = [\"html_reports\"] }\n\n[features]\ndefault = [\"database\"]\ndatabase = [\"sqlx\"]\nmetrics = []\n\n[profile.release]\nlto = true\ncodegen-units = 1\npanic = \"abort\"\nstrip = true\n\n[profile.dev]\ndebug = true\nopt-level = 0\n\n[[example]]\nname = \"basic_server\"\npath = \"examples/basic_server.rs\"\n\n[[bench]]\nname = \"tool_benchmarks\"\nharness = false\n</code></pre>"},{"location":"develop/rust/structure/#main-entry-point","title":"Main Entry Point","text":"<pre><code>// src/main.rs\nuse std::process;\n\nuse clap::Parser;\nuse tracing::{info, error};\nuse tracing_subscriber;\n\nuse mcp_server_rust::{\n    config::Settings,\n    server::Server,\n    error::Result,\n};\n\n#[derive(Parser)]\n#[command(name = \"mcp-server\")]\n#[command(about = \"A Model Context Protocol server implementation\")]\nstruct Cli {\n    /// Configuration file path\n    #[arg(short, long, default_value = \"config.yaml\")]\n    config: String,\n    \n    /// Log level\n    #[arg(long, default_value = \"info\")]\n    log_level: String,\n    \n    /// Server port (overrides config)\n    #[arg(short, long)]\n    port: Option&lt;u16&gt;,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    let cli = Cli::parse();\n    \n    // Initialize tracing\n    tracing_subscriber::fmt()\n        .with_env_filter(&amp;cli.log_level)\n        .init();\n    \n    info!(\"Starting MCP server\");\n    \n    // Load configuration\n    let mut settings = Settings::load(&amp;cli.config)?;\n    \n    // Override port if provided\n    if let Some(port) = cli.port {\n        settings.server.port = port;\n    }\n    \n    // Create and run server\n    let server = Server::new(settings).await?;\n    \n    if let Err(e) = server.run().await {\n        error!(\"Server error: {}\", e);\n        process::exit(1);\n    }\n    \n    Ok(())\n}\n</code></pre>"},{"location":"develop/rust/structure/#library-root","title":"Library Root","text":"<pre><code>// src/lib.rs\n//! # MCP Server Rust\n//! \n//! A Model Context Protocol server implementation in Rust.\n//! \n//! ## Features\n//! \n//! - Asynchronous processing with Tokio\n//! - Type-safe configuration management\n//! - Comprehensive error handling\n//! - Built-in tools for common operations\n//! - Resource management\n//! - Extensible architecture\n\npub mod config;\npub mod error;\npub mod resources;\npub mod server;\npub mod tools;\npub mod utils;\n\n// Re-export commonly used types\npub use error::{Error, Result};\npub use server::Server;\npub use config::Settings;\n\n/// MCP protocol version supported by this implementation\npub const MCP_VERSION: &amp;str = \"2024-11-05\";\n\n/// Server information\n#[derive(Debug, Clone)]\npub struct ServerInfo {\n    pub name: String,\n    pub version: String,\n}\n\nimpl Default for ServerInfo {\n    fn default() -&gt; Self {\n        Self {\n            name: env!(\"CARGO_PKG_NAME\").to_string(),\n            version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        }\n    }\n}\n</code></pre>"},{"location":"develop/rust/structure/#configuration-module","title":"Configuration Module","text":"<pre><code>// src/config/mod.rs\nmod settings;\n\npub use settings::{Settings, ServerConfig, DatabaseConfig};\n</code></pre> <pre><code>// src/config/settings.rs\nuse std::fs;\nuse serde::{Deserialize, Serialize};\nuse config::{Config, ConfigError, Environment, File};\n\n/// Application settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Settings {\n    pub server: ServerConfig,\n    pub database: Option&lt;DatabaseConfig&gt;,\n    pub tools: ToolsConfig,\n    pub logging: LoggingConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServerConfig {\n    pub name: String,\n    pub version: String,\n    pub host: String,\n    pub port: u16,\n    pub transport: TransportType,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DatabaseConfig {\n    pub url: String,\n    pub max_connections: u32,\n    pub min_connections: u32,\n    pub acquire_timeout: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolsConfig {\n    pub enabled: Vec&lt;String&gt;,\n    pub database_tool: Option&lt;DatabaseToolConfig&gt;,\n    pub http_tool: Option&lt;HttpToolConfig&gt;,\n    pub filesystem_tool: Option&lt;FilesystemToolConfig&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DatabaseToolConfig {\n    pub read_only: bool,\n    pub max_rows: u32,\n    pub timeout: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HttpToolConfig {\n    pub allowed_domains: Option&lt;Vec&lt;String&gt;&gt;,\n    pub blocked_domains: Option&lt;Vec&lt;String&gt;&gt;,\n    pub timeout: u64,\n    pub max_response_size: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FilesystemToolConfig {\n    pub allowed_paths: Vec&lt;String&gt;,\n    pub max_file_size: u64,\n    pub read_only: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoggingConfig {\n    pub level: String,\n    pub format: LogFormat,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum TransportType {\n    Stdio,\n    Http,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum LogFormat {\n    Json,\n    Pretty,\n    Compact,\n}\n\nimpl Settings {\n    /// Load settings from configuration file\n    pub fn load(config_path: &amp;str) -&gt; Result&lt;Self, ConfigError&gt; {\n        let mut config = Config::builder()\n            .add_source(File::with_name(\"config/default\"))\n            .add_source(File::with_name(config_path).required(false))\n            .add_source(Environment::with_prefix(\"MCP\").separator(\"_\"))\n            .build()?;\n            \n        // Set defaults\n        config.set_default(\"server.name\", env!(\"CARGO_PKG_NAME\"))?;\n        config.set_default(\"server.version\", env!(\"CARGO_PKG_VERSION\"))?;\n        config.set_default(\"server.host\", \"0.0.0.0\")?;\n        config.set_default(\"server.port\", 8000)?;\n        config.set_default(\"server.transport\", \"http\")?;\n        config.set_default(\"logging.level\", \"info\")?;\n        config.set_default(\"logging.format\", \"pretty\")?;\n        config.set_default(\"tools.enabled\", Vec::&lt;String&gt;::new())?;\n        \n        config.try_deserialize()\n    }\n    \n    /// Validate configuration\n    pub fn validate(&amp;self) -&gt; Result&lt;(), String&gt; {\n        if self.server.port == 0 {\n            return Err(\"Server port cannot be 0\".to_string());\n        }\n        \n        if let Some(db_config) = &amp;self.database {\n            if db_config.max_connections == 0 {\n                return Err(\"Database max_connections cannot be 0\".to_string());\n            }\n        }\n        \n        // Validate enabled tools exist\n        for tool_name in &amp;self.tools.enabled {\n            match tool_name.as_str() {\n                \"database\" | \"http\" | \"filesystem\" =&gt; {},\n                _ =&gt; return Err(format!(\"Unknown tool: {}\", tool_name)),\n            }\n        }\n        \n        Ok(())\n    }\n}\n\nimpl Default for Settings {\n    fn default() -&gt; Self {\n        Self {\n            server: ServerConfig {\n                name: env!(\"CARGO_PKG_NAME\").to_string(),\n                version: env!(\"CARGO_PKG_VERSION\").to_string(),\n                host: \"0.0.0.0\".to_string(),\n                port: 8000,\n                transport: TransportType::Http,\n            },\n            database: None,\n            tools: ToolsConfig {\n                enabled: vec![\"http\".to_string(), \"filesystem\".to_string()],\n                database_tool: None,\n                http_tool: Some(HttpToolConfig {\n                    allowed_domains: None,\n                    blocked_domains: None,\n                    timeout: 30,\n                    max_response_size: 1024 * 1024, // 1MB\n                }),\n                filesystem_tool: Some(FilesystemToolConfig {\n                    allowed_paths: vec![\"/tmp\".to_string()],\n                    max_file_size: 1024 * 1024, // 1MB\n                    read_only: true,\n                }),\n            },\n            logging: LoggingConfig {\n                level: \"info\".to_string(),\n                format: LogFormat::Pretty,\n            },\n        }\n    }\n}\n</code></pre>"},{"location":"develop/rust/structure/#error-handling-module","title":"Error Handling Module","text":"<pre><code>// src/error/mod.rs\nmod types;\n\npub use types::{Error, Result};\n</code></pre> <pre><code>// src/error/types.rs\nuse std::fmt;\nuse thiserror::Error;\n\n/// Application result type\npub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;\n\n/// Application error types\n#[derive(Error, Debug)]\npub enum Error {\n    #[error(\"Configuration error: {0}\")]\n    Config(#[from] config::ConfigError),\n    \n    #[error(\"I/O error: {0}\")]\n    Io(#[from] std::io::Error),\n    \n    #[error(\"JSON error: {0}\")]\n    Json(#[from] serde_json::Error),\n    \n    #[error(\"HTTP error: {0}\")]\n    Http(#[from] reqwest::Error),\n    \n    #[cfg(feature = \"database\")]\n    #[error(\"Database error: {0}\")]\n    Database(#[from] sqlx::Error),\n    \n    #[error(\"Validation error: {message}\")]\n    Validation { message: String },\n    \n    #[error(\"Tool error: {tool_name}: {message}\")]\n    Tool { tool_name: String, message: String },\n    \n    #[error(\"Resource error: {uri}: {message}\")]\n    Resource { uri: String, message: String },\n    \n    #[error(\"Permission denied: {message}\")]\n    Permission { message: String },\n    \n    #[error(\"Not found: {message}\")]\n    NotFound { message: String },\n    \n    #[error(\"Internal server error: {message}\")]\n    Internal { message: String },\n}\n\nimpl Error {\n    pub fn validation(message: impl Into&lt;String&gt;) -&gt; Self {\n        Self::Validation { message: message.into() }\n    }\n    \n    pub fn tool_error(tool_name: impl Into&lt;String&gt;, message: impl Into&lt;String&gt;) -&gt; Self {\n        Self::Tool {\n            tool_name: tool_name.into(),\n            message: message.into(),\n        }\n    }\n    \n    pub fn resource_error(uri: impl Into&lt;String&gt;, message: impl Into&lt;String&gt;) -&gt; Self {\n        Self::Resource {\n            uri: uri.into(),\n            message: message.into(),\n        }\n    }\n    \n    pub fn permission_denied(message: impl Into&lt;String&gt;) -&gt; Self {\n        Self::Permission { message: message.into() }\n    }\n    \n    pub fn not_found(message: impl Into&lt;String&gt;) -&gt; Self {\n        Self::NotFound { message: message.into() }\n    }\n    \n    pub fn internal(message: impl Into&lt;String&gt;) -&gt; Self {\n        Self::Internal { message: message.into() }\n    }\n}\n</code></pre>"},{"location":"develop/rust/structure/#server-module-structure","title":"Server Module Structure","text":"<pre><code>// src/server/mod.rs\nmod handlers;\nmod transport;\n\npub use handlers::Handlers;\nuse transport::Transport;\n\nuse crate::{config::Settings, error::Result, tools::ToolRegistry, resources::ResourceRegistry};\nuse std::sync::Arc;\nuse tokio::signal;\nuse tracing::{info, error};\n\n/// MCP Server\n#[derive(Clone)]\npub struct Server {\n    settings: Arc&lt;Settings&gt;,\n    tool_registry: Arc&lt;ToolRegistry&gt;,\n    resource_registry: Arc&lt;ResourceRegistry&gt;,\n    handlers: Arc&lt;Handlers&gt;,\n}\n\nimpl Server {\n    /// Create a new server instance\n    pub async fn new(settings: Settings) -&gt; Result&lt;Self&gt; {\n        // Validate settings\n        settings.validate().map_err(|e| crate::Error::validation(e))?;\n        \n        let settings = Arc::new(settings);\n        \n        // Initialize registries\n        let tool_registry = Arc::new(ToolRegistry::new(settings.clone()).await?);\n        let resource_registry = Arc::new(ResourceRegistry::new(settings.clone()));\n        \n        // Initialize handlers\n        let handlers = Arc::new(Handlers::new(\n            tool_registry.clone(),\n            resource_registry.clone(),\n        ));\n        \n        Ok(Self {\n            settings,\n            tool_registry,\n            resource_registry,\n            handlers,\n        })\n    }\n    \n    /// Run the server\n    pub async fn run(self) -&gt; Result&lt;()&gt; {\n        info!(\"Starting MCP server on {}:{}\", \n               self.settings.server.host, \n               self.settings.server.port);\n        \n        // Create transport\n        let transport = Transport::new(self.settings.clone(), self.handlers.clone()).await?;\n        \n        // Run server with graceful shutdown\n        tokio::select! {\n            result = transport.serve() =&gt; {\n                match result {\n                    Ok(_) =&gt; info!(\"Server stopped normally\"),\n                    Err(e) =&gt; {\n                        error!(\"Server error: {}\", e);\n                        return Err(e);\n                    }\n                }\n            },\n            _ = signal::ctrl_c() =&gt; {\n                info!(\"Received shutdown signal\");\n            }\n        }\n        \n        // Cleanup\n        self.tool_registry.shutdown().await;\n        info!(\"Server shutdown complete\");\n        \n        Ok(())\n    }\n}\n</code></pre> <p>This Rust project structure provides a solid foundation for building scalable and maintainable MCP servers with proper separation of concerns, configuration management, and error handling.</p>"},{"location":"develop/rust/testing/","title":"Rust Testing Guide","text":""},{"location":"develop/rust/testing/#rust-testing-guide","title":"Rust Testing Guide","text":""},{"location":"develop/rust/testing/#testing-strategies-for-rust-mcp-servers","title":"Testing Strategies for Rust MCP Servers","text":"<p>Comprehensive testing ensures your Rust MCP server is reliable, maintainable, and performs well under various conditions using Rust's powerful testing ecosystem.</p>"},{"location":"develop/rust/testing/#testing-configuration","title":"Testing Configuration","text":""},{"location":"develop/rust/testing/#cargotoml-test-dependencies","title":"Cargo.toml Test Dependencies","text":"<pre><code>[dev-dependencies]\n# Core testing framework\ntokio-test = \"0.4\"\nassert_matches = \"1.5\"\ntempfile = \"3.0\"\n\n# Mocking and test doubles\nmockall = \"0.11\"\nwiremock = \"0.5\"\n\n# Property-based testing\nquickcheck = \"1.0\"\nquickcheck_macros = \"1.0\"\n\n# Benchmarking\ncriterion = { version = \"0.5\", features = [\"html_reports\"] }\n\n# Test utilities\nrstest = \"0.18\"\ntest-case = \"3.0\"\nfake = { version = \"2.8\", features = [\"derive\"] }\n\n# HTTP testing\nhttpmock = \"0.6\"\nreqwest = { version = \"0.11\", features = [\"json\"] }\n\n# Database testing\nsqlx = { version = \"0.7\", features = [\"testing\"] }\n\n[features]\ntesting = []\n</code></pre>"},{"location":"develop/rust/testing/#test-utilities-module","title":"Test Utilities Module","text":"<pre><code>// src/testing/mod.rs\nuse std::sync::Once;\nuse tracing_subscriber;\n\nstatic INIT: Once = Once::new();\n\n/// Initialize test logging (call once per test run)\npub fn init_test_logging() {\n    INIT.call_once(|| {\n        tracing_subscriber::fmt()\n            .with_env_filter(\"debug\")\n            .with_test_writer()\n            .init();\n    });\n}\n\n/// Create temporary directory for tests\npub fn temp_dir() -&gt; tempfile::TempDir {\n    tempfile::tempdir().expect(\"Failed to create temp dir\")\n}\n\n/// Create test configuration\npub fn test_config() -&gt; crate::config::Settings {\n    crate::config::Settings {\n        server: crate::config::ServerConfig {\n            name: \"test-server\".to_string(),\n            version: \"test\".to_string(),\n            host: \"127.0.0.1\".to_string(),\n            port: 0, // Random available port\n            transport: crate::config::TransportType::Http,\n        },\n        database: None,\n        tools: crate::config::ToolsConfig {\n            enabled: vec![\"http\".to_string(), \"filesystem\".to_string()],\n            database_tool: None,\n            http_tool: Some(crate::config::HttpToolConfig {\n                allowed_domains: None,\n                blocked_domains: None,\n                timeout: 30,\n                max_response_size: 1024 * 1024,\n            }),\n            filesystem_tool: Some(crate::config::FilesystemToolConfig {\n                allowed_paths: vec![\"/tmp\".to_string()],\n                max_file_size: 1024 * 1024,\n                read_only: true,\n            }),\n        },\n        logging: crate::config::LoggingConfig {\n            level: \"debug\".to_string(),\n            format: crate::config::LogFormat::Pretty,\n        },\n    }\n}\n</code></pre>"},{"location":"develop/rust/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"develop/rust/testing/#tool-unit-tests","title":"Tool Unit Tests","text":"<pre><code>// src/tools/http/tests.rs\nuse super::*;\nuse crate::testing::*;\nuse httpmock::prelude::*;\nuse serde_json::json;\nuse std::collections::HashMap;\nuse tokio_test;\n\n#[tokio::test]\nasync fn test_http_tool_get_request() {\n    init_test_logging();\n    \n    // Setup mock server\n    let server = MockServer::start();\n    let mock = server.mock(|when, then| {\n        when.method(GET)\n            .path(\"/api/users\");\n        then.status(200)\n            .header(\"content-type\", \"application/json\")\n            .body(r#\"{\"users\": [\"alice\", \"bob\"]}\"#);\n    });\n    \n    // Create HTTP tool\n    let config = crate::config::HttpToolConfig {\n        allowed_domains: None,\n        blocked_domains: None,\n        timeout: 30,\n        max_response_size: 1024 * 1024,\n    };\n    \n    let tool = HttpTool::new(config).unwrap();\n    \n    // Prepare arguments\n    let mut arguments = HashMap::new();\n    arguments.insert(\"url\".to_string(), json!(server.url(\"/api/users\")));\n    arguments.insert(\"method\".to_string(), json!(\"GET\"));\n    \n    // Execute tool\n    let result = tool.execute(arguments).await.unwrap();\n    \n    // Verify result\n    assert_eq!(result.content.len(), 1);\n    \n    if let Content::Text { text } = &amp;result.content[0] {\n        let response: serde_json::Value = serde_json::from_str(text).unwrap();\n        assert_eq!(response[\"status_code\"], 200);\n        assert!(response[\"body\"].as_str().unwrap().contains(\"alice\"));\n    } else {\n        panic!(\"Expected text content\");\n    }\n    \n    mock.assert();\n}\n\n#[tokio::test]\nasync fn test_http_tool_post_request() {\n    init_test_logging();\n    \n    let server = MockServer::start();\n    let mock = server.mock(|when, then| {\n        when.method(POST)\n            .path(\"/api/users\")\n            .header(\"content-type\", \"application/json\")\n            .json_body(json!({\"name\": \"charlie\"}));\n        then.status(201)\n            .header(\"content-type\", \"application/json\")\n            .body(r#\"{\"id\": 123, \"name\": \"charlie\"}\"#);\n    });\n    \n    let config = crate::config::HttpToolConfig {\n        allowed_domains: None,\n        blocked_domains: None,\n        timeout: 30,\n        max_response_size: 1024 * 1024,\n    };\n    \n    let tool = HttpTool::new(config).unwrap();\n    \n    let mut arguments = HashMap::new();\n    arguments.insert(\"url\".to_string(), json!(server.url(\"/api/users\")));\n    arguments.insert(\"method\".to_string(), json!(\"POST\"));\n    arguments.insert(\"body\".to_string(), json!(r#\"{\"name\": \"charlie\"}\"#));\n    \n    let mut headers = HashMap::new();\n    headers.insert(\"content-type\".to_string(), json!(\"application/json\"));\n    arguments.insert(\"headers\".to_string(), json!(headers));\n    \n    let result = tool.execute(arguments).await.unwrap();\n    \n    assert_eq!(result.content.len(), 1);\n    if let Content::Text { text } = &amp;result.content[0] {\n        let response: serde_json::Value = serde_json::from_str(text).unwrap();\n        assert_eq!(response[\"status_code\"], 201);\n    }\n    \n    mock.assert();\n}\n\n#[tokio::test]\nasync fn test_http_tool_blocked_domain() {\n    init_test_logging();\n    \n    let config = crate::config::HttpToolConfig {\n        allowed_domains: None,\n        blocked_domains: Some(vec![\"blocked.com\".to_string()]),\n        timeout: 30,\n        max_response_size: 1024 * 1024,\n    };\n    \n    let tool = HttpTool::new(config).unwrap();\n    \n    let mut arguments = HashMap::new();\n    arguments.insert(\"url\".to_string(), json!(\"https://blocked.com/api\"));\n    \n    let result = tool.validate_arguments(&amp;arguments);\n    \n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"blocked\"));\n}\n\n// Property-based tests\n#[quickcheck]\nfn test_http_tool_url_validation(url: String) -&gt; bool {\n    let config = crate::config::HttpToolConfig {\n        allowed_domains: None,\n        blocked_domains: None,\n        timeout: 30,\n        max_response_size: 1024 * 1024,\n    };\n    \n    let tool = HttpTool::new(config).unwrap();\n    \n    // Valid URLs should not cause panics\n    let _ = tool.validate_url(&amp;url);\n    true\n}\n\n// Parametrized tests using rstest\n#[rstest]\n#[case(\"GET\", \"https://api.example.com/users\")]\n#[case(\"POST\", \"https://api.example.com/users\")]\n#[case(\"PUT\", \"https://api.example.com/users/123\")]\n#[case(\"DELETE\", \"https://api.example.com/users/123\")]\n#[tokio::test]\nasync fn test_http_methods(#[case] method: &amp;str, #[case] url: &amp;str) {\n    let config = crate::config::HttpToolConfig {\n        allowed_domains: None,\n        blocked_domains: None,\n        timeout: 30,\n        max_response_size: 1024 * 1024,\n    };\n    \n    let tool = HttpTool::new(config).unwrap();\n    \n    let mut arguments = HashMap::new();\n    arguments.insert(\"method\".to_string(), json!(method));\n    arguments.insert(\"url\".to_string(), json!(url));\n    \n    let validation_result = tool.validate_arguments(&amp;arguments);\n    assert!(validation_result.is_ok());\n}\n</code></pre>"},{"location":"develop/rust/testing/#database-tool-tests-with-mocking","title":"Database Tool Tests with Mocking","text":"<pre><code>// src/tools/database/tests.rs\nuse super::*;\nuse crate::testing::*;\nuse mockall::predicate::*;\nuse sqlx::testing::TestPool;\nuse std::collections::HashMap;\n\n// Mock trait for database operations\nmockall::mock! {\n    DatabasePool {\n        async fn query(&amp;self, query: &amp;str) -&gt; Result&lt;Vec&lt;sqlx::Row&gt;, sqlx::Error&gt;;\n    }\n}\n\n#[tokio::test]\nasync fn test_database_tool_select_query() {\n    init_test_logging();\n    \n    // This would typically use sqlx::testing::TestPool in real scenarios\n    let config = crate::config::DatabaseToolConfig {\n        read_only: true,\n        max_rows: 100,\n        timeout: 30,\n    };\n    \n    // For this test, we'll test validation logic\n    let tool_result = std::panic::catch_unwind(|| {\n        // Tool creation would happen here with real database\n        // For now, we test validation logic directly\n        let query = \"SELECT id, name FROM users\";\n        validate_query(query, &amp;config)\n    });\n    \n    assert!(tool_result.is_ok());\n}\n\n#[tokio::test]\nasync fn test_database_tool_prevents_dangerous_queries() {\n    let config = crate::config::DatabaseToolConfig {\n        read_only: true,\n        max_rows: 100,\n        timeout: 30,\n    };\n    \n    let dangerous_queries = vec![\n        \"DROP TABLE users\",\n        \"DELETE FROM users\",\n        \"UPDATE users SET password = 'hacked'\",\n        \"INSERT INTO users VALUES ('hacker', 'password')\",\n    ];\n    \n    for query in dangerous_queries {\n        let result = validate_query(query, &amp;config);\n        assert!(result.is_err(), \"Query should be rejected: {}\", query);\n    }\n}\n\nfn validate_query(query: &amp;str, config: &amp;crate::config::DatabaseToolConfig) -&gt; Result&lt;()&gt; {\n    let query_upper = query.trim().to_uppercase();\n    \n    if config.read_only &amp;&amp; !query_upper.starts_with(\"SELECT\") {\n        return Err(crate::Error::permission_denied(\n            \"Only SELECT statements are allowed in read-only mode\"\n        ));\n    }\n    \n    let dangerous_keywords = [\n        \"DROP\", \"DELETE\", \"INSERT\", \"UPDATE\", \"ALTER\", \n        \"CREATE\", \"TRUNCATE\", \"REPLACE\", \"MERGE\"\n    ];\n    \n    for keyword in &amp;dangerous_keywords {\n        if query_upper.contains(keyword) &amp;&amp; config.read_only {\n            return Err(crate::Error::permission_denied(\n                format!(\"Query contains forbidden keyword: {}\", keyword)\n            ));\n        }\n    }\n    \n    Ok(())\n}\n\n// Integration test with real database (requires test database)\n#[cfg(feature = \"testing\")]\n#[sqlx::test]\nasync fn test_database_tool_integration(pool: sqlx::PgPool) {\n    // Setup test data\n    sqlx::query(\"CREATE TEMPORARY TABLE test_users (id SERIAL PRIMARY KEY, name TEXT)\")\n        .execute(&amp;pool)\n        .await\n        .unwrap();\n    \n    sqlx::query(\"INSERT INTO test_users (name) VALUES ('Alice'), ('Bob')\")\n        .execute(&amp;pool)\n        .await\n        .unwrap();\n    \n    // Create tool\n    let config = crate::config::DatabaseToolConfig {\n        read_only: true,\n        max_rows: 100,\n        timeout: 30,\n    };\n    \n    let tool = DatabaseTool::new(\"postgresql://test\", config).await.unwrap();\n    \n    // Test query\n    let mut arguments = HashMap::new();\n    arguments.insert(\"query\".to_string(), json!(\"SELECT * FROM test_users\"));\n    \n    let result = tool.execute(arguments).await.unwrap();\n    \n    assert_eq!(result.content.len(), 1);\n    if let Content::Text { text } = &amp;result.content[0] {\n        assert!(text.contains(\"Alice\"));\n        assert!(text.contains(\"Bob\"));\n    }\n}\n</code></pre>"},{"location":"develop/rust/testing/#filesystem-tool-tests","title":"Filesystem Tool Tests","text":"<pre><code>// src/tools/filesystem/tests.rs\nuse super::*;\nuse crate::testing::*;\nuse std::fs;\nuse std::path::Path;\nuse tempfile::TempDir;\nuse tokio_test;\n\n#[tokio::test]\nasync fn test_filesystem_tool_read_file() {\n    init_test_logging();\n    \n    let temp_dir = temp_dir();\n    let test_file = temp_dir.path().join(\"test.txt\");\n    let test_content = \"Hello, World!\";\n    \n    // Create test file\n    fs::write(&amp;test_file, test_content).unwrap();\n    \n    let config = crate::config::FilesystemToolConfig {\n        allowed_paths: vec![temp_dir.path().to_string_lossy().into_owned()],\n        max_file_size: 1024 * 1024,\n        read_only: true,\n    };\n    \n    let tool = FilesystemTool::new(config);\n    \n    let mut arguments = HashMap::new();\n    arguments.insert(\"operation\".to_string(), json!(\"read_file\"));\n    arguments.insert(\"path\".to_string(), json!(test_file.to_string_lossy()));\n    \n    let result = tool.execute(arguments).await.unwrap();\n    \n    assert_eq!(result.content.len(), 1);\n    if let Content::Text { text } = &amp;result.content[0] {\n        let response: serde_json::Value = serde_json::from_str(text).unwrap();\n        assert_eq!(response[\"content\"], test_content);\n    }\n}\n\n#[tokio::test]\nasync fn test_filesystem_tool_list_directory() {\n    init_test_logging();\n    \n    let temp_dir = temp_dir();\n    \n    // Create test files\n    fs::write(temp_dir.path().join(\"file1.txt\"), \"content1\").unwrap();\n    fs::write(temp_dir.path().join(\"file2.txt\"), \"content2\").unwrap();\n    fs::create_dir(temp_dir.path().join(\"subdir\")).unwrap();\n    \n    let config = crate::config::FilesystemToolConfig {\n        allowed_paths: vec![temp_dir.path().to_string_lossy().into_owned()],\n        max_file_size: 1024 * 1024,\n        read_only: true,\n    };\n    \n    let tool = FilesystemTool::new(config);\n    \n    let mut arguments = HashMap::new();\n    arguments.insert(\"operation\".to_string(), json!(\"list_directory\"));\n    arguments.insert(\"path\".to_string(), json!(temp_dir.path().to_string_lossy()));\n    \n    let result = tool.execute(arguments).await.unwrap();\n    \n    assert_eq!(result.content.len(), 1);\n    if let Content::Text { text } = &amp;result.content[0] {\n        let response: serde_json::Value = serde_json::from_str(text).unwrap();\n        let entries = response[\"entries\"].as_array().unwrap();\n        assert_eq!(entries.len(), 3); // 2 files + 1 directory\n    }\n}\n\n#[tokio::test]\nasync fn test_filesystem_tool_path_traversal_protection() {\n    let config = crate::config::FilesystemToolConfig {\n        allowed_paths: vec![\"/tmp\".to_string()],\n        max_file_size: 1024 * 1024,\n        read_only: true,\n    };\n    \n    let tool = FilesystemTool::new(config);\n    \n    let mut arguments = HashMap::new();\n    arguments.insert(\"operation\".to_string(), json!(\"read_file\"));\n    arguments.insert(\"path\".to_string(), json!(\"../../../etc/passwd\"));\n    \n    let result = tool.validate_arguments(&amp;arguments);\n    assert!(result.is_err());\n    assert!(result.unwrap_err().to_string().contains(\"traversal\"));\n}\n\n#[test_case(\"/tmp/allowed.txt\"; \"allowed path\")]\n#[test_case(\"/tmp/subdir/allowed.txt\"; \"allowed subdirectory\")]\nfn test_filesystem_path_validation_allowed(path: &amp;str) {\n    let config = crate::config::FilesystemToolConfig {\n        allowed_paths: vec![\"/tmp\".to_string()],\n        max_file_size: 1024 * 1024,\n        read_only: true,\n    };\n    \n    let tool = FilesystemTool::new(config);\n    \n    // Note: This test would need actual file creation in real scenario\n    // For unit testing, we'd extract the validation logic\n    let validation_result = validate_path_logic(path, &amp;[\"/tmp\"]);\n    assert!(validation_result.is_ok());\n}\n\n// Helper function for testing path validation logic\nfn validate_path_logic(path: &amp;str, allowed_paths: &amp;[&amp;str]) -&gt; Result&lt;()&gt; {\n    if path.contains(\"..\") {\n        return Err(crate::Error::permission_denied(\"Path traversal not allowed\"));\n    }\n    \n    let path_obj = Path::new(path);\n    \n    for allowed_path in allowed_paths {\n        let allowed_obj = Path::new(allowed_path);\n        if path_obj.starts_with(allowed_obj) {\n            return Ok(());\n        }\n    }\n    \n    Err(crate::Error::permission_denied(\n        format!(\"Path not in allowed directories: {}\", path)\n    ))\n}\n</code></pre>"},{"location":"develop/rust/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"develop/rust/testing/#server-integration-tests","title":"Server Integration Tests","text":"<pre><code>// tests/integration/server_tests.rs\nuse mcp_server_rust::{Server, config::Settings, testing::*};\nuse reqwest;\nuse serde_json::json;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\n#[tokio::test]\nasync fn test_server_startup_and_health() {\n    init_test_logging();\n    \n    let config = test_config();\n    let server = Server::new(config).await.unwrap();\n    \n    // Start server in background\n    let server_handle = tokio::spawn(async move {\n        server.run().await\n    });\n    \n    // Give server time to start\n    sleep(Duration::from_millis(100)).await;\n    \n    // Test health endpoint\n    let client = reqwest::Client::new();\n    let response = client\n        .get(\"http://127.0.0.1:8000/health\")\n        .send()\n        .await\n        .unwrap();\n    \n    assert!(response.status().is_success());\n    \n    // Cleanup\n    server_handle.abort();\n}\n\n#[tokio::test]\nasync fn test_tool_listing_endpoint() {\n    init_test_logging();\n    \n    let mut config = test_config();\n    config.server.port = 0; // Use random port\n    \n    let server = Server::new(config).await.unwrap();\n    let server_handle = tokio::spawn(async move {\n        server.run().await\n    });\n    \n    sleep(Duration::from_millis(100)).await;\n    \n    let client = reqwest::Client::new();\n    let response = client\n        .post(\"http://127.0.0.1:8000/\")\n        .json(&amp;json!({\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"method\": \"tools/list\",\n            \"params\": {}\n        }))\n        .send()\n        .await\n        .unwrap();\n    \n    assert!(response.status().is_success());\n    \n    let body: serde_json::Value = response.json().await.unwrap();\n    assert_eq!(body[\"jsonrpc\"], \"2.0\");\n    assert_eq!(body[\"id\"], 1);\n    assert!(body[\"result\"][\"tools\"].is_array());\n    \n    server_handle.abort();\n}\n</code></pre>"},{"location":"develop/rust/testing/#performance-testing-and-benchmarks","title":"Performance Testing and Benchmarks","text":""},{"location":"develop/rust/testing/#benchmark-configuration","title":"Benchmark Configuration","text":"<pre><code>// benches/tool_benchmarks.rs\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\nuse mcp_server_rust::{tools::*, config::*};\nuse std::collections::HashMap;\nuse serde_json::json;\nuse tokio::runtime::Runtime;\n\nfn benchmark_http_tool(c: &amp;mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    \n    let config = HttpToolConfig {\n        allowed_domains: None,\n        blocked_domains: None,\n        timeout: 30,\n        max_response_size: 1024 * 1024,\n    };\n    \n    let tool = HttpTool::new(config).unwrap();\n    \n    c.bench_function(\"http_tool_validation\", |b| {\n        b.iter(|| {\n            let mut arguments = HashMap::new();\n            arguments.insert(\"url\".to_string(), json!(\"https://httpbin.org/get\"));\n            arguments.insert(\"method\".to_string(), json!(\"GET\"));\n            \n            black_box(tool.validate_arguments(&amp;arguments))\n        });\n    });\n    \n    c.bench_function(\"http_tool_execute\", |b| {\n        b.to_async(&amp;rt).iter(|| async {\n            let mut arguments = HashMap::new();\n            arguments.insert(\"url\".to_string(), json!(\"https://httpbin.org/get\"));\n            arguments.insert(\"method\".to_string(), json!(\"GET\"));\n            \n            black_box(tool.execute(arguments).await)\n        });\n    });\n}\n\nfn benchmark_filesystem_tool(c: &amp;mut Criterion) {\n    let rt = Runtime::new().unwrap();\n    \n    let temp_dir = tempfile::tempdir().unwrap();\n    let test_file = temp_dir.path().join(\"benchmark.txt\");\n    std::fs::write(&amp;test_file, \"benchmark content\".repeat(1000)).unwrap();\n    \n    let config = FilesystemToolConfig {\n        allowed_paths: vec![temp_dir.path().to_string_lossy().into_owned()],\n        max_file_size: 1024 * 1024,\n        read_only: true,\n    };\n    \n    let tool = FilesystemTool::new(config);\n    \n    c.bench_function(\"filesystem_tool_read\", |b| {\n        b.to_async(&amp;rt).iter(|| async {\n            let mut arguments = HashMap::new();\n            arguments.insert(\"operation\".to_string(), json!(\"read_file\"));\n            arguments.insert(\"path\".to_string(), json!(test_file.to_string_lossy()));\n            \n            black_box(tool.execute(arguments).await)\n        });\n    });\n}\n\ncriterion_group!(benches, benchmark_http_tool, benchmark_filesystem_tool);\ncriterion_main!(benches);\n</code></pre>"},{"location":"develop/rust/testing/#test-organization","title":"Test Organization","text":""},{"location":"develop/rust/testing/#test-directory-structure","title":"Test Directory Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 integration/\n\u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u251c\u2500\u2500 server_tests.rs\n\u2502   \u251c\u2500\u2500 tool_integration_tests.rs\n\u2502   \u2514\u2500\u2500 resource_tests.rs\n\u251c\u2500\u2500 common/\n\u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u251c\u2500\u2500 fixtures.rs\n\u2502   \u2514\u2500\u2500 test_data.rs\n\u2514\u2500\u2500 e2e/\n    \u251c\u2500\u2500 mod.rs\n    \u2514\u2500\u2500 full_workflow_tests.rs\n</code></pre>"},{"location":"develop/rust/testing/#test-makefile-targets","title":"Test Makefile Targets","text":"<pre><code># Makefile\n.PHONY: test test-unit test-integration test-bench test-coverage\n\n# Run all tests\ntest: test-unit test-integration\n\n# Run unit tests only\ntest-unit:\n\tcargo test --lib\n\n# Run integration tests\ntest-integration:\n\tcargo test --test '*'\n\n# Run benchmarks\ntest-bench:\n\tcargo bench\n\n# Generate coverage report\ntest-coverage:\n\tcargo tarpaulin --out html --output-dir target/coverage\n\n# Run tests with specific features\ntest-database:\n\tcargo test --features database\n\n# Run property-based tests\ntest-property:\n\tcargo test --features quickcheck\n\n# Clean test artifacts\nclean-test:\n\tcargo clean\n\trm -rf target/coverage\n</code></pre>"},{"location":"develop/rust/testing/#test-configuration-files","title":"Test Configuration Files","text":""},{"location":"develop/rust/testing/#cicd-testing","title":"CI/CD Testing","text":"<pre><code># .github/workflows/test.yml\nname: Test\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    name: Test Suite\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        rust: [stable, beta, nightly]\n\n    services:\n      postgres:\n        image: postgres:15\n        env:\n          POSTGRES_PASSWORD: postgres\n          POSTGRES_DB: test_db\n        options: &gt;-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Install Rust\n      uses: dtolnay/rust-toolchain@master\n      with:\n        toolchain: ${{ matrix.rust }}\n        components: rustfmt, clippy\n\n    - name: Cache dependencies\n      uses: actions/cache@v3\n      with:\n        path: |\n          ~/.cargo/registry\n          ~/.cargo/git\n          target\n        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n\n    - name: Run tests\n      run: cargo test --all-features\n      env:\n        DATABASE_URL: postgres://postgres:postgres@localhost/test_db\n\n    - name: Run clippy\n      run: cargo clippy -- -D warnings\n\n    - name: Run rustfmt\n      run: cargo fmt -- --check\n\n    - name: Generate coverage\n      run: |\n        cargo install tarpaulin\n        cargo tarpaulin --all-features --out xml\n\n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n      with:\n        file: cobertura.xml\n</code></pre> <p>This comprehensive Rust testing guide ensures your MCP server is thoroughly tested with unit tests, integration tests, property-based tests, and performance benchmarks, following Rust best practices and leveraging the ecosystem's powerful testing tools.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-mcp","title":"What is MCP?","text":"<p>The Model Context Protocol (MCP) is a standardized protocol for enabling AI models to interact with external tools, resources, and services through a well-defined interface.</p>"},{"location":"faq/#why-should-i-use-mcp","title":"Why should I use MCP?","text":"<ul> <li>Standardization: Consistent interface across all integrations</li> <li>Security: Built-in authentication and authorization</li> <li>Scalability: Designed for distributed systems</li> <li>Flexibility: Multiple transport protocols and languages</li> <li>Ecosystem: Growing library of pre-built servers</li> </ul>"},{"location":"faq/#what-languages-are-supported","title":"What languages are supported?","text":"<p>Official SDKs: - Python (recommended) - JavaScript/TypeScript - Go</p> <p>Community SDKs: - Rust - Java - Ruby - C#</p>"},{"location":"faq/#getting-started","title":"Getting Started","text":""},{"location":"faq/#how-do-i-create-my-first-mcp-server","title":"How do I create my first MCP server?","text":"<pre><code>from mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"my_server\")\n\n@mcp.tool()\ndef hello(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre>"},{"location":"faq/#how-do-i-test-my-mcp-server","title":"How do I test my MCP server?","text":"<pre><code># Use MCP Inspector\nuv run mcp dev my_server.py\n\n# Or test with curl\ncurl -X POST http://localhost:8000/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}'\n</code></pre>"},{"location":"faq/#how-do-i-deploy-my-mcp-server","title":"How do I deploy my MCP server?","text":"<ol> <li>Package your server (Python wheel, NPM package, or container)</li> <li>Choose deployment platform (Kubernetes, Cloud Run, Lambda)</li> <li>Configure environment variables</li> <li>Set up monitoring and logging</li> <li>Deploy and verify health checks</li> </ol>"},{"location":"faq/#architecture","title":"Architecture","text":""},{"location":"faq/#whats-the-difference-between-tools-and-resources","title":"What's the difference between tools and resources?","text":"<ul> <li>Tools: Active operations that perform actions (functions)</li> <li>Resources: Passive data providers (configuration, state)</li> </ul>"},{"location":"faq/#should-i-create-one-server-with-many-tools-or-many-servers-with-few-tools","title":"Should I create one server with many tools or many servers with few tools?","text":"<p>Follow the single responsibility principle: - \u2705 One server per service/domain (GitHub server, Database server) - \u274c One monolithic server with all tools</p>"},{"location":"faq/#how-do-i-handle-authentication","title":"How do I handle authentication?","text":"<p>MCP supports multiple authentication methods: - API Keys (simplest) - Bearer tokens (JWT) - OAuth 2.0 (enterprise) - mTLS (highest security)</p>"},{"location":"faq/#performance","title":"Performance","text":""},{"location":"faq/#how-many-concurrent-requests-can-an-mcp-server-handle","title":"How many concurrent requests can an MCP server handle?","text":"<p>Depends on: - Server implementation (async vs sync) - Hardware resources - Tool complexity - Network latency</p> <p>Typical benchmarks: - Python async: 1000-5000 req/s - Go: 5000-20000 req/s - Node.js: 2000-8000 req/s</p>"},{"location":"faq/#how-can-i-improve-performance","title":"How can I improve performance?","text":"<ol> <li>Use async/await for I/O operations</li> <li>Implement connection pooling</li> <li>Add caching layers</li> <li>Use efficient serialization</li> <li>Optimize database queries</li> <li>Scale horizontally</li> </ol>"},{"location":"faq/#whats-the-recommended-timeout-for-mcp-requests","title":"What's the recommended timeout for MCP requests?","text":"<ul> <li>Default: 30 seconds</li> <li>Long operations: 5 minutes</li> <li>Real-time operations: 5 seconds</li> </ul> <p>Configure based on your use case.</p>"},{"location":"faq/#security","title":"Security","text":""},{"location":"faq/#how-do-i-secure-my-mcp-server","title":"How do I secure my MCP server?","text":"<ol> <li>Always use HTTPS in production</li> <li>Implement authentication</li> <li>Validate and sanitize all inputs</li> <li>Use environment variables for secrets</li> <li>Enable rate limiting</li> <li>Log security events</li> <li>Regular security scans</li> </ol>"},{"location":"faq/#can-i-restrict-which-tools-a-client-can-access","title":"Can I restrict which tools a client can access?","text":"<p>Yes, implement role-based access control (RBAC): </p><pre><code>@mcp.tool(roles=[\"admin\"])\ndef dangerous_operation():\n    # Only admins can access\n    pass\n</code></pre><p></p>"},{"location":"faq/#how-do-i-handle-sensitive-data","title":"How do I handle sensitive data?","text":"<ul> <li>Never log sensitive information</li> <li>Encrypt data in transit (TLS)</li> <li>Encrypt data at rest</li> <li>Use secure secret management</li> <li>Implement data retention policies</li> <li>Follow compliance requirements (GDPR, HIPAA)</li> </ul>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#my-server-wont-start","title":"My server won't start","text":"<p>Check: 1. Port availability: <code>lsof -i :8000</code> 2. Dependencies installed: <code>pip list</code> 3. Environment variables set 4. Syntax errors: <code>python -m py_compile my_server.py</code> 5. Permissions: file and network access</p>"},{"location":"faq/#tools-arent-showing-up","title":"Tools aren't showing up","text":"<p>Verify: 1. Tools are decorated with <code>@mcp.tool()</code> 2. Server is running: check health endpoint 3. No startup errors in logs 4. Correct MCP protocol version</p>"},{"location":"faq/#connection-refused-errors","title":"Connection refused errors","text":"<p>Troubleshoot: 1. Server is running: <code>ps aux | grep mcp</code> 2. Correct URL and port 3. Firewall rules allow connection 4. Network connectivity: <code>ping</code> and <code>traceroute</code> 5. DNS resolution: <code>nslookup</code></p>"},{"location":"faq/#best-practices","title":"Best Practices","text":""},{"location":"faq/#how-should-i-structure-my-mcp-server-project","title":"How should I structure my MCP server project?","text":"<pre><code>my-mcp-server/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 server/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 main.py\n\u2502       \u251c\u2500\u2500 tools.py\n\u2502       \u2514\u2500\u2500 resources.py\n\u251c\u2500\u2500 tests/\n\u251c\u2500\u2500 docs/\n\u251c\u2500\u2500 Containerfile\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"faq/#what-should-i-include-in-my-readme","title":"What should I include in my README?","text":"<ul> <li>Overview and purpose</li> <li>Installation instructions</li> <li>Configuration options</li> <li>Available tools and resources</li> <li>Usage examples</li> <li>Troubleshooting guide</li> <li>Contributing guidelines</li> </ul>"},{"location":"faq/#how-do-i-version-my-mcp-server","title":"How do I version my MCP server?","text":"<p>Use semantic versioning: - MAJOR: Breaking changes - MINOR: New features (backward compatible) - PATCH: Bug fixes</p> <p>Example: <code>1.2.3</code></p>"},{"location":"faq/#integration","title":"Integration","text":""},{"location":"faq/#how-do-i-integrate-with-claude-desktop","title":"How do I integrate with Claude Desktop?","text":"<pre><code>uv run mcp install my_server.py --name \"My Server\"\n</code></pre>"},{"location":"faq/#how-do-i-connect-to-mcp-gateway","title":"How do I connect to MCP Gateway?","text":"<pre><code>curl -X POST http://gateway:4444/servers \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -d '{\"name\":\"my-server\",\"url\":\"http://localhost:8000/mcp\"}'\n</code></pre>"},{"location":"faq/#can-i-use-mcp-with-other-ai-models","title":"Can I use MCP with other AI models?","text":"<p>Yes, MCP is model-agnostic. Any system that can make HTTP requests and handle JSON can use MCP.</p>"},{"location":"faq/#advanced-topics","title":"Advanced Topics","text":""},{"location":"faq/#how-do-i-implement-streaming-responses","title":"How do I implement streaming responses?","text":"<pre><code>@mcp.tool()\nasync def stream_data():\n    async def generate():\n        for i in range(10):\n            yield f\"Data chunk {i}\\n\"\n            await asyncio.sleep(1)\n    \n    return StreamingResponse(generate())\n</code></pre>"},{"location":"faq/#can-i-chain-multiple-mcp-servers","title":"Can I chain multiple MCP servers?","text":"<p>Yes, servers can call other servers: </p><pre><code>@mcp.tool()\nasync def orchestrate():\n    result1 = await call_server(\"server1\", \"tool1\")\n    result2 = await call_server(\"server2\", \"tool2\", result1)\n    return result2\n</code></pre><p></p>"},{"location":"faq/#how-do-i-implement-custom-transports","title":"How do I implement custom transports?","text":"<p>Extend the base transport class: </p><pre><code>class CustomTransport(MCPTransport):\n    def send(self, message):\n        # Custom send logic\n        pass\n    \n    def receive(self):\n        # Custom receive logic\n        pass\n</code></pre><p></p>"},{"location":"faq/#common-errors","title":"Common Errors","text":""},{"location":"faq/#method-not-found","title":"\"Method not found\"","text":"<p>The requested method doesn't exist. Check: - Spelling of method name - Tool is registered - Correct server URL</p>"},{"location":"faq/#invalid-parameters","title":"\"Invalid parameters\"","text":"<p>Parameters don't match schema. Verify: - Parameter names - Data types - Required fields - JSON formatting</p>"},{"location":"faq/#internal-server-error","title":"\"Internal server error\"","text":"<p>Server encountered an error. Check: - Server logs for stack trace - Database connectivity - External service availability - Resource limits</p>"},{"location":"faq/#migration","title":"Migration","text":""},{"location":"faq/#migrating-from-rest-api-to-mcp","title":"Migrating from REST API to MCP","text":"<ol> <li>Map endpoints to tools</li> <li>Convert request/response to MCP format</li> <li>Add MCP server alongside REST</li> <li>Gradually migrate clients</li> <li>Deprecate REST endpoints</li> </ol>"},{"location":"faq/#migrating-between-mcp-versions","title":"Migrating between MCP versions","text":"<ol> <li>Review breaking changes</li> <li>Update SDK version</li> <li>Modify code for new APIs</li> <li>Test thoroughly</li> <li>Deploy with version compatibility</li> </ol>"},{"location":"faq/#community","title":"Community","text":""},{"location":"faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>GitHub Discussions</li> <li>Discord community</li> <li>Stack Overflow (#mcp tag)</li> <li>Official documentation</li> </ul>"},{"location":"faq/#how-can-i-contribute","title":"How can I contribute?","text":"<ul> <li>Report bugs</li> <li>Submit pull requests</li> <li>Write documentation</li> <li>Create example servers</li> <li>Help others in community</li> </ul>"},{"location":"faq/#are-there-example-mcp-servers","title":"Are there example MCP servers?","text":"<p>Yes, check the official repositories: - Time server (simple example) - GitHub tools (complex example) - File system (resource example) - Database connector (integration example)</p>"},{"location":"faq/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udd27 Troubleshooting Guide</li> <li>\ud83d\udca1 Common Patterns</li> <li>\ud83d\ude80 Migration Guide</li> </ul>"},{"location":"manage/","title":"Management Guide","text":""},{"location":"manage/#management-guide","title":"Management Guide","text":""},{"location":"manage/#lifecycle-management-for-mcp-servers","title":"Lifecycle Management for MCP Servers","text":"<p>Effective management ensures MCP servers remain reliable, secure, and performant throughout their lifecycle.</p>"},{"location":"manage/#management-phases","title":"Management Phases","text":""},{"location":"manage/#1-planning","title":"1. Planning","text":"<ul> <li>Requirements gathering</li> <li>Architecture design</li> <li>Resource allocation</li> <li>Risk assessment</li> </ul>"},{"location":"manage/#2-development","title":"2. Development","text":"<ul> <li>Implementation</li> <li>Testing</li> <li>Documentation</li> <li>Code review</li> </ul>"},{"location":"manage/#3-deployment","title":"3. Deployment","text":"<ul> <li>Environment setup</li> <li>Configuration management</li> <li>Release process</li> <li>Rollout strategy</li> </ul>"},{"location":"manage/#4-operation","title":"4. Operation","text":"<ul> <li>Monitoring</li> <li>Maintenance</li> <li>Support</li> <li>Optimization</li> </ul>"},{"location":"manage/#5-evolution","title":"5. Evolution","text":"<ul> <li>Updates and patches</li> <li>Feature additions</li> <li>Performance tuning</li> <li>Security hardening</li> </ul>"},{"location":"manage/#configuration-management","title":"Configuration Management","text":""},{"location":"manage/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code># config/production.yaml\nserver:\n  port: 8000\n  host: 0.0.0.0\n  workers: 4\n\ndatabase:\n  host: prod-db.example.com\n  pool_size: 20\n  \nmonitoring:\n  enabled: true\n  level: info\n  \nrate_limiting:\n  enabled: true\n  max_requests: 100\n  window: 60\n</code></pre>"},{"location":"manage/#dynamic-configuration","title":"Dynamic Configuration","text":"<pre><code>class ConfigManager:\n    def __init__(self):\n        self.config = self.load_config()\n        self.watch_changes()\n    \n    def load_config(self):\n        env = os.getenv('MCP_ENV', 'development')\n        return load_yaml(f'config/{env}.yaml')\n    \n    def watch_changes(self):\n        # Watch for config file changes\n        observer = Observer()\n        observer.schedule(ConfigHandler(self), 'config/')\n        observer.start()\n</code></pre>"},{"location":"manage/#version-management","title":"Version Management","text":""},{"location":"manage/#semantic-versioning","title":"Semantic Versioning","text":"<pre><code>MAJOR.MINOR.PATCH\n\n1.0.0 - Initial release\n1.0.1 - Bug fix\n1.1.0 - New feature (backward compatible)\n2.0.0 - Breaking change\n</code></pre>"},{"location":"manage/#api-versioning","title":"API Versioning","text":"<pre><code>@mcp.tool(version=\"1.0\")\ndef old_tool(param: str) -&gt; str:\n    \"\"\"Deprecated version\"\"\"\n    return process_v1(param)\n\n@mcp.tool(version=\"2.0\")\ndef new_tool(param: str, options: dict = None) -&gt; dict:\n    \"\"\"Current version with enhanced features\"\"\"\n    return process_v2(param, options)\n</code></pre>"},{"location":"manage/#dependency-management","title":"Dependency Management","text":""},{"location":"manage/#python-dependencies","title":"Python Dependencies","text":"<pre><code># pyproject.toml\n[project]\ndependencies = [\n    \"mcp&gt;=1.0,&lt;2.0\",  # Pin major version\n    \"pydantic~=2.5\",   # Compatible releases\n    \"requests==2.31.0\", # Exact version\n]\n\n[tool.pip-tools]\ngenerate-hashes = true\nresolver = \"backtracking\"\n</code></pre>"},{"location":"manage/#dependency-updates","title":"Dependency Updates","text":"<pre><code># Check for updates\npip list --outdated\n\n# Update dependencies\npip-compile --upgrade pyproject.toml\n\n# Security audit\npip-audit\n</code></pre>"},{"location":"manage/#health-monitoring","title":"Health Monitoring","text":""},{"location":"manage/#health-check-endpoint","title":"Health Check Endpoint","text":"<pre><code>@app.route('/health')\ndef health_check():\n    checks = {\n        'server': 'healthy',\n        'database': check_database(),\n        'dependencies': check_dependencies(),\n        'disk_space': check_disk_space(),\n        'memory': check_memory()\n    }\n    \n    status = 'healthy' if all(\n        v == 'healthy' for v in checks.values()\n    ) else 'unhealthy'\n    \n    return {\n        'status': status,\n        'timestamp': datetime.utcnow().isoformat(),\n        'checks': checks\n    }\n</code></pre>"},{"location":"manage/#metrics-collection","title":"Metrics Collection","text":"<pre><code>from prometheus_client import Counter, Histogram, Gauge\n\n# Define metrics\nrequest_count = Counter('mcp_requests_total', 'Total requests')\nrequest_duration = Histogram('mcp_request_duration_seconds', 'Request duration')\nactive_connections = Gauge('mcp_active_connections', 'Active connections')\n\n# Collect metrics\n@measure_time(request_duration)\ndef handle_request(request):\n    request_count.inc()\n    with active_connections.track_inprogress():\n        return process_request(request)\n</code></pre>"},{"location":"manage/#logging-strategy","title":"Logging Strategy","text":""},{"location":"manage/#structured-logging","title":"Structured Logging","text":"<pre><code>import structlog\n\nlogger = structlog.get_logger()\n\ndef process_tool(tool_name: str, params: dict):\n    logger.info(\n        \"tool_execution_started\",\n        tool=tool_name,\n        params=params,\n        timestamp=datetime.utcnow().isoformat()\n    )\n    \n    try:\n        result = execute_tool(tool_name, params)\n        logger.info(\n            \"tool_execution_completed\",\n            tool=tool_name,\n            duration_ms=elapsed_time\n        )\n        return result\n    except Exception as e:\n        logger.error(\n            \"tool_execution_failed\",\n            tool=tool_name,\n            error=str(e),\n            traceback=traceback.format_exc()\n        )\n        raise\n</code></pre>"},{"location":"manage/#log-aggregation","title":"Log Aggregation","text":"<pre><code># filebeat.yml\nfilebeat.inputs:\n- type: log\n  enabled: true\n  paths:\n    - /var/log/mcp-server/*.log\n  json.keys_under_root: true\n  json.add_error_key: true\n\noutput.elasticsearch:\n  hosts: [\"elasticsearch:9200\"]\n  index: \"mcp-logs-%{+yyyy.MM.dd}\"\n</code></pre>"},{"location":"manage/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"manage/#backup-strategy","title":"Backup Strategy","text":"<pre><code>class BackupManager:\n    def __init__(self):\n        self.backup_dir = '/backups'\n        self.retention_days = 30\n    \n    def backup_state(self):\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        backup_path = f\"{self.backup_dir}/backup_{timestamp}.tar.gz\"\n        \n        # Backup configuration\n        self.backup_config(backup_path)\n        \n        # Backup data\n        self.backup_data(backup_path)\n        \n        # Clean old backups\n        self.clean_old_backups()\n        \n        return backup_path\n</code></pre>"},{"location":"manage/#disaster-recovery","title":"Disaster Recovery","text":"<pre><code>#!/bin/bash\n# disaster_recovery.sh\n\n# Stop current server\nsystemctl stop mcp-server\n\n# Restore from backup\ntar -xzf /backups/latest.tar.gz -C /\n\n# Restore database\npsql &lt; /backups/database.sql\n\n# Start server\nsystemctl start mcp-server\n\n# Verify health\ncurl http://localhost:8000/health\n</code></pre>"},{"location":"manage/#change-management","title":"Change Management","text":""},{"location":"manage/#change-process","title":"Change Process","text":"<ol> <li>Request - Document change request</li> <li>Review - Technical and business review</li> <li>Approval - Get necessary approvals</li> <li>Testing - Test in staging environment</li> <li>Implementation - Deploy to production</li> <li>Verification - Verify successful deployment</li> <li>Documentation - Update documentation</li> </ol>"},{"location":"manage/#rollback-plan","title":"Rollback Plan","text":"<pre><code>class DeploymentManager:\n    def deploy(self, version: str):\n        # Save current version\n        self.save_rollback_point()\n        \n        try:\n            # Deploy new version\n            self.update_code(version)\n            self.run_migrations()\n            self.restart_services()\n            \n            # Verify deployment\n            if not self.verify_health():\n                raise DeploymentError(\"Health check failed\")\n                \n        except Exception as e:\n            logger.error(f\"Deployment failed: {e}\")\n            self.rollback()\n            raise\n    \n    def rollback(self):\n        logger.info(\"Starting rollback\")\n        self.restore_previous_version()\n        self.restart_services()\n        self.verify_health()\n</code></pre>"},{"location":"manage/#capacity-planning","title":"Capacity Planning","text":""},{"location":"manage/#resource-monitoring","title":"Resource Monitoring","text":"<pre><code>def monitor_resources():\n    return {\n        'cpu_percent': psutil.cpu_percent(interval=1),\n        'memory_percent': psutil.virtual_memory().percent,\n        'disk_usage': psutil.disk_usage('/').percent,\n        'network_connections': len(psutil.net_connections()),\n        'thread_count': threading.active_count()\n    }\n</code></pre>"},{"location":"manage/#scaling-strategy","title":"Scaling Strategy","text":"<pre><code># kubernetes/hpa.yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: mcp-server-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: mcp-server\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n</code></pre>"},{"location":"manage/#documentation-management","title":"Documentation Management","text":""},{"location":"manage/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>README.md - Quick start and overview</li> <li>API.md - Tool and resource documentation</li> <li>CONFIGURATION.md - Configuration options</li> <li>TROUBLESHOOTING.md - Common issues and solutions</li> <li>CHANGELOG.md - Version history</li> </ul>"},{"location":"manage/#documentation-generation","title":"Documentation Generation","text":"<pre><code>def generate_docs():\n    \"\"\"Generate documentation from code\"\"\"\n    docs = {\n        'tools': extract_tool_docs(),\n        'resources': extract_resource_docs(),\n        'configuration': extract_config_schema(),\n        'api_version': MCP_VERSION\n    }\n    \n    render_markdown(docs, 'docs/API.md')\n</code></pre>"},{"location":"manage/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udd04 Lifecycle Management</li> <li>\ud83d\udcc8 Versioning Strategy</li> <li>\ud83d\udccb Monitoring</li> <li>\ud83d\udce6 Updates and Patches</li> <li>\ud83d\udd19 Rollback Procedures</li> </ul>"},{"location":"operate/","title":"Operations Guide","text":""},{"location":"operate/#operations-guide","title":"Operations Guide","text":""},{"location":"operate/#operating-mcp-servers-in-production","title":"Operating MCP Servers in Production","text":"<p>Effective operations ensure MCP servers maintain high availability, performance, and reliability in production environments.</p>"},{"location":"operate/#operational-excellence","title":"Operational Excellence","text":""},{"location":"operate/#key-principles","title":"Key Principles","text":"<ol> <li>Observability - Monitor, log, trace everything</li> <li>Automation - Automate repetitive tasks</li> <li>Reliability - Design for failure</li> <li>Performance - Optimize continuously</li> <li>Security - Defense in depth</li> </ol>"},{"location":"operate/#operational-readiness","title":"Operational Readiness","text":""},{"location":"operate/#pre-production-checklist","title":"Pre-Production Checklist","text":"<ul> <li> Monitoring dashboards configured</li> <li> Alerts and notifications set up</li> <li> Logging pipeline established</li> <li> Backup and recovery tested</li> <li> Runbooks documented</li> <li> On-call rotation scheduled</li> <li> Incident response plan ready</li> <li> Capacity planning completed</li> </ul>"},{"location":"operate/#monitoring-strategy","title":"Monitoring Strategy","text":""},{"location":"operate/#four-golden-signals","title":"Four Golden Signals","text":"<ol> <li>Latency - Response time</li> <li>Traffic - Request rate</li> <li>Errors - Failure rate</li> <li>Saturation - Resource utilization</li> </ol>"},{"location":"operate/#key-metrics","title":"Key Metrics","text":"<pre><code># Application metrics\nmcp_requests_total\nmcp_request_duration_seconds\nmcp_errors_total\nmcp_active_connections\n\n# System metrics\ncpu_utilization_percent\nmemory_usage_bytes\ndisk_io_operations\nnetwork_throughput_bytes\n\n# Business metrics\ntools_executed_total\nresources_accessed_total\nuser_sessions_active\napi_quota_remaining\n</code></pre>"},{"location":"operate/#health-checks","title":"Health Checks","text":""},{"location":"operate/#liveness-probe","title":"Liveness Probe","text":"<pre><code>@app.route('/health/live')\ndef liveness():\n    \"\"\"Basic liveness check - is the process running?\"\"\"\n    return {'status': 'alive'}, 200\n</code></pre>"},{"location":"operate/#readiness-probe","title":"Readiness Probe","text":"<pre><code>@app.route('/health/ready')\ndef readiness():\n    \"\"\"Readiness check - can we serve traffic?\"\"\"\n    checks = {\n        'database': check_database_connection(),\n        'cache': check_cache_connection(),\n        'dependencies': check_external_services()\n    }\n    \n    if all(checks.values()):\n        return {'status': 'ready', 'checks': checks}, 200\n    else:\n        return {'status': 'not_ready', 'checks': checks}, 503\n</code></pre>"},{"location":"operate/#logging-best-practices","title":"Logging Best Practices","text":""},{"location":"operate/#structured-logging","title":"Structured Logging","text":"<pre><code>import structlog\n\nlogger = structlog.get_logger()\n\ndef process_request(request_id, tool_name, params):\n    logger.info(\n        \"request_started\",\n        request_id=request_id,\n        tool=tool_name,\n        params_size=len(str(params))\n    )\n    \n    try:\n        result = execute_tool(tool_name, params)\n        logger.info(\n            \"request_completed\",\n            request_id=request_id,\n            tool=tool_name,\n            duration_ms=elapsed_time,\n            result_size=len(str(result))\n        )\n        return result\n        \n    except Exception as e:\n        logger.error(\n            \"request_failed\",\n            request_id=request_id,\n            tool=tool_name,\n            error=str(e),\n            error_type=type(e).__name__\n        )\n        raise\n</code></pre>"},{"location":"operate/#log-aggregation","title":"Log Aggregation","text":"<pre><code># Fluentd configuration\n&lt;source&gt;\n  @type tail\n  path /var/log/mcp-server/*.log\n  pos_file /var/log/td-agent/mcp-server.pos\n  tag mcp.server\n  &lt;parse&gt;\n    @type json\n  &lt;/parse&gt;\n&lt;/source&gt;\n\n&lt;match mcp.**&gt;\n  @type elasticsearch\n  host elasticsearch.example.com\n  port 9200\n  logstash_format true\n  logstash_prefix mcp\n  &lt;buffer&gt;\n    @type file\n    path /var/log/td-agent/buffer/mcp\n    flush_interval 10s\n  &lt;/buffer&gt;\n&lt;/match&gt;\n</code></pre>"},{"location":"operate/#performance-management","title":"Performance Management","text":""},{"location":"operate/#performance-baseline","title":"Performance Baseline","text":"<pre><code># Establish baseline metrics\nPERFORMANCE_BASELINE = {\n    'p50_latency_ms': 100,\n    'p95_latency_ms': 500,\n    'p99_latency_ms': 1000,\n    'error_rate_percent': 0.1,\n    'requests_per_second': 1000\n}\n\ndef check_performance():\n    current_metrics = get_current_metrics()\n    \n    for metric, baseline in PERFORMANCE_BASELINE.items():\n        current = current_metrics[metric]\n        if current &gt; baseline * 1.5:  # 50% degradation\n            alert(f\"Performance degradation: {metric} = {current}\")\n</code></pre>"},{"location":"operate/#performance-tuning","title":"Performance Tuning","text":"<pre><code># Connection pooling\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\n    DATABASE_URL,\n    pool_size=20,\n    max_overflow=10,\n    pool_pre_ping=True,\n    pool_recycle=3600\n)\n\n# Caching strategy\nfrom functools import lru_cache\nimport redis\n\nredis_client = redis.Redis(decode_responses=True)\n\n@lru_cache(maxsize=1000)\ndef get_cached_result(key):\n    # Memory cache first\n    result = redis_client.get(key)\n    if result:\n        return json.loads(result)\n    \n    # Compute if not cached\n    result = compute_expensive_operation(key)\n    redis_client.setex(key, 3600, json.dumps(result))\n    return result\n</code></pre>"},{"location":"operate/#capacity-planning","title":"Capacity Planning","text":""},{"location":"operate/#resource-calculation","title":"Resource Calculation","text":"<pre><code>def calculate_capacity():\n    # Current metrics\n    avg_request_time = 100  # ms\n    peak_rps = 1000\n    cpu_per_request = 0.01  # cores\n    memory_per_connection = 10  # MB\n    \n    # Required resources\n    required_cores = peak_rps * cpu_per_request * 1.5  # 50% buffer\n    required_memory = peak_rps * memory_per_connection * 1.5\n    \n    # Instance sizing\n    instances_needed = math.ceil(required_cores / 4)  # 4 cores per instance\n    \n    return {\n        'cores_needed': required_cores,\n        'memory_needed_mb': required_memory,\n        'instances': instances_needed\n    }\n</code></pre>"},{"location":"operate/#backup-and-recovery","title":"Backup and Recovery","text":""},{"location":"operate/#backup-strategy","title":"Backup Strategy","text":"<pre><code>#!/bin/bash\n# backup.sh\n\nBACKUP_DIR=\"/backups/$(date +%Y%m%d)\"\nmkdir -p \"$BACKUP_DIR\"\n\n# Database backup\npg_dump $DATABASE_URL &gt; \"$BACKUP_DIR/database.sql\"\n\n# Configuration backup\ntar -czf \"$BACKUP_DIR/config.tar.gz\" /etc/mcp-server/\n\n# Application state backup\nredis-cli --rdb \"$BACKUP_DIR/redis.rdb\"\n\n# Upload to S3\naws s3 sync \"$BACKUP_DIR\" \"s3://backups/mcp-server/$(date +%Y%m%d)/\"\n\n# Cleanup old backups (keep 30 days)\nfind /backups -type d -mtime +30 -exec rm -rf {} +\n</code></pre>"},{"location":"operate/#disaster-recovery","title":"Disaster Recovery","text":"<pre><code>class DisasterRecovery:\n    def __init__(self):\n        self.backup_location = \"s3://backups/mcp-server/\"\n        self.recovery_point_objective = timedelta(hours=1)\n        self.recovery_time_objective = timedelta(minutes=30)\n    \n    def initiate_recovery(self, target_time):\n        # Find nearest backup\n        backup = self.find_backup(target_time)\n        \n        # Restore database\n        self.restore_database(backup['database'])\n        \n        # Restore configuration\n        self.restore_config(backup['config'])\n        \n        # Restore cache if needed\n        if self.should_restore_cache():\n            self.restore_cache(backup['cache'])\n        \n        # Verify recovery\n        if self.verify_recovery():\n            logger.info(\"Recovery successful\")\n            return True\n        else:\n            logger.error(\"Recovery failed\")\n            return False\n</code></pre>"},{"location":"operate/#maintenance-windows","title":"Maintenance Windows","text":""},{"location":"operate/#zero-downtime-maintenance","title":"Zero-Downtime Maintenance","text":"<pre><code>def rolling_update(new_version):\n    instances = get_all_instances()\n    batch_size = max(1, len(instances) // 4)  # Update 25% at a time\n    \n    for batch in chunks(instances, batch_size):\n        # Remove from load balancer\n        for instance in batch:\n            remove_from_lb(instance)\n        \n        # Wait for connections to drain\n        time.sleep(30)\n        \n        # Update instances\n        for instance in batch:\n            update_instance(instance, new_version)\n        \n        # Health check\n        for instance in batch:\n            wait_for_healthy(instance)\n        \n        # Add back to load balancer\n        for instance in batch:\n            add_to_lb(instance)\n        \n        # Monitor for issues\n        time.sleep(60)\n        if detect_issues():\n            rollback()\n            return False\n    \n    return True\n</code></pre>"},{"location":"operate/#troubleshooting","title":"Troubleshooting","text":""},{"location":"operate/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"operate/#high-latency","title":"High Latency","text":"<pre><code># Check slow queries\nSELECT query, mean_time, calls\nFROM pg_stat_statements\nORDER BY mean_time DESC\nLIMIT 10;\n\n# Check connection pool\nnetstat -an | grep :8000 | wc -l\n\n# Check CPU throttling\ntop -H -p $(pgrep mcp-server)\n</code></pre>"},{"location":"operate/#memory-leaks","title":"Memory Leaks","text":"<pre><code>import tracemalloc\nimport gc\n\n# Start tracing\ntracemalloc.start()\n\n# Take snapshot\nsnapshot = tracemalloc.take_snapshot()\ntop_stats = snapshot.statistics('lineno')\n\nfor stat in top_stats[:10]:\n    print(stat)\n\n# Force garbage collection\ngc.collect()\n</code></pre>"},{"location":"operate/#connection-errors","title":"Connection Errors","text":"<pre><code># Check network connectivity\nping -c 4 database.example.com\ntraceroute database.example.com\n\n# Check DNS resolution\nnslookup database.example.com\n\n# Check firewall rules\niptables -L -n -v\n</code></pre>"},{"location":"operate/#runbooks","title":"Runbooks","text":""},{"location":"operate/#sample-runbook-high-error-rate","title":"Sample Runbook: High Error Rate","text":"<pre><code>## Alert: High Error Rate\n\n### Symptoms\n- Error rate &gt; 1%\n- HTTP 5xx responses increasing\n\n### Initial Response (5 min)\n1. Check dashboards for error patterns\n2. Review recent deployments\n3. Check system resources\n\n### Investigation (15 min)\n1. Analyze error logs\n2. Check database connectivity\n3. Verify external dependencies\n4. Review recent changes\n\n### Mitigation\n1. If deployment issue: Rollback\n2. If resource issue: Scale up\n3. If dependency issue: Enable circuit breaker\n4. If database issue: Failover to replica\n\n### Resolution\n1. Fix root cause\n2. Deploy fix\n3. Monitor for recurrence\n4. Update documentation\n\n### Post-Incident\n1. Write incident report\n2. Update runbook if needed\n3. Schedule post-mortem\n</code></pre>"},{"location":"operate/#compliance-and-auditing","title":"Compliance and Auditing","text":""},{"location":"operate/#audit-logging","title":"Audit Logging","text":"<pre><code>def audit_log(event_type, user, action, resource, result):\n    audit_entry = {\n        'timestamp': datetime.utcnow().isoformat(),\n        'event_type': event_type,\n        'user': user,\n        'action': action,\n        'resource': resource,\n        'result': result,\n        'ip_address': request.remote_addr,\n        'user_agent': request.user_agent.string\n    }\n    \n    # Write to audit log\n    audit_logger.info(json.dumps(audit_entry))\n    \n    # Store in audit database\n    audit_db.insert(audit_entry)\n</code></pre>"},{"location":"operate/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udcca Monitoring Deep Dive</li> <li>\ud83d\udcdc Logging Strategy</li> <li>\ud83c\udfaf Performance Optimization</li> <li>\ud83c\udf21\ufe0f Scaling Operations</li> <li>\ud83c\udf86 Incident Response</li> </ul>"},{"location":"overview/","title":"Introduction","text":""},{"location":"overview/#mcp-overview","title":"MCP Overview","text":""},{"location":"overview/#introduction","title":"Introduction","text":"<p>The Model Context Protocol (MCP) is a standardized protocol for communication between AI models and external tools, resources, and services. This guide provides comprehensive best practices for developing, deploying, and maintaining MCP servers.</p>"},{"location":"overview/#what-is-mcp","title":"What is MCP?","text":"<p>MCP enables AI assistants to interact with external systems through a well-defined protocol, allowing them to:</p> <ul> <li>Access and manipulate data from various sources</li> <li>Execute tools and functions</li> <li>Provide contextual information to enhance AI responses</li> <li>Maintain secure and controlled interactions with external services</li> </ul>"},{"location":"overview/#why-mcp","title":"Why MCP?","text":""},{"location":"overview/#key-benefits","title":"Key Benefits","text":"<ul> <li>Standardization: Consistent interface across all integrations</li> <li>Security: Built-in authentication and authorization mechanisms</li> <li>Scalability: Designed for distributed architectures</li> <li>Flexibility: Support for multiple transport protocols</li> <li>Observability: Built-in monitoring and logging capabilities</li> </ul>"},{"location":"overview/#core-components","title":"Core Components","text":"<ol> <li>MCP Servers: Expose tools, resources, and prompts</li> <li>MCP Clients: Connect to servers and utilize their capabilities</li> <li>MCP Gateway: Central hub for managing multiple MCP servers</li> <li>Transport Layer: Communication protocols (STDIO, HTTP, WebSocket)</li> </ol>"},{"location":"overview/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>\ud83c\udfd7\ufe0f Architecture - System design and components</li> <li>\ud83d\udd11 Core Concepts - Fundamental MCP concepts</li> <li>\ud83d\udccb Standards - MCP protocol standards</li> <li>\ud83d\udea6 Getting Started - Quick start guide</li> </ul>"},{"location":"overview/architecture/","title":"Architecture","text":""},{"location":"overview/architecture/#mcp-architecture","title":"MCP Architecture","text":""},{"location":"overview/architecture/#system-architecture","title":"System Architecture","text":"<p>The Model Context Protocol follows a client-server architecture with optional gateway intermediaries for enterprise deployments.</p>"},{"location":"overview/architecture/#components-overview","title":"Components Overview","text":""},{"location":"overview/architecture/#mcp-server","title":"MCP Server","text":"<p>The foundation of the MCP ecosystem, servers expose: - Tools: Executable functions with defined inputs/outputs - Resources: Data and content providers - Prompts: Pre-configured interaction templates</p>"},{"location":"overview/architecture/#mcp-client","title":"MCP Client","text":"<p>Clients connect to servers and can: - Discover available capabilities - Execute tools with parameters - Fetch resources for context - Utilize prompts for interactions</p>"},{"location":"overview/architecture/#mcp-gateway","title":"MCP Gateway","text":"<p>Enterprise-grade component that: - Manages multiple MCP servers - Provides centralized authentication - Enables load balancing and failover - Offers unified API access</p>"},{"location":"overview/architecture/#communication-patterns","title":"Communication Patterns","text":""},{"location":"overview/architecture/#direct-connection","title":"Direct Connection","text":"<pre><code>Client &lt;---&gt; MCP Server\n</code></pre>"},{"location":"overview/architecture/#gateway-pattern","title":"Gateway Pattern","text":"<pre><code>Client &lt;---&gt; Gateway &lt;---&gt; MCP Server 1\n                      &lt;---&gt; MCP Server 2\n                      &lt;---&gt; MCP Server N\n</code></pre>"},{"location":"overview/architecture/#transport-protocols","title":"Transport Protocols","text":"<p>MCP defines two standard transport mechanisms:</p> Protocol Use Case Description stdio Local processes Client launches server as subprocess, communicates via stdin/stdout Streamable HTTP Remote servers HTTP POST for client-to-server, optional Server-Sent Events for streaming"},{"location":"overview/architecture/#stdio-transport","title":"stdio Transport","text":"<ul> <li>Client launches MCP server as subprocess</li> <li>Server reads JSON-RPC messages from stdin</li> <li>Server writes JSON-RPC messages to stdout</li> <li>Messages delimited by newlines, no embedded newlines</li> <li>Server may log to stderr (captured by client)</li> </ul>"},{"location":"overview/architecture/#streamable-http-transport","title":"Streamable HTTP Transport","text":"<ul> <li>Client sends JSON-RPC via HTTP POST to MCP endpoint</li> <li>Server responds with either JSON or Server-Sent Events</li> <li>Supports standard HTTP authentication (Bearer tokens, API keys)</li> <li>Enables remote server deployment and scaling</li> </ul>"},{"location":"overview/architecture/#data-flow","title":"Data Flow","text":"<ol> <li>Discovery: Client queries available capabilities</li> <li>Invocation: Client calls tools with parameters</li> <li>Processing: Server executes requested operations</li> <li>Response: Server returns results to client</li> </ol>"},{"location":"overview/architecture/#security-layers","title":"Security Layers","text":"<ul> <li>Authentication: Bearer tokens, API keys</li> <li>Authorization: Role-based access control</li> <li>Encryption: TLS for network transport</li> <li>Validation: Input/output sanitization</li> </ul>"},{"location":"overview/at-a-glance/","title":"MCP at a Glance","text":""},{"location":"overview/at-a-glance/#mcp-at-a-glance","title":"MCP at a Glance","text":"<p>A concise, high\u2011level summary for teams adopting the Model Context Protocol (MCP). Use this page as your orientation before diving into detailed sections.</p>"},{"location":"overview/at-a-glance/#what-mcp-is","title":"What MCP Is","text":"<ul> <li>A standard client\u2011server protocol to expose capabilities as tools, resources, and prompts.</li> <li>Transports: <code>stdio</code> for local per\u2011user use; Streamable HTTP for shared, remote services.</li> <li>Optional gateway centralizes authN/Z, routing, catalogs, quotas, and policy enforcement across many servers.</li> </ul>"},{"location":"overview/at-a-glance/#when-to-use-mcp","title":"When to Use MCP","text":"<ul> <li>You want a consistent, discoverable interface for tools and context across apps.</li> <li>You need security, auditability, and policy control for integrations.</li> <li>You operate multiple servers, tenants, or environments and need central governance.</li> </ul> <p>If you just need a single bespoke integration with minimal control, direct integration might be simpler.</p>"},{"location":"overview/at-a-glance/#server-responsibilities","title":"Server Responsibilities","text":"<ul> <li>Expose narrowly scoped tools with typed input/output schemas and explicit side effects.</li> <li>Provide resources for read\u2011only context; publish prompts for standardized interactions.</li> <li>Implement authentication/authorization, logging, and metrics.</li> <li>Keep execution stateless by default; externalize state with clear TTLs and PII handling.</li> </ul>"},{"location":"overview/at-a-glance/#transport-choice","title":"Transport Choice","text":"<ul> <li><code>stdio</code>: local, per\u2011user, strong isolation, minimal ops; limited for centralized operations.</li> <li>Streamable HTTP: shared, remote, scalable; requires full production hardening (TLS, auth, SLOs).</li> </ul>"},{"location":"overview/at-a-glance/#gateway-pattern-when-needed","title":"Gateway Pattern (When Needed)","text":"<ul> <li>Identity and scope brokering, routing/health, quotas/rate limits.</li> <li>Policy as code (allow/deny, environment gating, approvals, sensitive\u2011data rules).</li> <li>Catalog/registry, audit correlation, emergency kill switches.</li> </ul>"},{"location":"overview/at-a-glance/#tool-design-basics","title":"Tool Design Basics","text":"<ul> <li>Specific and actionable descriptions; document constraints and side effects.</li> <li>Version tool schemas; prefer additive changes; publish deprecation timelines.</li> <li>Read\u2011only by default; enable write tools behind explicit roles and policies.</li> <li>Long\u2011running work: async handles and status; idempotency keys; compensating actions.</li> </ul>"},{"location":"overview/at-a-glance/#security-basics","title":"Security Basics","text":"<ul> <li>Least privilege per tool/action; fine\u2011grained authorization.</li> <li>Validate inputs/outputs; sanitize outputs to avoid downstream injection.</li> <li>Secrets in a manager; TLS everywhere; signed artifacts; restricted egress/ingress.</li> </ul>"},{"location":"overview/at-a-glance/#observability-essentials","title":"Observability Essentials","text":"<ul> <li>Structured audit logs: who/what/when/why; arguments redacted; outcomes captured.</li> <li>Metrics: success rate, latency, error classes, approvals, policy denials, cost/quotas.</li> <li>Traces where applicable; correlate via gateway or request IDs.</li> </ul>"},{"location":"overview/at-a-glance/#versioning-promotion","title":"Versioning &amp; Promotion","text":"<ul> <li>Pin SDKs, dependencies, tool schemas, and configurations; record environment/decoding.</li> <li>SBOMs and signatures for servers and dependencies.</li> <li>Canary/shadow with rollback; publish release notes and impact levels.</li> </ul>"},{"location":"overview/at-a-glance/#slos-and-runbooks","title":"SLOs and Runbooks","text":"<ul> <li>Define p95 latency, success rate, and error budgets per critical tool.</li> <li>Runbooks for dependency failures, rate\u2011limit responses, and rollbacks; on\u2011call routing.</li> </ul>"},{"location":"overview/at-a-glance/#quick-checklists","title":"Quick Checklists","text":"<ul> <li>Readiness: authN/Z, schemas, redaction, logs/metrics, health endpoints, rate limits, runbooks.</li> <li>Security: secrets, TLS, least privilege, approvals for risky operations, egress policy.</li> <li>Operations: scaling plan, budgets/quotas, caching/batching, circuit breakers, load tests.</li> </ul> <p>See also: Architecture, Core Concepts, Standards, and Getting Started.</p>"},{"location":"overview/core-concepts/","title":"Core Concepts","text":""},{"location":"overview/core-concepts/#core-concepts","title":"Core Concepts","text":""},{"location":"overview/core-concepts/#fundamental-mcp-concepts","title":"Fundamental MCP Concepts","text":"<p>Understanding these core concepts is essential for working with the Model Context Protocol.</p>"},{"location":"overview/core-concepts/#tools","title":"Tools","text":"<p>Tools are the primary mechanism for exposing functionality through MCP.</p>"},{"location":"overview/core-concepts/#tool-definition","title":"Tool Definition","text":"<ul> <li>Name: Unique identifier for the tool</li> <li>Description: Human-readable explanation</li> <li>Parameters: Typed input schema (JSON Schema)</li> <li>Return Type: Expected output format</li> </ul>"},{"location":"overview/core-concepts/#protocol-methods","title":"Protocol Methods","text":"<ul> <li>Discovery: <code>tools/list</code> - Lists available tools</li> <li>Execution: <code>tools/call</code> - Executes a specific tool</li> </ul>"},{"location":"overview/core-concepts/#example-tool-definition","title":"Example Tool Definition","text":"<pre><code>{\n  \"name\": \"calculate_sum\",\n  \"description\": \"Add two numbers together\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"a\": {\"type\": \"number\"},\n      \"b\": {\"type\": \"number\"}\n    },\n    \"required\": [\"a\", \"b\"]\n  }\n}\n</code></pre>"},{"location":"overview/core-concepts/#resources","title":"Resources","text":"<p>Resources provide contextual data to AI models without requiring explicit tool calls.</p>"},{"location":"overview/core-concepts/#resource-types","title":"Resource Types","text":"<ul> <li>Static: Fixed content (configuration, documentation)</li> <li>Dynamic: Real-time data (status, metrics)</li> <li>Streaming: Continuous updates (logs, events)</li> </ul>"},{"location":"overview/core-concepts/#resource-uris","title":"Resource URIs","text":"<p>Resources use URI schemes for identification: - <code>file://path/to/resource</code> - <code>config://settings/app</code> - <code>status://health/check</code></p>"},{"location":"overview/core-concepts/#protocol-methods_1","title":"Protocol Methods","text":"<ul> <li>Discovery: <code>resources/list</code> - Lists available resources</li> <li>Access: <code>resources/read</code> - Retrieves resource content</li> <li>Templates: <code>resources/templates/list</code> - Lists resource templates</li> <li>Monitoring: <code>resources/subscribe</code> - Monitors resource changes</li> </ul>"},{"location":"overview/core-concepts/#prompts","title":"Prompts","text":"<p>Pre-configured interaction templates that guide AI behavior.</p>"},{"location":"overview/core-concepts/#prompt-components","title":"Prompt Components","text":"<ul> <li>Name: Identifier for the prompt</li> <li>Description: Purpose and usage</li> <li>Arguments: Dynamic values to inject</li> <li>Template: The actual prompt text</li> </ul>"},{"location":"overview/core-concepts/#protocol-methods_2","title":"Protocol Methods","text":"<ul> <li>Discovery: <code>prompts/list</code> - Lists available prompts</li> <li>Retrieval: <code>prompts/get</code> - Retrieves a specific prompt</li> </ul>"},{"location":"overview/core-concepts/#contexts","title":"Contexts","text":"<p>Execution contexts provide: - Logging: Structured logging capabilities - Progress: Status updates for long operations - Cancellation: Graceful operation termination - Metadata: Request-specific information</p>"},{"location":"overview/core-concepts/#messages","title":"Messages","text":"<p>MCP uses JSON-RPC 2.0 for message formatting.</p>"},{"location":"overview/core-concepts/#message-types","title":"Message Types","text":"<ol> <li>Request: Client-initiated operations</li> <li>Response: Server results</li> <li>Notification: Async events</li> <li>Error: Structured error responses</li> </ol>"},{"location":"overview/core-concepts/#capabilities","title":"Capabilities","text":"<p>Servers declare their capabilities during initialization: - Supported tools - Available resources - Protocol version - Transport options</p>"},{"location":"overview/core-concepts/#sessions","title":"Sessions","text":"<p>Stateful connections between clients and servers: - Session establishment - Capability negotiation - State management - Graceful termination</p>"},{"location":"overview/getting-started/","title":"Getting Started","text":""},{"location":"overview/getting-started/#getting-started","title":"Getting Started","text":""},{"location":"overview/getting-started/#quick-start-guide","title":"Quick Start Guide","text":"<p>Get up and running with MCP in minutes.</p>"},{"location":"overview/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+ or Node.js 18+</li> <li>Git for version control</li> <li>Text editor or IDE</li> <li>Terminal/Command line access</li> </ul>"},{"location":"overview/getting-started/#installation","title":"Installation","text":""},{"location":"overview/getting-started/#python","title":"Python","text":"<pre><code># Using uv (recommended)\nuv add mcp\n\n# Using pip\npip install mcp\n</code></pre>"},{"location":"overview/getting-started/#nodejs","title":"Node.js","text":"<pre><code>npm install @modelcontextprotocol/sdk\n</code></pre>"},{"location":"overview/getting-started/#your-first-mcp-server","title":"Your First MCP Server","text":""},{"location":"overview/getting-started/#step-1-create-server-file","title":"Step 1: Create Server File","text":"<pre><code># hello_mcp.py\nimport asyncio\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\nfrom mcp.types import Tool, TextContent\n\n# Create server instance\nserver = Server(\"hello-server\")\n\n@server.list_tools()\nasync def list_tools():\n    return [\n        Tool(\n            name=\"say_hello\",\n            description=\"Greet someone by name\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\"type\": \"string\"}\n                },\n                \"required\": [\"name\"]\n            }\n        )\n    ]\n\n@server.call_tool()\nasync def call_tool(name: str, arguments: dict):\n    if name == \"say_hello\":\n        name_arg = arguments.get(\"name\", \"World\")\n        return [TextContent(type=\"text\", text=f\"Hello, {name_arg}!\")]\n    \n    raise ValueError(f\"Unknown tool: {name}\")\n\nasync def main():\n    async with stdio_server() as (read_stream, write_stream):\n        await server.run(read_stream, write_stream)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"overview/getting-started/#step-2-run-the-server","title":"Step 2: Run the Server","text":"<pre><code># STDIO mode (for development and testing)\npython hello_mcp.py\n</code></pre>"},{"location":"overview/getting-started/#step-3-test-your-server","title":"Step 3: Test Your Server","text":"<p>You can test your MCP server using:</p> <ol> <li> <p>MCP Inspector (development tool): </p><pre><code>npx @modelcontextprotocol/inspector python hello_mcp.py\n</code></pre><p></p> </li> <li> <p>Claude Desktop: Add to your configuration file</p> </li> <li> <p>Manual JSON-RPC testing: The server communicates via stdio using JSON-RPC messages</p> </li> </ol>"},{"location":"overview/getting-started/#next-steps","title":"Next Steps","text":""},{"location":"overview/getting-started/#essential-reading","title":"Essential Reading","text":"<ul> <li>\ud83d\udccb Standards - Protocol specifications</li> <li>\ud83c\udfd7\ufe0f Architecture - System design</li> <li>\ud83d\udcbb Development Guide - Language-specific guides</li> </ul>"},{"location":"overview/getting-started/#hands-on-tutorials","title":"Hands-On Tutorials","text":"<ol> <li>Building a GitHub Integration</li> <li>Creating a Database Connector</li> <li>Implementing Authentication</li> </ol>"},{"location":"overview/getting-started/#sample-projects","title":"Sample Projects","text":"<ul> <li>Time Server</li> <li>File System Server</li> <li>GitHub Tools</li> </ul>"},{"location":"overview/getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"overview/getting-started/#tool-registration","title":"Tool Registration","text":"<pre><code>@mcp.tool()\ndef my_tool(param: str) -&gt; str:\n    \"\"\"Tool description\"\"\"\n    return result\n</code></pre>"},{"location":"overview/getting-started/#resource-exposure","title":"Resource Exposure","text":"<pre><code>@mcp.resource(\"config://settings\")\ndef get_settings() -&gt; str:\n    return json.dumps(config)\n</code></pre>"},{"location":"overview/getting-started/#error-handling","title":"Error Handling","text":"<pre><code>@mcp.tool()\ndef safe_operation(data: str) -&gt; str:\n    try:\n        return process(data)\n    except Exception as e:\n        raise McpError(f\"Operation failed: {e}\")\n</code></pre>"},{"location":"overview/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"overview/getting-started/#common-issues","title":"Common Issues","text":"<p>Port Already in Use </p><pre><code># Find process using port\nlsof -i :8000\n# Kill process or use different port\n</code></pre><p></p> <p>Module Not Found </p><pre><code># Ensure MCP is installed\npip list | grep mcp\n# Reinstall if needed\npip install --upgrade \"mcp[cli]\"\n</code></pre><p></p> <p>Connection Refused - Check server is running - Verify correct port - Check firewall settings</p>"},{"location":"overview/getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcda Documentation</li> <li>\ud83d\udcac Community Forum</li> <li>\ud83d\udc1b Issue Tracker</li> <li>\u2753 FAQ</li> </ul>"},{"location":"overview/server-anatomy/","title":"Server Anatomy","text":""},{"location":"overview/server-anatomy/#mcp-server-anatomy","title":"MCP Server Anatomy","text":"<p>Understand the core elements MCP servers expose and how to design them for clarity, safety, and maintainability.</p>"},{"location":"overview/server-anatomy/#capabilities","title":"Capabilities","text":"<ul> <li>Tools: Executable actions with typed input/output schemas, explicit constraints, and disclosed side effects.</li> <li>Resources: Read\u2011only data/context providers (files, records, documents) with stable identifiers and access controls.</li> <li>Prompts: Predefined interaction templates that standardize tasks and reduce prompt drift.</li> </ul>"},{"location":"overview/server-anatomy/#tool-contracts-highlevel","title":"Tool Contracts (High\u2011Level)","text":"<ul> <li>Schemas: Define strict input/output contracts (types, ranges, formats) and provide examples in documentation.</li> <li>Errors: Enumerate error classes with machine\u2011actionable codes and human\u2011readable messages.</li> <li>Side effects: Declare mutations (create/update/delete) and external impacts; require idempotency for create/update.</li> <li>Authorization: Specify scopes/roles required per tool; require approvals for high\u2011impact operations.</li> </ul>"},{"location":"overview/server-anatomy/#discovery-and-versioning","title":"Discovery and Versioning","text":"<ul> <li>Discovery: Provide names, descriptions, schemas, and versions for tools, resources, and prompts.</li> <li>Versioning: Use semantic versions and content hashes for contracts; prefer additive changes; publish deprecation timelines.</li> <li>Feature flags: Surface optional capabilities and environment/tenant differences in discovery responses.</li> </ul>"},{"location":"overview/server-anatomy/#state-and-longrunning-work","title":"State and Long\u2011Running Work","text":"<ul> <li>Stateless by default: Externalize state (cache/DB) with clear TTLs and PII handling; avoid hidden server memory.</li> <li>Asynchronous patterns: For long operations, return a handle and provide status/list tools; support callbacks/webhooks where appropriate.</li> <li>Compensations: Offer rollback tools for reversible side effects; log irreversible actions with approvals and change tickets.</li> </ul>"},{"location":"overview/server-anatomy/#documentation-essentials","title":"Documentation Essentials","text":"<ul> <li>Purpose: One sentence describing the server\u2019s domain and boundaries.</li> <li>Capabilities: List tools/resources/prompts with concise, specific descriptions and constraints.</li> <li>Contracts: Link to input/output definitions and error catalogs; include examples of typical calls and responses.</li> <li>Policies: State required scopes, approvals, rate limits, and environment/tenant differences.</li> <li>Operations: Provide SLOs, health endpoints, runbooks, and support contacts.</li> </ul>"},{"location":"overview/standards/","title":"Standards","text":""},{"location":"overview/standards/#mcp-standards","title":"MCP Standards","text":""},{"location":"overview/standards/#protocol-standards","title":"Protocol Standards","text":"<p>The Model Context Protocol follows established standards and conventions to ensure interoperability and consistency.</p>"},{"location":"overview/standards/#protocol-version","title":"Protocol Version","text":"<p>Current version: 2025-06-18</p>"},{"location":"overview/standards/#version-format","title":"Version Format","text":"<p>MCP uses date-based versioning format: <code>YYYY-MM-DD</code> - Each revision represents the protocol state at that date - Breaking changes are indicated in the changelog - Implementations must support capability negotiation</p>"},{"location":"overview/standards/#message-format","title":"Message Format","text":"<p>MCP uses JSON-RPC 2.0 specification.</p>"},{"location":"overview/standards/#request-structure","title":"Request Structure","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"tool_name\",\n    \"arguments\": {}\n  },\n  \"id\": 1\n}\n</code></pre>"},{"location":"overview/standards/#response-structure","title":"Response Structure","text":"<pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"result\": {\n    \"content\": []\n  },\n  \"id\": 1\n}\n</code></pre>"},{"location":"overview/standards/#naming-conventions","title":"Naming Conventions","text":""},{"location":"overview/standards/#tools","title":"Tools","text":"<ul> <li>Format: <code>snake_case</code></li> <li>Examples: <code>get_user</code>, <code>create_ticket</code>, <code>fetch_data</code></li> </ul>"},{"location":"overview/standards/#resources","title":"Resources","text":"<ul> <li>Format: URI scheme</li> <li>Examples: <code>file://docs/readme</code>, <code>config://app/settings</code></li> </ul>"},{"location":"overview/standards/#environment-variables","title":"Environment Variables","text":"<ul> <li>Format: <code>SCREAMING_SNAKE_CASE</code> with role prefix</li> <li>Examples: <code>MCP_GITHUB_TOKEN</code>, <code>MCP_SERVER_PORT</code></li> </ul>"},{"location":"overview/standards/#error-codes","title":"Error Codes","text":"<p>Standard JSON-RPC error codes plus MCP-specific ranges:</p> Code Range Description -32700 to -32600 JSON-RPC protocol errors -32000 to -32099 MCP server errors -31000 to -31999 Tool execution errors -30000 to -30999 Resource access errors"},{"location":"overview/standards/#data-types","title":"Data Types","text":""},{"location":"overview/standards/#primitive-types","title":"Primitive Types","text":"<ul> <li><code>string</code>: UTF-8 text</li> <li><code>number</code>: JSON number (float/int)</li> <li><code>boolean</code>: true/false</li> <li><code>null</code>: Null value</li> </ul>"},{"location":"overview/standards/#complex-types","title":"Complex Types","text":"<ul> <li><code>object</code>: JSON object with schema</li> <li><code>array</code>: Ordered list of values</li> </ul>"},{"location":"overview/standards/#content-types","title":"Content Types","text":"<p>MCP supports multiple content types in responses:</p> Type Description Example <code>text</code> Plain text content Error messages, simple responses <code>image</code> Base64 encoded images Screenshots, diagrams <code>resource</code> Resource references File paths, URIs"},{"location":"overview/standards/#transport-standards","title":"Transport Standards","text":""},{"location":"overview/standards/#http","title":"HTTP","text":"<ul> <li>Endpoint: <code>/mcp</code></li> <li>Methods: POST only</li> <li>Content-Type: <code>application/json</code></li> <li>Authentication: Bearer token in Authorization header</li> </ul>"},{"location":"overview/standards/#websocket","title":"WebSocket","text":"<ul> <li>Subprotocol: <code>mcp.v1</code></li> <li>Ping/Pong: Every 30 seconds</li> <li>Message framing: Text frames with JSON</li> </ul>"},{"location":"overview/standards/#compliance-requirements","title":"Compliance Requirements","text":"<p>All MCP implementations must: 1. Support JSON-RPC 2.0 2. Implement capability discovery 3. Provide error handling 4. Support graceful shutdown 5. Include health checks</p>"},{"location":"package/","title":"Packaging Guide","text":""},{"location":"package/#packaging-guide","title":"Packaging Guide","text":""},{"location":"package/#packaging-and-distribution-for-mcp-servers","title":"Packaging and Distribution for MCP Servers","text":"<p>Proper packaging ensures MCP servers can be easily installed, deployed, and maintained across different environments.</p>"},{"location":"package/#packaging-strategies","title":"Packaging Strategies","text":""},{"location":"package/#language-specific-packages","title":"Language-Specific Packages","text":"<ul> <li>Python: PyPI packages with pip/uv</li> <li>JavaScript: NPM packages</li> <li>Go: Go modules</li> <li>Rust: Cargo crates</li> </ul>"},{"location":"package/#container-images","title":"Container Images","text":"<ul> <li>Docker/Podman containers</li> <li>OCI-compliant images</li> <li>Multi-stage builds</li> <li>Minimal base images</li> </ul>"},{"location":"package/#binary-distributions","title":"Binary Distributions","text":"<ul> <li>Platform-specific executables</li> <li>Static binaries</li> <li>Cross-compilation</li> </ul>"},{"location":"package/#package-structure","title":"Package Structure","text":""},{"location":"package/#standard-layout","title":"Standard Layout","text":"<pre><code>my-mcp-server/\n\u251c\u2500\u2500 src/                 # Source code\n\u251c\u2500\u2500 tests/              # Test files\n\u251c\u2500\u2500 docs/               # Documentation\n\u251c\u2500\u2500 configs/            # Configuration files\n\u251c\u2500\u2500 scripts/            # Build/deploy scripts\n\u251c\u2500\u2500 Containerfile       # Container definition\n\u251c\u2500\u2500 Makefile           # Build automation\n\u251c\u2500\u2500 pyproject.toml     # Python package config\n\u251c\u2500\u2500 package.json       # Node.js package config\n\u251c\u2500\u2500 go.mod             # Go module config\n\u251c\u2500\u2500 LICENSE            # License file\n\u251c\u2500\u2500 README.md          # Documentation\n\u2514\u2500\u2500 CHANGELOG.md       # Version history\n</code></pre>"},{"location":"package/#python-packaging","title":"Python Packaging","text":""},{"location":"package/#pyprojecttoml-configuration","title":"pyproject.toml Configuration","text":"<pre><code>[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"mcp-server-example\"\nversion = \"1.0.0\"\ndescription = \"Example MCP Server\"\nreadme = \"README.md\"\nlicense = \"MIT\"\nauthors = [\n    {name = \"Your Name\", email = \"you@example.com\"}\n]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3.11\",\n]\ndependencies = [\n    \"mcp[cli]&gt;=1.0.0\",\n    \"pydantic&gt;=2.0\",\n    \"aiohttp&gt;=3.9\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0\",\n    \"ruff&gt;=0.1\",\n    \"mypy&gt;=1.0\",\n]\n\n[project.scripts]\nmcp-example = \"mcp_server_example.main:cli\"\n\n[project.entry-points.\"mcp.server\"]\nexample = \"mcp_server_example:server\"\n</code></pre>"},{"location":"package/#building-python-package","title":"Building Python Package","text":"<pre><code># Install build tools\npip install build twine\n\n# Build package\npython -m build\n\n# Check package\ntwine check dist/*\n\n# Upload to PyPI\ntwine upload dist/*\n</code></pre>"},{"location":"package/#javascriptnpm-packaging","title":"JavaScript/NPM Packaging","text":""},{"location":"package/#packagejson-configuration","title":"package.json Configuration","text":"<pre><code>{\n  \"name\": \"@yourorg/mcp-server-example\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Example MCP Server\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"prepublishOnly\": \"npm run build &amp;&amp; npm test\",\n    \"test\": \"jest\"\n  },\n  \"files\": [\n    \"dist\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"keywords\": [\"mcp\", \"server\", \"ai\"],\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.0.0\",\n    \"jest\": \"^29.0.0\"\n  },\n  \"engines\": {\n    \"node\": \"&gt;=18.0.0\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\",\n    \"registry\": \"https://registry.npmjs.org/\"\n  }\n}\n</code></pre>"},{"location":"package/#publishing-to-npm","title":"Publishing to NPM","text":"<pre><code># Login to NPM\nnpm login\n\n# Build and test\nnpm run build\nnpm test\n\n# Publish\nnpm publish --access public\n</code></pre>"},{"location":"package/#container-packaging","title":"Container Packaging","text":""},{"location":"package/#multi-stage-dockerfile","title":"Multi-Stage Dockerfile","text":"<pre><code># Build stage\nFROM python:3.11-slim as builder\n\nWORKDIR /build\n\n# Install build dependencies\nRUN pip install --no-cache-dir build\n\n# Copy source\nCOPY pyproject.toml README.md ./\nCOPY src ./src\n\n# Build wheel\nRUN python -m build --wheel\n\n# Runtime stage\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Install runtime dependencies\nCOPY --from=builder /build/dist/*.whl /tmp/\nRUN pip install --no-cache-dir /tmp/*.whl &amp;&amp; rm /tmp/*.whl\n\n# Create non-root user\nRUN useradd -m -u 1000 mcp &amp;&amp; chown -R mcp:mcp /app\nUSER mcp\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD python -c \"import requests; requests.get('http://localhost:8000/health')\"\n\nEXPOSE 8000\n\nCMD [\"python\", \"-m\", \"mcp_server_example\"]\n</code></pre>"},{"location":"package/#building-container-images","title":"Building Container Images","text":"<pre><code># Build with Docker\ndocker build -t mcp-server-example:latest .\n\n# Build with Podman\npodman build -t mcp-server-example:latest .\n\n# Multi-platform build\ndocker buildx build --platform linux/amd64,linux/arm64 \\\n  -t mcp-server-example:latest .\n</code></pre>"},{"location":"package/#binary-distribution","title":"Binary Distribution","text":""},{"location":"package/#go-binary-building","title":"Go Binary Building","text":"<pre><code># Build for current platform\ngo build -o mcp-server cmd/server/main.go\n\n# Cross-compilation\nGOOS=linux GOARCH=amd64 go build -o mcp-server-linux-amd64\nGOOS=darwin GOARCH=arm64 go build -o mcp-server-darwin-arm64\nGOOS=windows GOARCH=amd64 go build -o mcp-server-windows.exe\n\n# Static binary\nCGO_ENABLED=0 go build -ldflags=\"-s -w\" -o mcp-server\n</code></pre>"},{"location":"package/#rust-binary-building","title":"Rust Binary Building","text":"<pre><code># Build release binary\ncargo build --release\n\n# Cross-compilation with cross\ncross build --target x86_64-unknown-linux-musl --release\n\n# Optimize for size\ncargo build --release --features minimal\nstrip target/release/mcp-server\n</code></pre>"},{"location":"package/#package-metadata","title":"Package Metadata","text":""},{"location":"package/#version-information","title":"Version Information","text":"<pre><code># src/mcp_server_example/__version__.py\n__version__ = \"1.0.0\"\n__author__ = \"Your Name\"\n__email__ = \"you@example.com\"\n__description__ = \"Example MCP Server\"\n\ndef get_version_info():\n    return {\n        \"version\": __version__,\n        \"author\": __author__,\n        \"description\": __description__,\n        \"build_date\": BUILD_DATE,\n        \"git_commit\": GIT_COMMIT\n    }\n</code></pre>"},{"location":"package/#license-selection","title":"License Selection","text":"<pre><code>Common Open Source Licenses:\n- MIT: Simple, permissive\n- Apache 2.0: Patent protection\n- GPL v3: Copyleft\n- BSD 3-Clause: Similar to MIT\n- MPL 2.0: File-level copyleft\n</code></pre>"},{"location":"package/#distribution-channels","title":"Distribution Channels","text":""},{"location":"package/#package-registries","title":"Package Registries","text":"<ul> <li>PyPI: Python packages</li> <li>NPM: JavaScript packages</li> <li>Docker Hub: Container images</li> <li>GitHub Packages: Multi-format registry</li> <li>Artifactory: Enterprise registry</li> </ul>"},{"location":"package/#github-releases","title":"GitHub Releases","text":"<pre><code># .github/workflows/release.yml\nname: Release\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Build packages\n      run: |\n        make build\n        make package\n    \n    - name: Create Release\n      uses: softprops/action-gh-release@v1\n      with:\n        files: |\n          dist/*\n          binaries/*\n        generate_release_notes: true\n</code></pre>"},{"location":"package/#package-security","title":"Package Security","text":""},{"location":"package/#signing-packages","title":"Signing Packages","text":"<pre><code># GPG signing for Python packages\ngpg --detach-sign -a dist/package-1.0.0.tar.gz\n\n# NPM package signing\nnpm pack --sign\n\n# Container image signing with cosign\ncosign sign docker.io/myorg/mcp-server:latest\n</code></pre>"},{"location":"package/#sbom-generation","title":"SBOM Generation","text":"<pre><code># Generate SBOM with syft\nsyft packages dir:. -o spdx-json &gt; sbom.json\n\n# Include in container\nCOPY sbom.json /usr/share/doc/sbom.json\n</code></pre>"},{"location":"package/#installation-methods","title":"Installation Methods","text":""},{"location":"package/#quick-install-scripts","title":"Quick Install Scripts","text":"<pre><code>#!/bin/bash\n# install.sh\n\nset -e\n\n# Detect OS and architecture\nOS=$(uname -s | tr '[:upper:]' '[:lower:]')\nARCH=$(uname -m)\n\n# Download appropriate binary\nURL=\"https://github.com/org/mcp-server/releases/latest/download/mcp-server-${OS}-${ARCH}\"\ncurl -L \"$URL\" -o mcp-server\n\n# Make executable and install\nchmod +x mcp-server\nsudo mv mcp-server /usr/local/bin/\n\necho \"MCP Server installed successfully!\"\n</code></pre>"},{"location":"package/#package-managers","title":"Package Managers","text":"<pre><code># Homebrew (macOS/Linux)\nbrew tap yourorg/mcp\nbrew install mcp-server\n\n# APT (Debian/Ubuntu)\nsudo add-apt-repository ppa:yourorg/mcp\nsudo apt update\nsudo apt install mcp-server\n\n# YUM/DNF (RHEL/Fedora)\nsudo dnf config-manager --add-repo https://repo.example.com/mcp.repo\nsudo dnf install mcp-server\n</code></pre>"},{"location":"package/#versioning-strategy","title":"Versioning Strategy","text":""},{"location":"package/#semantic-versioning","title":"Semantic Versioning","text":"<pre><code>1.0.0 - Initial stable release\n1.0.1 - Bug fixes only\n1.1.0 - New features (backward compatible)\n2.0.0 - Breaking changes\n\nPre-release versions:\n1.0.0-alpha.1\n1.0.0-beta.1\n1.0.0-rc.1\n</code></pre>"},{"location":"package/#compatibility-matrix","title":"Compatibility Matrix","text":"<pre><code>| MCP Server | MCP SDK | Python | Node.js |\n|------------|---------|--------|---------|\n| 1.0.x      | &gt;=1.0   | &gt;=3.10 | &gt;=16    |\n| 1.1.x      | &gt;=1.1   | &gt;=3.11 | &gt;=18    |\n| 2.0.x      | &gt;=2.0   | &gt;=3.11 | &gt;=20    |\n</code></pre>"},{"location":"package/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udc0d Python Packaging Details</li> <li>\ud83d\udce6 NPM Packaging</li> <li>\ud83d\udc33 Container Packaging</li> <li>\ud83d\udcda Distribution Strategies</li> </ul>"},{"location":"secure/","title":"Security Guide","text":""},{"location":"secure/#security-guide","title":"Security Guide","text":""},{"location":"secure/#security-best-practices-for-mcp-servers","title":"Security Best Practices for MCP Servers","text":"<p>Security is paramount when building MCP servers that interact with external systems and handle sensitive data.</p>"},{"location":"secure/#security-principles","title":"Security Principles","text":""},{"location":"secure/#defense-in-depth","title":"Defense in Depth","text":"<p>Implement multiple layers of security controls: 1. Network Security - Firewalls, TLS, VPNs, CORS 2. Application Security - Input validation, output encoding 3. Data Security - Encryption at rest and in transit 4. Access Control - Authentication and authorization 5. Monitoring - Logging, alerting, incident response 6. Container Security - Signed containers, syscall restrictions</p>"},{"location":"secure/#zero-trust-architecture","title":"Zero Trust Architecture","text":"<ul> <li>Never trust, always verify</li> <li>Least privilege access</li> <li>Assume breach mindset</li> <li>Continuous verification</li> </ul>"},{"location":"secure/#network-security","title":"Network Security","text":"<ul> <li>TLS: Always use TLS in production</li> <li>CORS: Configure proper Cross-Origin Resource Sharing policies</li> <li>Container Signing: Only use containers signed by trusted providers</li> <li>Trusted Repositories: Download MCP servers from verified sources only</li> </ul>"},{"location":"secure/#common-security-threats","title":"Common Security Threats","text":""},{"location":"secure/#owasp-top-10-for-apis","title":"OWASP Top 10 for APIs","text":"<ol> <li>Broken Object Level Authorization</li> <li>Broken Authentication</li> <li>Excessive Data Exposure</li> <li>Lack of Resources &amp; Rate Limiting</li> <li>Broken Function Level Authorization</li> <li>Mass Assignment</li> <li>Security Misconfiguration</li> <li>Injection</li> <li>Improper Assets Management</li> <li>Insufficient Logging &amp; Monitoring</li> </ol>"},{"location":"secure/#security-checklist","title":"Security Checklist","text":""},{"location":"secure/#development-phase","title":"Development Phase","text":"<ul> <li> Input validation implemented</li> <li> Output encoding applied</li> <li> Authentication required</li> <li> Authorization checks in place</li> <li> Secrets stored securely</li> <li> Dependencies scanned</li> <li> Code reviewed for security</li> </ul>"},{"location":"secure/#deployment-phase","title":"Deployment Phase","text":"<ul> <li> TLS/SSL configured</li> <li> Firewall rules defined</li> <li> Rate limiting enabled</li> <li> Monitoring configured</li> <li> Backup strategy implemented</li> <li> Incident response plan ready</li> </ul>"},{"location":"secure/#secure-coding-practices","title":"Secure Coding Practices","text":""},{"location":"secure/#input-validation","title":"Input Validation","text":"<pre><code>from pydantic import BaseModel, validator\nimport re\n\nclass SecureInput(BaseModel):\n    email: str\n    url: str\n\n    @validator('email')\n    def validate_email(cls, v):\n        pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\n        if not re.match(pattern, v):\n            raise ValueError('Invalid email format')\n        return v\n\n    @validator('url')\n    def validate_url(cls, v):\n        if not v.startswith(('http://', 'https://')):\n            raise ValueError('URL must start with http:// or https://')\n        return v\n</code></pre>"},{"location":"secure/#sql-injection-prevention","title":"SQL Injection Prevention","text":"<pre><code># BAD - Vulnerable to SQL injection\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"\n\n# GOOD - Parameterized query\nquery = \"SELECT * FROM users WHERE id = %s\"\ncursor.execute(query, (user_id,))\n</code></pre>"},{"location":"secure/#xss-prevention","title":"XSS Prevention","text":"<pre><code>// BAD - Direct HTML insertion\nelement.innerHTML = userInput;\n\n// GOOD - Text content only\nelement.textContent = userInput;\n\n// GOOD - Sanitized HTML\nelement.innerHTML = DOMPurify.sanitize(userInput);\n</code></pre>"},{"location":"secure/#authentication-and-authorization","title":"Authentication and Authorization","text":""},{"location":"secure/#oauth-20-implementation","title":"OAuth 2.0 Implementation","text":"<pre><code># OAuth flow implementation\nclass OAuthHandler:\n    def __init__(self, client_id, client_secret):\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n    def get_authorization_url(self, scopes: List[str]) -&gt; str:\n        # OAuth scopes should be granular - separate read/write permissions\n        scope_string = \" \".join(scopes)\n        return f\"https://auth.provider.com/oauth/authorize?client_id={self.client_id}&amp;scope={scope_string}&amp;response_type=code\"\n\n    def exchange_code_for_token(self, code: str) -&gt; dict:\n        # Token exchange implementation\n        # Include scope validation and token storage\n        pass\n</code></pre>"},{"location":"secure/#oauth-scopes-strategy","title":"OAuth Scopes Strategy","text":"<ul> <li>Granular Permissions: Use separate scopes for read and write operations</li> <li>Service-Specific: Different scopes for each service the MCP server connects to</li> <li>Principle of Least Privilege: Request minimal scopes needed</li> </ul>"},{"location":"secure/#dynamic-client-registration","title":"Dynamic Client Registration","text":"<pre><code># Support dynamic OAuth client registration\ndef register_oauth_client(client_info: dict) -&gt; dict:\n    # Validate client information\n    # Register with OAuth provider\n    # Return client credentials\n    return {\n        \"client_id\": generated_id,\n        \"client_secret\": generated_secret,\n        \"registration_access_token\": access_token\n    }\n</code></pre>"},{"location":"secure/#api-key-authentication","title":"API Key Authentication","text":"<pre><code>def verify_api_key(api_key: str) -&gt; bool:\n    hashed_key = hashlib.sha256(api_key.encode()).hexdigest()\n    return hashed_key in VALID_API_KEYS\n</code></pre>"},{"location":"secure/#jwt-authentication","title":"JWT Authentication","text":"<pre><code>import jwt\n\ndef create_token(user_id: str) -&gt; str:\n    payload = {\n        'user_id': user_id,\n        'exp': datetime.utcnow() + timedelta(hours=1)\n    }\n    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')\n\ndef verify_token(token: str) -&gt; dict:\n    try:\n        return jwt.decode(token, SECRET_KEY, algorithms=['HS256'])\n    except jwt.InvalidTokenError:\n        raise AuthenticationError('Invalid token')\n</code></pre>"},{"location":"secure/#rate-limiting","title":"Rate Limiting","text":""},{"location":"secure/#implementation-example","title":"Implementation Example","text":"<pre><code>from functools import wraps\nfrom collections import defaultdict\nimport time\n\nrate_limits = defaultdict(list)\n\ndef rate_limit(max_calls: int, period: int):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(request, *args, **kwargs):\n            client_id = get_client_id(request)\n            now = time.time()\n\n            # Clean old entries\n            rate_limits[client_id] = [\n                t for t in rate_limits[client_id]\n                if now - t &lt; period\n            ]\n\n            if len(rate_limits[client_id]) &gt;= max_calls:\n                raise RateLimitError('Rate limit exceeded')\n\n            rate_limits[client_id].append(now)\n            return func(request, *args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"secure/#secrets-management","title":"Secrets Management","text":""},{"location":"secure/#environment-variables","title":"Environment Variables","text":"<pre><code>import os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Never commit .env files\nAPI_KEY = os.getenv('MCP_API_KEY')\nif not API_KEY:\n    raise ValueError('MCP_API_KEY not configured')\n</code></pre>"},{"location":"secure/#secret-stores","title":"Secret Stores","text":"<pre><code># AWS Secrets Manager example\nimport boto3\n\ndef get_secret(secret_name: str) -&gt; str:\n    client = boto3.client('secretsmanager')\n    response = client.get_secret_value(SecretId=secret_name)\n    return response['SecretString']\n</code></pre>"},{"location":"secure/#security-headers","title":"Security Headers","text":""},{"location":"secure/#http-security-headers","title":"HTTP Security Headers","text":"<pre><code>def add_security_headers(response):\n    response.headers['X-Content-Type-Options'] = 'nosniff'\n    response.headers['X-Frame-Options'] = 'DENY'\n    response.headers['X-XSS-Protection'] = '1; mode=block'\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\n    return response\n</code></pre>"},{"location":"secure/#logging-and-monitoring","title":"Logging and Monitoring","text":""},{"location":"secure/#security-event-logging","title":"Security Event Logging","text":"<pre><code>import logging\n\nsecurity_logger = logging.getLogger('security')\n\ndef log_security_event(event_type: str, details: dict):\n    security_logger.warning(f\"SECURITY_EVENT: {event_type}\", extra={\n        'event_type': event_type,\n        'timestamp': datetime.utcnow().isoformat(),\n        'details': details\n    })\n\n# Usage\nlog_security_event('AUTHENTICATION_FAILED', {\n    'user': username,\n    'ip': request.remote_addr,\n    'reason': 'Invalid password'\n})\n</code></pre>"},{"location":"secure/#vulnerability-scanning","title":"Vulnerability Scanning","text":""},{"location":"secure/#dependency-scanning","title":"Dependency Scanning","text":"<pre><code># Python\npip-audit\nsafety check\n\n# JavaScript\nnpm audit\nyarn audit\n\n# Go\ngo list -m all | nancy sleuth\n</code></pre>"},{"location":"secure/#container-scanning","title":"Container Scanning","text":"<pre><code># Trivy\ntrivy image my-mcp-server:latest\n\n# Grype\ngrype my-mcp-server:latest\n</code></pre>"},{"location":"secure/#static-code-analysis-sast","title":"Static Code Analysis (SAST)","text":"<pre><code># Python\nbandit -r src/\nsemgrep --config=auto src/\n\n# JavaScript/TypeScript\neslint --ext .js,.ts src/\nnpm audit\n\n# Go\ngosec ./...\nstaticcheck ./...\n</code></pre>"},{"location":"secure/#container-security","title":"Container Security","text":""},{"location":"secure/#secure-container-practices","title":"Secure Container Practices","text":"<ul> <li>Minimal Base Images: Use distroless or minimal base images</li> <li>Non-root Users: Run containers as non-root users</li> <li>Read-only Filesystems: Mount filesystems as read-only when possible</li> <li>Syscall Filtering: Restrict system calls using seccomp profiles</li> </ul>"},{"location":"secure/#container-signing","title":"Container Signing","text":"<pre><code># Sign container images\ncosign sign my-mcp-server:latest\n\n# Verify signatures\ncosign verify --key cosign.pub my-mcp-server:latest\n</code></pre>"},{"location":"secure/#secure-dockerfile","title":"Secure Dockerfile","text":"<pre><code>FROM gcr.io/distroless/python3-debian11\n\n# Create non-root user\nUSER 10001:10001\n\n# Copy application\nCOPY --chown=10001:10001 src/ /app/src/\n\n# Set read-only root filesystem\nUSER 10001\nWORKDIR /app\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --retries=3 \\\n  CMD curl -f http://localhost:8000/health || exit 1\n\nCMD [\"python\", \"-m\", \"src.server\"]\n</code></pre>"},{"location":"secure/#production-security-checklist","title":"Production Security Checklist","text":""},{"location":"secure/#minimum-requirements-for-production","title":"Minimum Requirements for Production","text":""},{"location":"secure/#server-side-http-transport","title":"Server-side (HTTP Transport)","text":"<ul> <li> Hosted by trusted provider with security certifications</li> <li> TLS/SSL enabled with valid certificates</li> <li> Rate limiting implemented</li> <li> Input validation on all endpoints</li> <li> Authentication required for all operations</li> <li> Authorization checks implemented</li> <li> Logging and monitoring configured</li> <li> Security headers implemented</li> <li> Container signed by trusted authority</li> <li> CORS policies properly configured</li> </ul>"},{"location":"secure/#client-side-stdio-transport","title":"Client-side (STDIO Transport)","text":"<ul> <li> Container signed by trusted provider</li> <li> Minimal container with no unnecessary tools</li> <li> Syscall restrictions implemented</li> <li> Read-only filesystem where possible</li> <li> Resource limits configured</li> <li> Network isolation when appropriate</li> </ul>"},{"location":"secure/#incident-response","title":"Incident Response","text":""},{"location":"secure/#response-plan","title":"Response Plan","text":"<ol> <li>Detect - Identify security incident</li> <li>Contain - Limit damage scope</li> <li>Investigate - Determine root cause</li> <li>Remediate - Fix vulnerability</li> <li>Recover - Restore normal operations</li> <li>Review - Post-incident analysis</li> </ol>"},{"location":"secure/#compliance","title":"Compliance","text":""},{"location":"secure/#common-standards","title":"Common Standards","text":"<ul> <li>GDPR - Data protection and privacy</li> <li>SOC 2 - Security controls</li> <li>ISO 27001 - Information security</li> <li>PCI DSS - Payment card security</li> <li>HIPAA - Healthcare data protection</li> </ul>"},{"location":"secure/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83d\udd11 Authentication</li> <li>\ud83d\udeaa Authorization</li> <li>\ud83d\udd10 Secrets Management</li> <li>\ud83d\udee1\ufe0f Input Validation</li> <li>\ud83d\udd0d Security Scanning</li> </ul>"},{"location":"test/","title":"Testing Guide","text":""},{"location":"test/#testing-guide","title":"Testing Guide","text":""},{"location":"test/#comprehensive-testing-for-mcp-servers","title":"Comprehensive Testing for MCP Servers","text":"<p>Testing is crucial for ensuring MCP servers are reliable, secure, and performant. This guide covers all testing levels from unit to end-to-end.</p>"},{"location":"test/#testing-pyramid","title":"Testing Pyramid","text":"<pre><code>        /\\\n       /E2E\\\n      /------\\\n     /  Integ \\\n    /----------\\\n   /    Unit    \\\n  /--------------\\\n</code></pre> <ol> <li>Unit Tests (70%) - Fast, isolated component tests</li> <li>Integration Tests (20%) - Component interaction tests</li> <li>End-to-End Tests (10%) - Full system workflow tests</li> </ol>"},{"location":"test/#testing-strategy","title":"Testing Strategy","text":""},{"location":"test/#what-to-test","title":"What to Test","text":""},{"location":"test/#critical-paths","title":"Critical Paths","text":"<ul> <li>Tool execution and responses</li> <li>Resource access and permissions</li> <li>Error handling and recovery</li> <li>Input validation and sanitization</li> <li>Authentication and authorization</li> </ul>"},{"location":"test/#edge-cases","title":"Edge Cases","text":"<ul> <li>Empty inputs</li> <li>Maximum size inputs</li> <li>Invalid data types</li> <li>Concurrent requests</li> <li>Network failures</li> </ul>"},{"location":"test/#quick-start-testing","title":"Quick Start Testing","text":""},{"location":"test/#python-example","title":"Python Example","text":"<pre><code>import pytest\nfrom my_server import mcp\n\n@pytest.fixture\ndef client():\n    return mcp.test_client()\n\ndef test_tool_execution(client):\n    response = client.call_tool('my_tool', {'input': 'test'})\n    assert response['status'] == 'success'\n    assert 'result' in response\n</code></pre>"},{"location":"test/#javascript-example","title":"JavaScript Example","text":"<pre><code>const { TestClient } = require('@mcp/testing');\nconst server = require('./server');\n\ndescribe('MCP Server', () =&gt; {\n  let client;\n  \n  beforeAll(() =&gt; {\n    client = new TestClient(server);\n  });\n  \n  test('tool execution', async () =&gt; {\n    const result = await client.callTool('my_tool', { input: 'test' });\n    expect(result.status).toBe('success');\n  });\n});\n</code></pre>"},{"location":"test/#go-example","title":"Go Example","text":"<pre><code>func TestToolExecution(t *testing.T) {\n    server := NewTestServer()\n    defer server.Close()\n    \n    result, err := server.CallTool(\"my_tool\", map[string]interface{}{\n        \"input\": \"test\",\n    })\n    \n    assert.NoError(t, err)\n    assert.Equal(t, \"expected\", result)\n}\n</code></pre>"},{"location":"test/#test-coverage-requirements","title":"Test Coverage Requirements","text":""},{"location":"test/#minimum-coverage","title":"Minimum Coverage","text":"<ul> <li>Overall: 80% code coverage</li> <li>Critical paths: 100% coverage</li> <li>Error handling: 90% coverage</li> <li>Edge cases: 85% coverage</li> </ul>"},{"location":"test/#coverage-tools","title":"Coverage Tools","text":"Language Tool Command Python pytest-cov <code>pytest --cov=my_server --cov-report=html</code> JavaScript Jest <code>jest --coverage</code> Go Built-in <code>go test -cover ./...</code>"},{"location":"test/#test-data-management","title":"Test Data Management","text":""},{"location":"test/#fixtures","title":"Fixtures","text":"<pre><code># Python fixtures\n@pytest.fixture\ndef sample_data():\n    return {\n        'valid_input': {'name': 'test', 'value': 123},\n        'invalid_input': {'name': '', 'value': 'not_a_number'},\n        'edge_case': {'name': 'x' * 1000, 'value': float('inf')}\n    }\n</code></pre>"},{"location":"test/#mocking-external-services","title":"Mocking External Services","text":"<pre><code>// JavaScript mocking\njest.mock('./external-api', () =&gt; ({\n  fetchData: jest.fn(() =&gt; Promise.resolve({ data: 'mocked' }))\n}));\n</code></pre>"},{"location":"test/#continuous-integration","title":"Continuous Integration","text":""},{"location":"test/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Test MCP Server\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Setup Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n    \n    - name: Install dependencies\n      run: |\n        pip install -e \".[test]\"\n    \n    - name: Run tests\n      run: |\n        pytest --cov=my_server --cov-report=xml\n    \n    - name: Upload coverage\n      uses: codecov/codecov-action@v3\n</code></pre>"},{"location":"test/#testing-checklist","title":"Testing Checklist","text":""},{"location":"test/#pre-release-testing","title":"Pre-Release Testing","text":"<ul> <li> All unit tests pass</li> <li> Integration tests complete</li> <li> Security scan performed</li> <li> Performance benchmarks met</li> <li> Documentation updated</li> <li> Manual smoke tests done</li> </ul>"},{"location":"test/#test-categories","title":"Test Categories","text":"<ol> <li>Functional Testing</li> <li>Tool functionality</li> <li>Resource access</li> <li> <p>Protocol compliance</p> </li> <li> <p>Non-Functional Testing</p> </li> <li>Performance</li> <li>Security</li> <li>Usability</li> <li> <p>Reliability</p> </li> <li> <p>Regression Testing</p> </li> <li>Previous bugs fixed</li> <li>Features still working</li> <li>Backward compatibility</li> </ol>"},{"location":"test/#common-testing-patterns","title":"Common Testing Patterns","text":""},{"location":"test/#table-driven-tests","title":"Table-Driven Tests","text":"<pre><code>// Go example\ntests := []struct {\n    name    string\n    input   string\n    want    string\n    wantErr bool\n}{\n    {\"valid\", \"test\", \"TEST\", false},\n    {\"empty\", \"\", \"\", true},\n    {\"special\", \"!@#\", \"!@#\", false},\n}\n\nfor _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n        got, err := process(tt.input)\n        if (err != nil) != tt.wantErr {\n            t.Errorf(\"process() error = %v, wantErr %v\", err, tt.wantErr)\n        }\n        if got != tt.want {\n            t.Errorf(\"process() = %v, want %v\", got, tt.want)\n        }\n    })\n}\n</code></pre>"},{"location":"test/#property-based-testing","title":"Property-Based Testing","text":"<pre><code># Python hypothesis example\nfrom hypothesis import given, strategies as st\n\n@given(st.text())\ndef test_tool_handles_any_string(s):\n    result = my_tool(s)\n    assert isinstance(result, str)\n    assert len(result) &lt;= 1000  # Max length constraint\n</code></pre>"},{"location":"test/#testing-tools","title":"Testing Tools","text":""},{"location":"test/#recommended-tools-by-language","title":"Recommended Tools by Language","text":""},{"location":"test/#python","title":"Python","text":"<ul> <li>pytest - Testing framework</li> <li>pytest-asyncio - Async test support</li> <li>pytest-cov - Coverage reporting</li> <li>hypothesis - Property-based testing</li> <li>responses - HTTP mocking</li> </ul>"},{"location":"test/#javascripttypescript","title":"JavaScript/TypeScript","text":"<ul> <li>Jest - Testing framework</li> <li>Supertest - HTTP testing</li> <li>Sinon - Mocking library</li> <li>Playwright - E2E testing</li> </ul>"},{"location":"test/#go","title":"Go","text":"<ul> <li>testify - Assertions and mocks</li> <li>gomock - Mocking framework</li> <li>httptest - HTTP testing</li> <li>race detector - Concurrency testing</li> </ul>"},{"location":"test/#next-steps","title":"Next Steps","text":"<ul> <li>\u2705 Unit Testing</li> <li>\ud83d\udd04 Integration Testing</li> <li>\ud83d\ude80 End-to-End Testing</li> <li>\ud83d\udcca Performance Testing</li> <li>\ud83d\udd12 Security Testing</li> </ul>"},{"location":"tutorials/advanced/","title":"Advanced MCP Tutorial","text":""},{"location":"tutorials/advanced/#advanced-mcp-tutorial","title":"Advanced MCP Tutorial","text":""},{"location":"tutorials/advanced/#building-production-ready-mcp-servers","title":"Building Production-Ready MCP Servers","text":"<p>This tutorial covers advanced concepts for building robust, scalable MCP servers suitable for production environments.</p>"},{"location":"tutorials/advanced/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed the Quickstart Tutorial</li> <li>Understanding of async programming</li> <li>Basic knowledge of databases and HTTP clients</li> <li>Familiarity with configuration management</li> </ul>"},{"location":"tutorials/advanced/#overview","title":"Overview","text":"<p>We'll enhance our basic MCP server with: 1. Database Integration: PostgreSQL tool for data queries 2. HTTP Client: Web API integration tool 3. File System: Secure file operations 4. Configuration Management: Environment-based settings 5. Error Handling: Comprehensive error management 6. Logging &amp; Monitoring: Observability features 7. Security: Authentication and authorization 8. Testing: Unit and integration tests</p>"},{"location":"tutorials/advanced/#project-structure","title":"Project Structure","text":"<pre><code>advanced-mcp-server/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 config/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 auth.py\n\u2502   \u2502   \u251c\u2500\u2500 errors.py\n\u2502   \u2502   \u2514\u2500\u2500 logging.py\n\u2502   \u251c\u2500\u2500 tools/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 database.py\n\u2502   \u2502   \u251c\u2500\u2500 http_client.py\n\u2502   \u2502   \u251c\u2500\u2500 filesystem.py\n\u2502   \u2502   \u2514\u2500\u2500 base.py\n\u2502   \u251c\u2500\u2500 resources/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 config_resource.py\n\u2502   \u251c\u2500\u2500 middleware/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 auth.py\n\u2502   \u2502   \u251c\u2500\u2500 logging.py\n\u2502   \u2502   \u2514\u2500\u2500 rate_limiting.py\n\u2502   \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 integration/\n\u2502   \u2514\u2500\u2500 conftest.py\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 development.yaml\n\u2502   \u251c\u2500\u2500 production.yaml\n\u2502   \u2514\u2500\u2500 test.yaml\n\u251c\u2500\u2500 docker/\n\u2502   \u251c\u2500\u2500 Dockerfile\n\u2502   \u2514\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 requirements-dev.txt\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"tutorials/advanced/#step-1-configuration-management","title":"Step 1: Configuration Management","text":""},{"location":"tutorials/advanced/#settings-configuration","title":"Settings Configuration","text":"<pre><code># src/config/settings.py\nfrom pydantic import BaseSettings, Field\nfrom typing import List, Optional\nimport os\n\nclass DatabaseConfig(BaseSettings):\n    url: str = Field(..., env=\"DATABASE_URL\")\n    pool_size: int = Field(5, env=\"DB_POOL_SIZE\")\n    pool_timeout: int = Field(30, env=\"DB_POOL_TIMEOUT\")\n    \n    class Config:\n        env_prefix = \"DB_\"\n\nclass SecurityConfig(BaseSettings):\n    secret_key: str = Field(..., env=\"SECRET_KEY\")\n    allowed_origins: List[str] = Field([\"*\"], env=\"ALLOWED_ORIGINS\")\n    rate_limit_per_minute: int = Field(60, env=\"RATE_LIMIT_PER_MINUTE\")\n    require_auth: bool = Field(False, env=\"REQUIRE_AUTH\")\n    \n    class Config:\n        env_prefix = \"SECURITY_\"\n\nclass LoggingConfig(BaseSettings):\n    level: str = Field(\"INFO\", env=\"LOG_LEVEL\")\n    format: str = Field(\"json\", env=\"LOG_FORMAT\")\n    file_path: Optional[str] = Field(None, env=\"LOG_FILE_PATH\")\n    \n    class Config:\n        env_prefix = \"LOG_\"\n\nclass ServerSettings(BaseSettings):\n    name: str = Field(\"advanced-mcp-server\", env=\"SERVER_NAME\")\n    version: str = Field(\"2.0.0\", env=\"SERVER_VERSION\")\n    environment: str = Field(\"development\", env=\"ENVIRONMENT\")\n    \n    # Sub-configurations\n    database: DatabaseConfig = DatabaseConfig()\n    security: SecurityConfig = SecurityConfig()\n    logging: LoggingConfig = LoggingConfig()\n    \n    # Tool-specific settings\n    filesystem_allowed_paths: List[str] = Field([\"/tmp\"], env=\"FILESYSTEM_ALLOWED_PATHS\")\n    http_timeout: int = Field(30, env=\"HTTP_TIMEOUT\")\n    http_max_retries: int = Field(3, env=\"HTTP_MAX_RETRIES\")\n    \n    @classmethod\n    def load_from_yaml(cls, config_file: str) -&gt; \"ServerSettings\":\n        import yaml\n        with open(config_file, 'r') as f:\n            config_data = yaml.safe_load(f)\n        return cls(**config_data)\n    \n    class Config:\n        env_file = \".env\"\n        case_sensitive = False\n\n# Global settings instance\nsettings = ServerSettings()\n</code></pre>"},{"location":"tutorials/advanced/#yaml-configuration-files","title":"YAML Configuration Files","text":"<pre><code># config/development.yaml\nserver:\n  name: \"advanced-mcp-server\"\n  version: \"2.0.0\"\n  environment: \"development\"\n\ndatabase:\n  url: \"postgresql://user:password@localhost:5432/mcp_dev\"\n  pool_size: 5\n  pool_timeout: 30\n\nsecurity:\n  secret_key: \"dev-secret-key-change-in-production\"\n  allowed_origins: [\"*\"]\n  rate_limit_per_minute: 100\n  require_auth: false\n\nlogging:\n  level: \"DEBUG\"\n  format: \"pretty\"\n  file_path: null\n\nfilesystem_allowed_paths:\n  - \"/tmp\"\n  - \"/var/data\"\n\nhttp_timeout: 30\nhttp_max_retries: 3\n</code></pre>"},{"location":"tutorials/advanced/#step-2-enhanced-error-handling","title":"Step 2: Enhanced Error Handling","text":"<pre><code># src/core/errors.py\nfrom typing import Optional, Dict, Any\nimport traceback\nfrom enum import Enum\n\nclass ErrorCode(Enum):\n    VALIDATION_ERROR = \"VALIDATION_ERROR\"\n    TOOL_EXECUTION_ERROR = \"TOOL_EXECUTION_ERROR\"\n    RESOURCE_NOT_FOUND = \"RESOURCE_NOT_FOUND\"\n    PERMISSION_DENIED = \"PERMISSION_DENIED\"\n    RATE_LIMIT_EXCEEDED = \"RATE_LIMIT_EXCEEDED\"\n    AUTHENTICATION_FAILED = \"AUTHENTICATION_FAILED\"\n    CONFIGURATION_ERROR = \"CONFIGURATION_ERROR\"\n    INTERNAL_ERROR = \"INTERNAL_ERROR\"\n\nclass MCPError(Exception):\n    \"\"\"Base MCP error with structured information.\"\"\"\n    \n    def __init__(\n        self,\n        message: str,\n        code: ErrorCode = ErrorCode.INTERNAL_ERROR,\n        details: Optional[Dict[str, Any]] = None,\n        cause: Optional[Exception] = None\n    ):\n        super().__init__(message)\n        self.message = message\n        self.code = code\n        self.details = details or {}\n        self.cause = cause\n        \n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert error to dictionary for JSON serialization.\"\"\"\n        result = {\n            \"error\": {\n                \"code\": self.code.value,\n                \"message\": self.message,\n                \"details\": self.details\n            }\n        }\n        \n        if self.cause:\n            result[\"error\"][\"cause\"] = str(self.cause)\n            result[\"error\"][\"traceback\"] = traceback.format_exception(\n                type(self.cause), self.cause, self.cause.__traceback__\n            )\n        \n        return result\n\nclass ValidationError(MCPError):\n    def __init__(self, message: str, field: Optional[str] = None, **kwargs):\n        details = kwargs.get('details', {})\n        if field:\n            details['field'] = field\n        super().__init__(message, ErrorCode.VALIDATION_ERROR, details, **kwargs)\n\nclass ToolExecutionError(MCPError):\n    def __init__(self, tool_name: str, message: str, **kwargs):\n        details = kwargs.get('details', {})\n        details['tool_name'] = tool_name\n        super().__init__(\n            f\"Tool '{tool_name}' execution failed: {message}\",\n            ErrorCode.TOOL_EXECUTION_ERROR,\n            details,\n            **kwargs\n        )\n\nclass ResourceNotFoundError(MCPError):\n    def __init__(self, resource_uri: str, **kwargs):\n        details = kwargs.get('details', {})\n        details['resource_uri'] = resource_uri\n        super().__init__(\n            f\"Resource '{resource_uri}' not found\",\n            ErrorCode.RESOURCE_NOT_FOUND,\n            details,\n            **kwargs\n        )\n\nclass PermissionDeniedError(MCPError):\n    def __init__(self, operation: str, reason: Optional[str] = None, **kwargs):\n        details = kwargs.get('details', {})\n        details['operation'] = operation\n        if reason:\n            details['reason'] = reason\n        \n        message = f\"Permission denied for operation: {operation}\"\n        if reason:\n            message += f\" ({reason})\"\n            \n        super().__init__(\n            message,\n            ErrorCode.PERMISSION_DENIED,\n            details,\n            **kwargs\n        )\n\n# Error handling decorator\ndef handle_tool_errors(func):\n    \"\"\"Decorator to handle tool execution errors consistently.\"\"\"\n    import functools\n    \n    @functools.wraps(func)\n    async def wrapper(self, *args, **kwargs):\n        try:\n            return await func(self, *args, **kwargs)\n        except MCPError:\n            raise  # Re-raise MCP errors as-is\n        except Exception as e:\n            raise ToolExecutionError(\n                tool_name=getattr(self, 'name', 'unknown'),\n                message=str(e),\n                cause=e\n            )\n    \n    return wrapper\n</code></pre>"},{"location":"tutorials/advanced/#step-3-structured-logging","title":"Step 3: Structured Logging","text":"<pre><code># src/core/logging.py\nimport logging\nimport logging.config\nimport json\nimport sys\nfrom datetime import datetime\nfrom typing import Any, Dict\nfrom src.config.settings import settings\n\nclass JSONFormatter(logging.Formatter):\n    \"\"\"Custom JSON formatter for structured logging.\"\"\"\n    \n    def format(self, record: logging.LogRecord) -&gt; str:\n        log_entry = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"message\": record.getMessage(),\n            \"module\": record.module,\n            \"function\": record.funcName,\n            \"line\": record.lineno,\n        }\n        \n        # Add extra fields\n        if hasattr(record, 'tool_name'):\n            log_entry['tool_name'] = record.tool_name\n        if hasattr(record, 'user_id'):\n            log_entry['user_id'] = record.user_id\n        if hasattr(record, 'request_id'):\n            log_entry['request_id'] = record.request_id\n        \n        # Add exception info if present\n        if record.exc_info:\n            log_entry['exception'] = self.formatException(record.exc_info)\n        \n        return json.dumps(log_entry)\n\nclass PrettyFormatter(logging.Formatter):\n    \"\"\"Human-readable formatter for development.\"\"\"\n    \n    def format(self, record: logging.LogRecord) -&gt; str:\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        level_color = {\n            'DEBUG': '\\033[36m',    # Cyan\n            'INFO': '\\033[32m',     # Green\n            'WARNING': '\\033[33m',  # Yellow\n            'ERROR': '\\033[31m',    # Red\n            'CRITICAL': '\\033[35m', # Magenta\n        }.get(record.levelname, '')\n        \n        reset_color = '\\033[0m'\n        \n        return (\n            f\"{timestamp} | {level_color}{record.levelname:8}{reset_color} | \"\n            f\"{record.name:20} | {record.getMessage()}\"\n        )\n\ndef setup_logging():\n    \"\"\"Configure logging based on settings.\"\"\"\n    \n    # Choose formatter\n    if settings.logging.format == \"json\":\n        formatter_class = JSONFormatter\n    else:\n        formatter_class = PrettyFormatter\n    \n    # Configure handlers\n    handlers = {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'formatter': 'default',\n            'stream': sys.stdout,\n        }\n    }\n    \n    if settings.logging.file_path:\n        handlers['file'] = {\n            'class': 'logging.FileHandler',\n            'formatter': 'default',\n            'filename': settings.logging.file_path,\n        }\n    \n    # Logging configuration\n    config = {\n        'version': 1,\n        'disable_existing_loggers': False,\n        'formatters': {\n            'default': {\n                '()': formatter_class,\n            }\n        },\n        'handlers': handlers,\n        'loggers': {\n            'mcp_server': {\n                'handlers': list(handlers.keys()),\n                'level': settings.logging.level,\n                'propagate': False,\n            },\n            'uvicorn': {\n                'handlers': ['console'],\n                'level': 'INFO',\n                'propagate': False,\n            },\n        },\n        'root': {\n            'handlers': list(handlers.keys()),\n            'level': settings.logging.level,\n        }\n    }\n    \n    logging.config.dictConfig(config)\n\n# Context manager for request logging\nimport contextvars\n\nrequest_id_var: contextvars.ContextVar[str] = contextvars.ContextVar('request_id')\nuser_id_var: contextvars.ContextVar[str] = contextvars.ContextVar('user_id')\n\nclass LoggingContext:\n    \"\"\"Context manager for adding request context to logs.\"\"\"\n    \n    def __init__(self, request_id: str = None, user_id: str = None):\n        self.request_id = request_id\n        self.user_id = user_id\n        self.tokens = []\n    \n    def __enter__(self):\n        if self.request_id:\n            self.tokens.append(request_id_var.set(self.request_id))\n        if self.user_id:\n            self.tokens.append(user_id_var.set(self.user_id))\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        for token in self.tokens:\n            token.reset()\n\nclass ContextualLoggerAdapter(logging.LoggerAdapter):\n    \"\"\"Logger adapter that automatically includes context variables.\"\"\"\n    \n    def process(self, msg, kwargs):\n        extra = kwargs.get('extra', {})\n        \n        try:\n            extra['request_id'] = request_id_var.get()\n        except LookupError:\n            pass\n        \n        try:\n            extra['user_id'] = user_id_var.get()\n        except LookupError:\n            pass\n        \n        kwargs['extra'] = extra\n        return msg, kwargs\n\ndef get_logger(name: str) -&gt; ContextualLoggerAdapter:\n    \"\"\"Get a contextual logger instance.\"\"\"\n    base_logger = logging.getLogger(name)\n    return ContextualLoggerAdapter(base_logger, {})\n</code></pre>"},{"location":"tutorials/advanced/#step-4-advanced-database-tool","title":"Step 4: Advanced Database Tool","text":"<pre><code># src/tools/database.py\nimport asyncpg\nimport json\nfrom typing import Dict, List, Any, Optional\nfrom src.tools.base import BaseTool\nfrom src.core.errors import ValidationError, ToolExecutionError, handle_tool_errors\nfrom src.core.logging import get_logger\nfrom src.config.settings import settings\n\nlogger = get_logger(__name__)\n\nclass DatabaseTool(BaseTool):\n    \"\"\"Advanced database query tool with connection pooling and security.\"\"\"\n    \n    def __init__(self):\n        super().__init__(\n            name=\"database_query\",\n            description=\"Execute SQL queries against PostgreSQL database with safety checks\"\n        )\n        self.pool: Optional[asyncpg.Pool] = None\n        self.allowed_tables: List[str] = []  # Configure based on your needs\n        \n    async def initialize(self):\n        \"\"\"Initialize database connection pool.\"\"\"\n        try:\n            self.pool = await asyncpg.create_pool(\n                dsn=settings.database.url,\n                min_size=1,\n                max_size=settings.database.pool_size,\n                command_timeout=settings.database.pool_timeout\n            )\n            logger.info(\"Database connection pool initialized\")\n            \n            # Load allowed tables (example)\n            async with self.pool.acquire() as conn:\n                rows = await conn.fetch(\"\"\"\n                    SELECT table_name \n                    FROM information_schema.tables \n                    WHERE table_schema = 'public'\n                \"\"\")\n                self.allowed_tables = [row['table_name'] for row in rows]\n                logger.info(f\"Loaded {len(self.allowed_tables)} allowed tables\")\n                \n        except Exception as e:\n            logger.error(f\"Failed to initialize database pool: {e}\")\n            raise ToolExecutionError(self.name, f\"Database initialization failed: {e}\", cause=e)\n    \n    def get_schema(self) -&gt; Dict[str, Any]:\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": \"SQL query to execute (SELECT only)\"\n                },\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"description\": \"Parameters for parameterized queries\",\n                    \"additionalProperties\": True\n                },\n                \"limit\": {\n                    \"type\": \"integer\",\n                    \"minimum\": 1,\n                    \"maximum\": 1000,\n                    \"default\": 100,\n                    \"description\": \"Maximum number of rows to return\"\n                },\n                \"timeout\": {\n                    \"type\": \"integer\",\n                    \"minimum\": 1,\n                    \"maximum\": 300,\n                    \"default\": 30,\n                    \"description\": \"Query timeout in seconds\"\n                }\n            },\n            \"required\": [\"query\"]\n        }\n    \n    def _validate_query(self, query: str) -&gt; None:\n        \"\"\"Validate SQL query for security.\"\"\"\n        query_upper = query.strip().upper()\n        \n        # Only allow SELECT statements\n        if not query_upper.startswith('SELECT'):\n            raise ValidationError(\n                \"Only SELECT queries are allowed\",\n                field=\"query\",\n                details={\"query_type\": \"non_select\"}\n            )\n        \n        # Block dangerous keywords\n        dangerous_keywords = [\n            'DROP', 'DELETE', 'INSERT', 'UPDATE', 'ALTER',\n            'CREATE', 'TRUNCATE', 'REPLACE', 'EXEC',\n            'EXECUTE', 'MERGE', 'CALL'\n        ]\n        \n        for keyword in dangerous_keywords:\n            if keyword in query_upper:\n                raise ValidationError(\n                    f\"Query contains forbidden keyword: {keyword}\",\n                    field=\"query\",\n                    details={\"forbidden_keyword\": keyword}\n                )\n        \n        # Check for suspicious patterns\n        suspicious_patterns = [\n            'UNION', 'INFORMATION_SCHEMA', 'PG_', 'SYS'\n        ]\n        \n        for pattern in suspicious_patterns:\n            if pattern in query_upper:\n                logger.warning(f\"Query contains suspicious pattern: {pattern}\", extra={\n                    'query': query[:100] + \"...\" if len(query) &gt; 100 else query\n                })\n    \n    @handle_tool_errors\n    async def execute(self, arguments: Dict[str, Any]) -&gt; List[Any]:\n        if not self.pool:\n            await self.initialize()\n        \n        # Extract and validate arguments\n        query = arguments.get(\"query\", \"\").strip()\n        parameters = arguments.get(\"parameters\", {})\n        limit = arguments.get(\"limit\", 100)\n        timeout = arguments.get(\"timeout\", 30)\n        \n        if not query:\n            raise ValidationError(\"Query cannot be empty\", field=\"query\")\n        \n        self._validate_query(query)\n        \n        # Add LIMIT if not present\n        if \"LIMIT\" not in query.upper():\n            query = f\"{query} LIMIT ${len(parameters) + 1}\"\n            parameters[f\"${len(parameters) + 1}\"] = limit\n        \n        logger.info(f\"Executing database query\", extra={\n            'query': query[:100] + \"...\" if len(query) &gt; 100 else query,\n            'parameter_count': len(parameters)\n        })\n        \n        try:\n            async with self.pool.acquire() as conn:\n                # Set statement timeout\n                await conn.execute(f'SET statement_timeout = {timeout * 1000}')\n                \n                # Execute query\n                if parameters:\n                    rows = await conn.fetch(query, *parameters.values())\n                else:\n                    rows = await conn.fetch(query)\n                \n                # Convert to JSON-serializable format\n                results = []\n                for row in rows:\n                    row_dict = {}\n                    for key, value in row.items():\n                        # Handle special types\n                        if hasattr(value, 'isoformat'):  # datetime\n                            value = value.isoformat()\n                        elif isinstance(value, bytes):\n                            value = value.hex()\n                        row_dict[key] = value\n                    results.append(row_dict)\n                \n                logger.info(f\"Query executed successfully, returned {len(results)} rows\")\n                \n                return [{\n                    \"type\": \"text\",\n                    \"text\": json.dumps({\n                        \"query\": query,\n                        \"row_count\": len(results),\n                        \"results\": results\n                    }, indent=2, default=str)\n                }]\n                \n        except asyncpg.exceptions.PostgresError as e:\n            logger.error(f\"Database query failed: {e}\")\n            raise ToolExecutionError(\n                self.name,\n                f\"Query execution failed: {e}\",\n                details={\n                    \"error_code\": e.sqlstate,\n                    \"error_message\": str(e)\n                },\n                cause=e\n            )\n        except Exception as e:\n            logger.error(f\"Unexpected error during query execution: {e}\")\n            raise ToolExecutionError(self.name, f\"Unexpected error: {e}\", cause=e)\n    \n    async def cleanup(self):\n        \"\"\"Clean up database connections.\"\"\"\n        if self.pool:\n            await self.pool.close()\n            logger.info(\"Database connection pool closed\")\n</code></pre>"},{"location":"tutorials/advanced/#step-5-http-client-tool-with-resilience","title":"Step 5: HTTP Client Tool with Resilience","text":"<pre><code># src/tools/http_client.py\nimport aiohttp\nimport asyncio\nimport json\nfrom typing import Dict, List, Any, Optional\nfrom urllib.parse import urlparse\nimport time\nfrom src.tools.base import BaseTool\nfrom src.core.errors import ValidationError, ToolExecutionError, handle_tool_errors\nfrom src.core.logging import get_logger\nfrom src.config.settings import settings\n\nlogger = get_logger(__name__)\n\nclass HTTPClientTool(BaseTool):\n    \"\"\"Advanced HTTP client with retry logic, circuit breaker, and caching.\"\"\"\n    \n    def __init__(self):\n        super().__init__(\n            name=\"http_request\",\n            description=\"Make HTTP requests with automatic retries and error handling\"\n        )\n        self.session: Optional[aiohttp.ClientSession] = None\n        self.circuit_breaker_state: Dict[str, Dict] = {}\n        self.cache: Dict[str, Dict] = {}\n        \n    async def initialize(self):\n        \"\"\"Initialize HTTP client session.\"\"\"\n        timeout = aiohttp.ClientTimeout(total=settings.http_timeout)\n        self.session = aiohttp.ClientSession(\n            timeout=timeout,\n            headers={\"User-Agent\": f\"{settings.name}/{settings.version}\"}\n        )\n        logger.info(\"HTTP client session initialized\")\n    \n    def get_schema(self) -&gt; Dict[str, Any]:\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"method\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\"],\n                    \"default\": \"GET\",\n                    \"description\": \"HTTP method\"\n                },\n                \"url\": {\n                    \"type\": \"string\",\n                    \"format\": \"uri\",\n                    \"description\": \"URL to request\"\n                },\n                \"headers\": {\n                    \"type\": \"object\",\n                    \"description\": \"HTTP headers\",\n                    \"additionalProperties\": {\"type\": \"string\"}\n                },\n                \"data\": {\n                    \"type\": \"object\",\n                    \"description\": \"Request body data (JSON)\"\n                },\n                \"params\": {\n                    \"type\": \"object\",\n                    \"description\": \"URL query parameters\",\n                    \"additionalProperties\": {\"type\": \"string\"}\n                },\n                \"timeout\": {\n                    \"type\": \"integer\",\n                    \"minimum\": 1,\n                    \"maximum\": 300,\n                    \"default\": settings.http_timeout,\n                    \"description\": \"Request timeout in seconds\"\n                },\n                \"retries\": {\n                    \"type\": \"integer\",\n                    \"minimum\": 0,\n                    \"maximum\": 10,\n                    \"default\": settings.http_max_retries,\n                    \"description\": \"Number of retry attempts\"\n                },\n                \"cache_ttl\": {\n                    \"type\": \"integer\",\n                    \"minimum\": 0,\n                    \"default\": 0,\n                    \"description\": \"Cache TTL in seconds (0 = no cache)\"\n                }\n            },\n            \"required\": [\"url\"]\n        }\n    \n    def _validate_url(self, url: str) -&gt; None:\n        \"\"\"Validate URL for security.\"\"\"\n        try:\n            parsed = urlparse(url)\n        except Exception:\n            raise ValidationError(\"Invalid URL format\", field=\"url\")\n        \n        if parsed.scheme not in ['http', 'https']:\n            raise ValidationError(\"Only HTTP and HTTPS URLs are allowed\", field=\"url\")\n        \n        # Block private/local addresses (optional security measure)\n        hostname = parsed.hostname\n        if hostname:\n            import ipaddress\n            try:\n                ip = ipaddress.ip_address(hostname)\n                if ip.is_private or ip.is_loopback or ip.is_link_local:\n                    logger.warning(f\"Request to private IP address blocked: {hostname}\")\n                    raise ValidationError(\"Requests to private IP addresses are not allowed\", field=\"url\")\n            except ipaddress.AddressValueError:\n                pass  # Hostname is not an IP address\n    \n    def _get_circuit_breaker_state(self, host: str) -&gt; Dict:\n        \"\"\"Get circuit breaker state for a host.\"\"\"\n        if host not in self.circuit_breaker_state:\n            self.circuit_breaker_state[host] = {\n                \"failures\": 0,\n                \"last_failure\": 0,\n                \"state\": \"closed\"  # closed, open, half_open\n            }\n        return self.circuit_breaker_state[host]\n    \n    def _should_allow_request(self, host: str) -&gt; bool:\n        \"\"\"Check if request should be allowed based on circuit breaker.\"\"\"\n        state = self._get_circuit_breaker_state(host)\n        current_time = time.time()\n        \n        if state[\"state\"] == \"open\":\n            # Check if we should try again (half-open)\n            if current_time - state[\"last_failure\"] &gt; 60:  # 1 minute timeout\n                state[\"state\"] = \"half_open\"\n                return True\n            return False\n        \n        return True\n    \n    def _record_success(self, host: str):\n        \"\"\"Record successful request.\"\"\"\n        state = self._get_circuit_breaker_state(host)\n        state[\"failures\"] = 0\n        state[\"state\"] = \"closed\"\n    \n    def _record_failure(self, host: str):\n        \"\"\"Record failed request.\"\"\"\n        state = self._get_circuit_breaker_state(host)\n        state[\"failures\"] += 1\n        state[\"last_failure\"] = time.time()\n        \n        if state[\"failures\"] &gt;= 5:  # Threshold\n            state[\"state\"] = \"open\"\n            logger.warning(f\"Circuit breaker opened for host: {host}\")\n    \n    def _get_cache_key(self, method: str, url: str, headers: Dict, params: Dict) -&gt; str:\n        \"\"\"Generate cache key for request.\"\"\"\n        import hashlib\n        key_data = f\"{method}:{url}:{json.dumps(headers, sort_keys=True)}:{json.dumps(params, sort_keys=True)}\"\n        return hashlib.md5(key_data.encode()).hexdigest()\n    \n    def _get_cached_response(self, cache_key: str, cache_ttl: int) -&gt; Optional[Dict]:\n        \"\"\"Get cached response if valid.\"\"\"\n        if cache_key in self.cache:\n            cached = self.cache[cache_key]\n            if time.time() - cached[\"timestamp\"] &lt; cache_ttl:\n                logger.info(\"Returning cached response\")\n                return cached[\"response\"]\n            else:\n                del self.cache[cache_key]\n        return None\n    \n    def _cache_response(self, cache_key: str, response: Dict):\n        \"\"\"Cache response.\"\"\"\n        self.cache[cache_key] = {\n            \"response\": response,\n            \"timestamp\": time.time()\n        }\n    \n    @handle_tool_errors\n    async def execute(self, arguments: Dict[str, Any]) -&gt; List[Any]:\n        if not self.session:\n            await self.initialize()\n        \n        # Extract arguments\n        method = arguments.get(\"method\", \"GET\").upper()\n        url = arguments[\"url\"]\n        headers = arguments.get(\"headers\", {})\n        data = arguments.get(\"data\")\n        params = arguments.get(\"params\", {})\n        timeout = arguments.get(\"timeout\", settings.http_timeout)\n        retries = arguments.get(\"retries\", settings.http_max_retries)\n        cache_ttl = arguments.get(\"cache_ttl\", 0)\n        \n        self._validate_url(url)\n        \n        # Check circuit breaker\n        parsed_url = urlparse(url)\n        host = parsed_url.hostname\n        if not self._should_allow_request(host):\n            raise ToolExecutionError(\n                self.name,\n                f\"Circuit breaker is open for host: {host}\",\n                details={\"host\": host, \"circuit_breaker_state\": \"open\"}\n            )\n        \n        # Check cache for GET requests\n        if method == \"GET\" and cache_ttl &gt; 0:\n            cache_key = self._get_cache_key(method, url, headers, params)\n            cached_response = self._get_cached_response(cache_key, cache_ttl)\n            if cached_response:\n                return [{\"type\": \"text\", \"text\": json.dumps(cached_response, indent=2)}]\n        \n        logger.info(f\"Making {method} request to {url}\")\n        \n        # Make request with retries\n        last_exception = None\n        for attempt in range(retries + 1):\n            try:\n                async with self.session.request(\n                    method=method,\n                    url=url,\n                    headers=headers,\n                    json=data if data else None,\n                    params=params,\n                    timeout=aiohttp.ClientTimeout(total=timeout)\n                ) as response:\n                    # Read response\n                    try:\n                        response_text = await response.text()\n                        try:\n                            response_data = json.loads(response_text)\n                        except json.JSONDecodeError:\n                            response_data = response_text\n                    except Exception:\n                        response_data = None\n                    \n                    # Build result\n                    result = {\n                        \"status_code\": response.status,\n                        \"headers\": dict(response.headers),\n                        \"data\": response_data,\n                        \"url\": str(response.url),\n                        \"method\": method,\n                        \"success\": 200 &lt;= response.status &lt; 400\n                    }\n                    \n                    # Record success/failure for circuit breaker\n                    if result[\"success\"]:\n                        self._record_success(host)\n                    else:\n                        self._record_failure(host)\n                    \n                    # Cache successful GET responses\n                    if method == \"GET\" and cache_ttl &gt; 0 and result[\"success\"]:\n                        self._cache_response(cache_key, result)\n                    \n                    logger.info(f\"Request completed with status {response.status}\")\n                    \n                    return [{\n                        \"type\": \"text\",\n                        \"text\": json.dumps(result, indent=2, default=str)\n                    }]\n                    \n            except asyncio.TimeoutError:\n                last_exception = ToolExecutionError(\n                    self.name,\n                    f\"Request timed out after {timeout} seconds\"\n                )\n                self._record_failure(host)\n            except aiohttp.ClientError as e:\n                last_exception = ToolExecutionError(\n                    self.name,\n                    f\"HTTP client error: {str(e)}\",\n                    cause=e\n                )\n                self._record_failure(host)\n            except Exception as e:\n                last_exception = ToolExecutionError(\n                    self.name,\n                    f\"Unexpected error: {str(e)}\",\n                    cause=e\n                )\n                self._record_failure(host)\n            \n            if attempt &lt; retries:\n                wait_time = 2 ** attempt  # Exponential backoff\n                logger.warning(f\"Request failed, retrying in {wait_time}s (attempt {attempt + 1}/{retries + 1})\")\n                await asyncio.sleep(wait_time)\n        \n        # All retries exhausted\n        raise last_exception\n    \n    async def cleanup(self):\n        \"\"\"Clean up HTTP client session.\"\"\"\n        if self.session:\n            await self.session.close()\n            logger.info(\"HTTP client session closed\")\n</code></pre> <p>This advanced tutorial demonstrates how to build production-ready MCP servers with proper error handling, logging, configuration management, and resilience patterns. The remaining sections would continue with middleware implementation, security features, comprehensive testing, and deployment strategies.</p>"},{"location":"tutorials/quickstart/","title":"MCP Quickstart Tutorial","text":""},{"location":"tutorials/quickstart/#mcp-quickstart-tutorial","title":"MCP Quickstart Tutorial","text":""},{"location":"tutorials/quickstart/#build-your-first-mcp-server-in-10-minutes","title":"Build Your First MCP Server in 10 Minutes","text":"<p>This tutorial will guide you through creating a basic MCP server from scratch, helping you understand the core concepts and get up and running quickly.</p>"},{"location":"tutorials/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Choose your language: Python 3.8+, Node.js 16+, Go 1.21+, or Rust 1.75+</li> <li>Basic understanding of your chosen programming language</li> <li>Text editor or IDE</li> <li>Terminal/command line access</li> </ul>"},{"location":"tutorials/quickstart/#overview","title":"Overview","text":"<p>We'll build a simple MCP server that provides two tools: 1. Echo Tool: Returns the input text with a prefix 2. Math Tool: Performs basic arithmetic operations</p>"},{"location":"tutorials/quickstart/#step-1-project-setup","title":"Step 1: Project Setup","text":""},{"location":"tutorials/quickstart/#python-setup","title":"Python Setup","text":"<pre><code># Create project directory\nmkdir my-mcp-server &amp;&amp; cd my-mcp-server\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Create project structure\nmkdir -p src/tools\ntouch src/__init__.py\ntouch src/main.py\ntouch src/tools/__init__.py\ntouch src/tools/echo.py\ntouch src/tools/math.py\n\n# Install MCP SDK\npip install mcp-sdk\n</code></pre>"},{"location":"tutorials/quickstart/#nodejs-setup","title":"Node.js Setup","text":"<pre><code># Create project directory\nmkdir my-mcp-server &amp;&amp; cd my-mcp-server\n\n# Initialize npm project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk\n\n# Create project structure\nmkdir -p src/tools\ntouch src/index.js\ntouch src/tools/echo.js\ntouch src/tools/math.js\n</code></pre>"},{"location":"tutorials/quickstart/#go-setup","title":"Go Setup","text":"<pre><code># Create project directory\nmkdir my-mcp-server &amp;&amp; cd my-mcp-server\n\n# Initialize Go module\ngo mod init my-mcp-server\n\n# Create project structure\nmkdir -p cmd/server internal/tools\ntouch cmd/server/main.go\ntouch internal/tools/echo.go\ntouch internal/tools/math.go\n\n# Add MCP SDK dependency\ngo get github.com/modelcontextprotocol/go-sdk\n</code></pre>"},{"location":"tutorials/quickstart/#rust-setup","title":"Rust Setup","text":"<pre><code># Create project directory\ncargo new my-mcp-server --bin\ncd my-mcp-server\n\n# Create project structure\nmkdir -p src/tools\ntouch src/tools/mod.rs\ntouch src/tools/echo.rs\ntouch src/tools/math.rs\n\n# Add dependencies to Cargo.toml\ncat &gt;&gt; Cargo.toml &lt;&lt; EOF\n\n[dependencies]\nmcp-sdk = \"0.1\"\ntokio = { version = \"1.0\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nanyhow = \"1.0\"\nEOF\n</code></pre>"},{"location":"tutorials/quickstart/#step-2-implement-the-echo-tool","title":"Step 2: Implement the Echo Tool","text":""},{"location":"tutorials/quickstart/#python-implementation","title":"Python Implementation","text":"<pre><code># src/tools/echo.py\nfrom typing import Dict, List, Any\nfrom mcp_sdk import Tool, Content, TextContent\n\nclass EchoTool(Tool):\n    def __init__(self):\n        super().__init__(\n            name=\"echo\",\n            description=\"Echo the input text with a prefix\"\n        )\n    \n    def get_schema(self) -&gt; Dict[str, Any]:\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"text\": {\n                    \"type\": \"string\",\n                    \"description\": \"Text to echo\"\n                },\n                \"prefix\": {\n                    \"type\": \"string\",\n                    \"description\": \"Prefix to add to the text\",\n                    \"default\": \"Echo: \"\n                }\n            },\n            \"required\": [\"text\"]\n        }\n    \n    async def execute(self, arguments: Dict[str, Any]) -&gt; List[Content]:\n        text = arguments.get(\"text\", \"\")\n        prefix = arguments.get(\"prefix\", \"Echo: \")\n        \n        result = f\"{prefix}{text}\"\n        \n        return [TextContent(text=result)]\n</code></pre>"},{"location":"tutorials/quickstart/#nodejs-implementation","title":"Node.js Implementation","text":"<pre><code>// src/tools/echo.js\nclass EchoTool {\n    constructor() {\n        this.name = \"echo\";\n        this.description = \"Echo the input text with a prefix\";\n    }\n\n    getSchema() {\n        return {\n            type: \"object\",\n            properties: {\n                text: {\n                    type: \"string\",\n                    description: \"Text to echo\"\n                },\n                prefix: {\n                    type: \"string\",\n                    description: \"Prefix to add to the text\",\n                    default: \"Echo: \"\n                }\n            },\n            required: [\"text\"]\n        };\n    }\n\n    async execute(arguments) {\n        const text = arguments.text || \"\";\n        const prefix = arguments.prefix || \"Echo: \";\n        \n        const result = `${prefix}${text}`;\n        \n        return [{ type: \"text\", text: result }];\n    }\n}\n\nmodule.exports = EchoTool;\n</code></pre>"},{"location":"tutorials/quickstart/#go-implementation","title":"Go Implementation","text":"<pre><code>// internal/tools/echo.go\npackage tools\n\nimport (\n    \"context\"\n    \"fmt\"\n    \n    \"github.com/modelcontextprotocol/go-sdk/server\"\n)\n\ntype EchoTool struct{}\n\nfunc NewEchoTool() *EchoTool {\n    return &amp;EchoTool{}\n}\n\nfunc (t *EchoTool) Name() string {\n    return \"echo\"\n}\n\nfunc (t *EchoTool) Description() string {\n    return \"Echo the input text with a prefix\"\n}\n\nfunc (t *EchoTool) InputSchema() map[string]interface{} {\n    return map[string]interface{}{\n        \"type\": \"object\",\n        \"properties\": map[string]interface{}{\n            \"text\": map[string]interface{}{\n                \"type\":        \"string\",\n                \"description\": \"Text to echo\",\n            },\n            \"prefix\": map[string]interface{}{\n                \"type\":        \"string\",\n                \"description\": \"Prefix to add to the text\",\n                \"default\":     \"Echo: \",\n            },\n        },\n        \"required\": []string{\"text\"},\n    }\n}\n\nfunc (t *EchoTool) Execute(ctx context.Context, arguments map[string]interface{}) ([]server.Content, error) {\n    text, ok := arguments[\"text\"].(string)\n    if !ok {\n        return nil, fmt.Errorf(\"text argument is required and must be a string\")\n    }\n    \n    prefix := \"Echo: \"\n    if p, ok := arguments[\"prefix\"].(string); ok {\n        prefix = p\n    }\n    \n    result := fmt.Sprintf(\"%s%s\", prefix, text)\n    \n    return []server.Content{\n        {\n            Type: \"text\",\n            Text: result,\n        },\n    }, nil\n}\n</code></pre>"},{"location":"tutorials/quickstart/#rust-implementation","title":"Rust Implementation","text":"<pre><code>// src/tools/echo.rs\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\nuse crate::tools::Tool;\n\npub struct EchoTool;\n\n#[async_trait]\nimpl Tool for EchoTool {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"echo\"\n    }\n    \n    fn description(&amp;self) -&gt; &amp;str {\n        \"Echo the input text with a prefix\"\n    }\n    \n    fn schema(&amp;self) -&gt; Value {\n        json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"text\": {\n                    \"type\": \"string\",\n                    \"description\": \"Text to echo\"\n                },\n                \"prefix\": {\n                    \"type\": \"string\",\n                    \"description\": \"Prefix to add to the text\",\n                    \"default\": \"Echo: \"\n                }\n            },\n            \"required\": [\"text\"]\n        })\n    }\n    \n    async fn execute(&amp;self, arguments: HashMap&lt;String, Value&gt;) -&gt; Result&lt;Vec&lt;Content&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        let text = arguments.get(\"text\")\n            .and_then(|v| v.as_str())\n            .ok_or(\"text argument is required and must be a string\")?;\n        \n        let prefix = arguments.get(\"prefix\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"Echo: \");\n        \n        let result = format!(\"{}{}\", prefix, text);\n        \n        Ok(vec![Content {\n            content_type: \"text\".to_string(),\n            text: Some(result),\n            data: None,\n        }])\n    }\n}\n</code></pre>"},{"location":"tutorials/quickstart/#step-3-implement-the-math-tool","title":"Step 3: Implement the Math Tool","text":""},{"location":"tutorials/quickstart/#python-implementation_1","title":"Python Implementation","text":"<pre><code># src/tools/math.py\nfrom typing import Dict, List, Any\nimport operator\nfrom mcp_sdk import Tool, Content, TextContent\n\nclass MathTool(Tool):\n    def __init__(self):\n        super().__init__(\n            name=\"math\",\n            description=\"Perform basic arithmetic operations\"\n        )\n        \n        self.operations = {\n            \"add\": operator.add,\n            \"subtract\": operator.sub,\n            \"multiply\": operator.mul,\n            \"divide\": operator.truediv,\n        }\n    \n    def get_schema(self) -&gt; Dict[str, Any]:\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"operation\": {\n                    \"type\": \"string\",\n                    \"enum\": list(self.operations.keys()),\n                    \"description\": \"Mathematical operation to perform\"\n                },\n                \"a\": {\n                    \"type\": \"number\",\n                    \"description\": \"First number\"\n                },\n                \"b\": {\n                    \"type\": \"number\",\n                    \"description\": \"Second number\"\n                }\n            },\n            \"required\": [\"operation\", \"a\", \"b\"]\n        }\n    \n    async def execute(self, arguments: Dict[str, Any]) -&gt; List[Content]:\n        operation = arguments.get(\"operation\")\n        a = arguments.get(\"a\")\n        b = arguments.get(\"b\")\n        \n        if operation not in self.operations:\n            raise ValueError(f\"Unsupported operation: {operation}\")\n        \n        if operation == \"divide\" and b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        \n        try:\n            result = self.operations[operation](a, b)\n            return [TextContent(text=f\"{a} {operation} {b} = {result}\")]\n        except Exception as e:\n            raise ValueError(f\"Calculation error: {str(e)}\")\n</code></pre>"},{"location":"tutorials/quickstart/#nodejs-implementation_1","title":"Node.js Implementation","text":"<pre><code>// src/tools/math.js\nclass MathTool {\n    constructor() {\n        this.name = \"math\";\n        this.description = \"Perform basic arithmetic operations\";\n        \n        this.operations = {\n            add: (a, b) =&gt; a + b,\n            subtract: (a, b) =&gt; a - b,\n            multiply: (a, b) =&gt; a * b,\n            divide: (a, b) =&gt; {\n                if (b === 0) throw new Error(\"Cannot divide by zero\");\n                return a / b;\n            }\n        };\n    }\n\n    getSchema() {\n        return {\n            type: \"object\",\n            properties: {\n                operation: {\n                    type: \"string\",\n                    enum: Object.keys(this.operations),\n                    description: \"Mathematical operation to perform\"\n                },\n                a: {\n                    type: \"number\",\n                    description: \"First number\"\n                },\n                b: {\n                    type: \"number\",\n                    description: \"Second number\"\n                }\n            },\n            required: [\"operation\", \"a\", \"b\"]\n        };\n    }\n\n    async execute(arguments) {\n        const { operation, a, b } = arguments;\n        \n        if (!this.operations[operation]) {\n            throw new Error(`Unsupported operation: ${operation}`);\n        }\n        \n        try {\n            const result = this.operations[operation](a, b);\n            return [{ \n                type: \"text\", \n                text: `${a} ${operation} ${b} = ${result}` \n            }];\n        } catch (error) {\n            throw new Error(`Calculation error: ${error.message}`);\n        }\n    }\n}\n\nmodule.exports = MathTool;\n</code></pre>"},{"location":"tutorials/quickstart/#step-4-create-the-main-server","title":"Step 4: Create the Main Server","text":""},{"location":"tutorials/quickstart/#python-server","title":"Python Server","text":"<pre><code># src/main.py\nimport asyncio\nfrom mcp_sdk import Server\nfrom tools.echo import EchoTool\nfrom tools.math import MathTool\n\nasync def main():\n    # Create server instance\n    server = Server(\"my-mcp-server\", \"1.0.0\")\n    \n    # Register tools\n    server.add_tool(EchoTool())\n    server.add_tool(MathTool())\n    \n    # Start server\n    print(\"Starting MCP server...\")\n    await server.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/quickstart/#nodejs-server","title":"Node.js Server","text":"<pre><code>// src/index.js\nconst { Server } = require('@modelcontextprotocol/sdk');\nconst EchoTool = require('./tools/echo');\nconst MathTool = require('./tools/math');\n\nasync function main() {\n    // Create server instance\n    const server = new Server({\n        name: \"my-mcp-server\",\n        version: \"1.0.0\"\n    });\n    \n    // Register tools\n    server.addTool(new EchoTool());\n    server.addTool(new MathTool());\n    \n    // Start server\n    console.log(\"Starting MCP server...\");\n    await server.start();\n}\n\nmain().catch(console.error);\n</code></pre>"},{"location":"tutorials/quickstart/#go-server","title":"Go Server","text":"<pre><code>// cmd/server/main.go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \n    \"github.com/modelcontextprotocol/go-sdk/server\"\n    \"my-mcp-server/internal/tools\"\n)\n\nfunc main() {\n    // Create server\n    srv := server.New(\"my-mcp-server\", \"1.0.0\")\n    \n    // Register tools\n    srv.AddTool(tools.NewEchoTool())\n    srv.AddTool(tools.NewMathTool())\n    \n    // Start server\n    log.Println(\"Starting MCP server...\")\n    if err := srv.Start(context.Background()); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"tutorials/quickstart/#rust-server","title":"Rust Server","text":"<pre><code>// src/main.rs\nuse tokio;\nuse mcp_sdk::Server;\nmod tools;\nuse tools::{EchoTool, MathTool};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create server\n    let mut server = Server::new(\"my-mcp-server\", \"1.0.0\");\n    \n    // Register tools\n    server.add_tool(Box::new(EchoTool));\n    server.add_tool(Box::new(MathTool));\n    \n    // Start server\n    println!(\"Starting MCP server...\");\n    server.start().await?;\n    \n    Ok(())\n}\n</code></pre>"},{"location":"tutorials/quickstart/#step-5-test-your-server","title":"Step 5: Test Your Server","text":""},{"location":"tutorials/quickstart/#create-a-test-script","title":"Create a Test Script","text":""},{"location":"tutorials/quickstart/#python-test","title":"Python Test","text":"<pre><code># test_server.py\nimport asyncio\nimport json\nfrom mcp_sdk.client import Client\n\nasync def test_server():\n    client = Client()\n    \n    try:\n        # Connect to server\n        await client.connect(\"stdio\", [\"python\", \"src/main.py\"])\n        \n        # Test echo tool\n        echo_result = await client.call_tool(\"echo\", {\n            \"text\": \"Hello, World!\",\n            \"prefix\": \"Server says: \"\n        })\n        print(\"Echo result:\", echo_result)\n        \n        # Test math tool\n        math_result = await client.call_tool(\"math\", {\n            \"operation\": \"add\",\n            \"a\": 5,\n            \"b\": 3\n        })\n        print(\"Math result:\", math_result)\n        \n    finally:\n        await client.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(test_server())\n</code></pre>"},{"location":"tutorials/quickstart/#manual-testing-with-curl","title":"Manual Testing with curl","text":"<pre><code># Test the server manually (if running HTTP transport)\necho '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"tools/list\"\n}' | curl -X POST \\\n    -H \"Content-Type: application/json\" \\\n    -d @- \\\n    http://localhost:8000\n</code></pre>"},{"location":"tutorials/quickstart/#step-6-run-and-test","title":"Step 6: Run and Test","text":""},{"location":"tutorials/quickstart/#start-your-server","title":"Start Your Server","text":"<pre><code># Python\npython src/main.py\n\n# Node.js\nnode src/index.js\n\n# Go\ngo run cmd/server/main.go\n\n# Rust\ncargo run\n</code></pre>"},{"location":"tutorials/quickstart/#expected-output","title":"Expected Output","text":"<p>When you start your server, you should see: </p><pre><code>Starting MCP server...\nServer listening on stdio transport...\n</code></pre><p></p>"},{"location":"tutorials/quickstart/#step-7-connect-with-claude-desktop-optional","title":"Step 7: Connect with Claude Desktop (Optional)","text":"<p>If you have Claude Desktop installed, you can connect your server:</p> <ol> <li>Open Claude Desktop settings</li> <li>Add your server configuration:</li> </ol> <pre><code>{\n  \"servers\": {\n    \"my-mcp-server\": {\n      \"command\": \"python\",\n      \"args\": [\"/path/to/your/project/src/main.py\"]\n    }\n  }\n}\n</code></pre> <ol> <li>Restart Claude Desktop</li> <li>Try asking Claude to use your tools:</li> <li>\"Echo 'Hello from MCP!'\"</li> <li>\"Calculate 15 + 27 using the math tool\"</li> </ol>"},{"location":"tutorials/quickstart/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've built your first MCP server. Here's what you can do next:</p>"},{"location":"tutorials/quickstart/#enhance-your-tools","title":"Enhance Your Tools","text":"<ul> <li>Add input validation</li> <li>Implement error handling</li> <li>Add more mathematical operations</li> <li>Create tools for file operations</li> </ul>"},{"location":"tutorials/quickstart/#add-more-features","title":"Add More Features","text":"<ul> <li>Implement resources (data sources)</li> <li>Add prompts (predefined interactions)</li> <li>Include logging and monitoring</li> <li>Add configuration management</li> </ul>"},{"location":"tutorials/quickstart/#deploy-your-server","title":"Deploy Your Server","text":"<ul> <li>Package as a container</li> <li>Deploy to cloud platforms</li> <li>Set up CI/CD pipelines</li> <li>Add health checks and metrics</li> </ul>"},{"location":"tutorials/quickstart/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Explore the Advanced Tutorial</li> <li>Learn about Security Best Practices</li> <li>Study Deployment Patterns</li> </ul>"},{"location":"tutorials/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/quickstart/#common-issues","title":"Common Issues","text":"<ol> <li>\"Module not found\" errors: Ensure all dependencies are installed and paths are correct</li> <li>Server won't start: Check port availability and permissions</li> <li>Tools not responding: Verify tool registration and schema definitions</li> <li>Connection issues: Ensure transport configuration matches client expectations</li> </ol>"},{"location":"tutorials/quickstart/#getting-help","title":"Getting Help","text":"<ul> <li>Check the FAQ</li> <li>Visit the MCP documentation</li> <li>Join the community discussions</li> <li>Review example implementations</li> </ul> <p>You now have a working MCP server! This foundation will help you understand the core concepts as you build more sophisticated integrations.</p>"},{"location":"use/","title":"Integration Guide","text":""},{"location":"use/#integration-guide","title":"Integration Guide","text":""},{"location":"use/#using-mcp-servers","title":"Using MCP Servers","text":"<p>Learn how to integrate MCP servers with various clients, platforms, and services.</p>"},{"location":"use/#integration-patterns","title":"Integration Patterns","text":""},{"location":"use/#direct-integration","title":"Direct Integration","text":"<p>Client connects directly to MCP server: </p><pre><code>Client &lt;---&gt; MCP Server\n</code></pre><p></p>"},{"location":"use/#gateway-integration","title":"Gateway Integration","text":"<p>Client connects through MCP Gateway: </p><pre><code>Client &lt;---&gt; Gateway &lt;---&gt; MCP Servers\n</code></pre><p></p>"},{"location":"use/#federated-integration","title":"Federated Integration","text":"<p>Multiple gateways with shared servers: </p><pre><code>Clients &lt;---&gt; Gateway A &lt;---&gt; Shared Servers\n         &lt;---&gt; Gateway B &lt;---&gt;\n</code></pre><p></p>"},{"location":"use/#client-libraries","title":"Client Libraries","text":""},{"location":"use/#python-client","title":"Python Client","text":"<pre><code>from mcp import Client\n\n# Initialize client\nclient = Client(\"http://localhost:8000/mcp\")\n\n# List available tools\ntools = client.list_tools()\nfor tool in tools:\n    print(f\"Tool: {tool.name} - {tool.description}\")\n\n# Call a tool\nresult = client.call_tool(\n    \"process_data\",\n    {\"input\": \"test data\", \"format\": \"json\"}\n)\nprint(f\"Result: {result}\")\n\n# Access resources\nresource = client.get_resource(\"config://settings\")\nprint(f\"Settings: {resource}\")\n</code></pre>"},{"location":"use/#javascript-client","title":"JavaScript Client","text":"<pre><code>import { MCPClient } from '@mcp/client';\n\n// Initialize client\nconst client = new MCPClient({\n  url: 'http://localhost:8000/mcp',\n  apiKey: process.env.MCP_API_KEY\n});\n\n// List tools\nconst tools = await client.listTools();\ntools.forEach(tool =&gt; {\n  console.log(`Tool: ${tool.name} - ${tool.description}`);\n});\n\n// Call tool\nconst result = await client.callTool('process_data', {\n  input: 'test data',\n  format: 'json'\n});\nconsole.log('Result:', result);\n\n// Get resource\nconst resource = await client.getResource('config://settings');\nconsole.log('Settings:', resource);\n</code></pre>"},{"location":"use/#go-client","title":"Go Client","text":"<pre><code>package main\n\nimport (\n    \"github.com/mcp/go-client\"\n)\n\nfunc main() {\n    // Initialize client\n    client := mcp.NewClient(\"http://localhost:8000/mcp\")\n    \n    // List tools\n    tools, err := client.ListTools()\n    if err != nil {\n        log.Fatal(err)\n    }\n    \n    for _, tool := range tools {\n        fmt.Printf(\"Tool: %s - %s\\n\", tool.Name, tool.Description)\n    }\n    \n    // Call tool\n    result, err := client.CallTool(\"process_data\", map[string]interface{}{\n        \"input\": \"test data\",\n        \"format\": \"json\",\n    })\n    \n    if err != nil {\n        log.Fatal(err)\n    }\n    \n    fmt.Printf(\"Result: %v\\n\", result)\n}\n</code></pre>"},{"location":"use/#claude-desktop-integration","title":"Claude Desktop Integration","text":""},{"location":"use/#configuration","title":"Configuration","text":"<pre><code>// claude_desktop_config.json\n{\n  \"mcpServers\": {\n    \"my-server\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"my_mcp_server\"],\n      \"env\": {\n        \"MCP_API_KEY\": \"${MCP_API_KEY}\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"use/#installation","title":"Installation","text":"<pre><code># Install server for Claude Desktop\nuv run mcp install my_server.py --name \"My Server\"\n\n# With configuration\nuv run mcp install my_server.py \\\n  --name \"My Server\" \\\n  -v API_KEY=\"${API_KEY}\" \\\n  -v DEBUG=true\n</code></pre>"},{"location":"use/#gateway-integration_1","title":"Gateway Integration","text":""},{"location":"use/#register-with-gateway","title":"Register with Gateway","text":"<pre><code># Register server\ncurl -X POST http://gateway.example.com/servers \\\n  -H \"Authorization: Bearer ${GATEWAY_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"my-server\",\n    \"url\": \"http://my-server:8000/mcp\",\n    \"transport\": \"http\",\n    \"authentication\": {\n      \"type\": \"bearer\",\n      \"token\": \"${SERVER_TOKEN}\"\n    }\n  }'\n</code></pre>"},{"location":"use/#gateway-client-usage","title":"Gateway Client Usage","text":"<pre><code>from mcp_gateway import GatewayClient\n\n# Connect to gateway\ngateway = GatewayClient(\n    url=\"http://gateway.example.com\",\n    token=os.getenv(\"GATEWAY_TOKEN\")\n)\n\n# List available servers\nservers = gateway.list_servers()\nprint(f\"Available servers: {servers}\")\n\n# Call tool on specific server\nresult = gateway.call_tool(\n    server=\"my-server\",\n    tool=\"process_data\",\n    params={\"input\": \"test\"}\n)\n</code></pre>"},{"location":"use/#rest-api-integration","title":"REST API Integration","text":""},{"location":"use/#openapi-specification","title":"OpenAPI Specification","text":"<pre><code>openapi: 3.0.0\ninfo:\n  title: MCP Server API\n  version: 1.0.0\npaths:\n  /mcp:\n    post:\n      summary: Execute MCP request\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/MCPRequest'\n      responses:\n        '200':\n          description: Successful response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/MCPResponse'\n\ncomponents:\n  schemas:\n    MCPRequest:\n      type: object\n      properties:\n        jsonrpc:\n          type: string\n          enum: [\"2.0\"]\n        method:\n          type: string\n        params:\n          type: object\n        id:\n          type: integer\n</code></pre>"},{"location":"use/#rest-client-example","title":"REST Client Example","text":"<pre><code>import requests\n\nclass MCPRestClient:\n    def __init__(self, base_url, api_key=None):\n        self.base_url = base_url\n        self.headers = {\"Content-Type\": \"application/json\"}\n        if api_key:\n            self.headers[\"Authorization\"] = f\"Bearer {api_key}\"\n    \n    def call_tool(self, tool_name, params):\n        payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": \"tools/call\",\n            \"params\": {\n                \"name\": tool_name,\n                \"arguments\": params\n            },\n            \"id\": 1\n        }\n        \n        response = requests.post(\n            f\"{self.base_url}/mcp\",\n            json=payload,\n            headers=self.headers\n        )\n        \n        response.raise_for_status()\n        return response.json()[\"result\"]\n</code></pre>"},{"location":"use/#websocket-integration","title":"WebSocket Integration","text":""},{"location":"use/#websocket-client","title":"WebSocket Client","text":"<pre><code>class MCPWebSocketClient {\n  constructor(url) {\n    this.ws = new WebSocket(url);\n    this.requestId = 0;\n    this.pending = new Map();\n    \n    this.ws.on('message', (data) =&gt; {\n      const response = JSON.parse(data);\n      const handler = this.pending.get(response.id);\n      if (handler) {\n        handler(response);\n        this.pending.delete(response.id);\n      }\n    });\n  }\n  \n  async callTool(name, params) {\n    return new Promise((resolve, reject) =&gt; {\n      const id = ++this.requestId;\n      \n      this.pending.set(id, (response) =&gt; {\n        if (response.error) {\n          reject(new Error(response.error.message));\n        } else {\n          resolve(response.result);\n        }\n      });\n      \n      this.ws.send(JSON.stringify({\n        jsonrpc: \"2.0\",\n        method: \"tools/call\",\n        params: { name, arguments: params },\n        id\n      }));\n    });\n  }\n}\n</code></pre>"},{"location":"use/#event-streaming","title":"Event Streaming","text":""},{"location":"use/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<pre><code>from flask import Response, Flask\nimport json\n\napp = Flask(__name__)\n\n@app.route('/mcp/stream')\ndef stream_events():\n    def generate():\n        # Subscribe to events\n        for event in mcp.subscribe_events():\n            yield f\"data: {json.dumps(event)}\\n\\n\"\n    \n    return Response(\n        generate(),\n        mimetype=\"text/event-stream\",\n        headers={\n            \"Cache-Control\": \"no-cache\",\n            \"X-Accel-Buffering\": \"no\"\n        }\n    )\n</code></pre>"},{"location":"use/#client-side-sse","title":"Client-Side SSE","text":"<pre><code>const eventSource = new EventSource('/mcp/stream');\n\neventSource.onmessage = (event) =&gt; {\n  const data = JSON.parse(event.data);\n  console.log('Received event:', data);\n};\n\neventSource.onerror = (error) =&gt; {\n  console.error('SSE error:', error);\n  eventSource.close();\n};\n</code></pre>"},{"location":"use/#webhook-integration","title":"Webhook Integration","text":""},{"location":"use/#webhook-configuration","title":"Webhook Configuration","text":"<pre><code>@mcp.on_tool_execution\ndef webhook_handler(tool_name, params, result):\n    \"\"\"Send webhook on tool execution\"\"\"\n    webhook_url = os.getenv(\"WEBHOOK_URL\")\n    \n    payload = {\n        \"event\": \"tool_executed\",\n        \"tool\": tool_name,\n        \"params\": params,\n        \"result\": result,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n    \n    requests.post(webhook_url, json=payload)\n</code></pre>"},{"location":"use/#webhook-receiver","title":"Webhook Receiver","text":"<pre><code>from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/webhook/mcp', methods=['POST'])\ndef receive_webhook():\n    data = request.json\n    \n    # Verify webhook signature\n    signature = request.headers.get('X-MCP-Signature')\n    if not verify_signature(request.data, signature):\n        return {'error': 'Invalid signature'}, 401\n    \n    # Process webhook\n    event_type = data.get('event')\n    if event_type == 'tool_executed':\n        process_tool_execution(data)\n    \n    return {'status': 'received'}, 200\n</code></pre>"},{"location":"use/#authentication-methods","title":"Authentication Methods","text":""},{"location":"use/#api-key-authentication","title":"API Key Authentication","text":"<pre><code>def authenticate_api_key(api_key):\n    client = MCPClient(\n        url=\"http://localhost:8000/mcp\",\n        headers={\"X-API-Key\": api_key}\n    )\n    return client\n</code></pre>"},{"location":"use/#oauth-20-integration","title":"OAuth 2.0 Integration","text":"<pre><code>from authlib.integrations.requests_client import OAuth2Session\n\noauth = OAuth2Session(\n    client_id=CLIENT_ID,\n    client_secret=CLIENT_SECRET,\n    redirect_uri=REDIRECT_URI\n)\n\n# Get token\ntoken = oauth.fetch_token(\n    TOKEN_URL,\n    authorization_response=request.url\n)\n\n# Use token with MCP\nclient = MCPClient(\n    url=\"http://localhost:8000/mcp\",\n    headers={\"Authorization\": f\"Bearer {token['access_token']}\"}\n)\n</code></pre>"},{"location":"use/#error-handling","title":"Error Handling","text":""},{"location":"use/#client-side-error-handling","title":"Client-Side Error Handling","text":"<pre><code>class MCPClientWithRetry:\n    def __init__(self, url, max_retries=3):\n        self.url = url\n        self.max_retries = max_retries\n    \n    def call_tool_with_retry(self, tool_name, params):\n        for attempt in range(self.max_retries):\n            try:\n                return self.call_tool(tool_name, params)\n            \n            except MCPError as e:\n                if e.code == -32000:  # Server error\n                    if attempt &lt; self.max_retries - 1:\n                        time.sleep(2 ** attempt)  # Exponential backoff\n                        continue\n                raise\n            \n            except ConnectionError as e:\n                if attempt &lt; self.max_retries - 1:\n                    time.sleep(1)\n                    continue\n                raise\n</code></pre>"},{"location":"use/#usage-examples","title":"Usage Examples","text":""},{"location":"use/#data-processing-pipeline","title":"Data Processing Pipeline","text":"<pre><code># Chain multiple MCP tools\nasync def process_pipeline(data):\n    # Step 1: Validate data\n    validated = await client.call_tool(\"validate_data\", {\"data\": data})\n    \n    # Step 2: Transform data\n    transformed = await client.call_tool(\"transform_data\", {\n        \"data\": validated,\n        \"format\": \"normalized\"\n    })\n    \n    # Step 3: Analyze data\n    analysis = await client.call_tool(\"analyze_data\", {\n        \"data\": transformed,\n        \"metrics\": [\"mean\", \"median\", \"std\"]\n    })\n    \n    # Step 4: Generate report\n    report = await client.call_tool(\"generate_report\", {\n        \"analysis\": analysis,\n        \"format\": \"pdf\"\n    })\n    \n    return report\n</code></pre>"},{"location":"use/#multi-server-orchestration","title":"Multi-Server Orchestration","text":"<pre><code>async def orchestrate_servers():\n    # Connect to multiple servers\n    github_client = MCPClient(\"http://github-server:8000/mcp\")\n    jira_client = MCPClient(\"http://jira-server:8000/mcp\")\n    slack_client = MCPClient(\"http://slack-server:8000/mcp\")\n    \n    # Get GitHub issues\n    issues = await github_client.call_tool(\"list_issues\", {\n        \"repo\": \"myorg/myrepo\",\n        \"state\": \"open\"\n    })\n    \n    # Create Jira tickets\n    for issue in issues:\n        ticket = await jira_client.call_tool(\"create_ticket\", {\n            \"title\": issue[\"title\"],\n            \"description\": issue[\"body\"],\n            \"labels\": issue[\"labels\"]\n        })\n        \n        # Notify via Slack\n        await slack_client.call_tool(\"send_message\", {\n            \"channel\": \"#dev-team\",\n            \"text\": f\"Created Jira ticket {ticket['key']} for GitHub issue #{issue['number']}\"\n        })\n</code></pre>"},{"location":"use/#next-steps","title":"Next Steps","text":"<ul> <li>\ud83e\udd16 Claude Integration</li> <li>\ud83c\udf10 Gateway Setup</li> <li>\ud83d\udce6 API Client Libraries</li> <li>\ud83d\udd17 Webhook Configuration</li> </ul>"}]}