{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe0 Home","text":""},{"location":"#mcp-best-practices-guide","title":"MCP Best Practices Guide","text":"<p>This guide provides high\u2011level, vendor\u2011neutral guidance for building, deploying, and operating MCP servers in production. It emphasizes principles and patterns over framework specifics, and favors simple, observable, secure designs that scale.</p>"},{"location":"#what-is-mcp","title":"What is MCP?","text":"<p>The Model Context Protocol (MCP) is an open protocol that standardizes how applications provide context to large language models (LLMs). Think of MCP like a USB-C port for AI applications\u2014it provides a standardized way to connect AI models to different data sources and tools.</p>"},{"location":"#what-this-guide-covers","title":"What This Guide Covers","text":"<p>The guide is organized into practical sections that mirror the MCP server lifecycle.</p> Section Focus Key Topics \ud83e\udded Overview What MCP is and where it fits Core building blocks; when to use MCP; success factors \u2b50 Best Practices Principles that stand the test of production Single responsibility; contracts\u2011first; additive change; stateless defaults \ud83d\udcbb Develop Building servers with discipline Outcomes and contracts; observability from day one; least\u2011privilege integrations \ud83e\uddea Test Validating behavior and quality Unit/integration/E2E; evals and baselines; coverage and CI gates \ud83d\udce6 Package Reliable distribution and supply chain integrity Containers; SBOMs and signing; provenance; trusted catalogs \ud83d\ude80 Deploy Topology and platform guidance Gateway front\u2011door; environment separation; sandboxing; rollout strategies \u2699\ufe0f Operate Lifecycle and day\u20112 excellence SLOs; monitoring and incident flow; catalog and approvals; multi\u2011tenancy \ud83d\udee1\ufe0f Secure Defense\u2011in\u2011depth for MCP Identity and access; policy\u2011as\u2011code; runtime controls; continuous assurance \ud83d\udd0c Use How clients/hosts consume MCP Host choices; gateway mediation; good\u2011citizen patterns"},{"location":"#who-this-guide-is-for","title":"Who This Guide Is For","text":"<ul> <li>Developers building MCP servers and integrations</li> <li>DevOps Engineers deploying and operating MCP infrastructure</li> <li>Engineering Teams adopting MCP in production environments</li> <li>Technical Leaders evaluating MCP for their organizations</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If you're new to MCP, start with:</p> <ol> <li>Overview \u2014 fundamentals and context</li> <li>Best Practices \u2014 essential standards</li> <li>Develop \u2014 building your first server</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>This guide is community\u2011driven. We welcome contributions, corrections, and improvements. The content reflects real\u2011world experience and evolving best practices from the MCP community.</p>"},{"location":"#learn-the-protocol","title":"Learn the Protocol","text":"<p>For protocol details (transports, messages, discovery), refer to the official specification at https://spec.modelcontextprotocol.io. This guide assumes familiarity with the spec and focuses on how to apply it effectively in production.</p> <p>Ready to build production-grade MCP servers? Let's get started! \ud83d\ude80</p>"},{"location":"contribute/","title":"\ud83d\ude4c Contribute","text":""},{"location":"contribute/#contribution-guide","title":"Contribution Guide","text":""},{"location":"contribute/#contributing-to-mcp-best-practices-guide","title":"Contributing to MCP Best Practices Guide","text":"<p>Thank you for your interest in contributing to the MCP Best Practices Guide! This community-driven documentation helps developers build better MCP servers and integrations.</p>"},{"location":"contribute/#getting-started","title":"Getting Started","text":""},{"location":"contribute/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+ installed</li> <li>Git configured for your GitHub account</li> <li>Basic familiarity with Markdown and MkDocs</li> </ul>"},{"location":"contribute/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li>Fork the repository on GitHub</li> <li> <p>Clone your fork locally:</p> </li> <li> <p>Set up the development environment:</p> </li> <li> <p>Start the local development server:</p> </li> </ol> <p>This will serve the documentation at http://127.0.0.1:8003/</p>"},{"location":"contribute/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contribute/#workflow-overview","title":"Workflow Overview","text":"<ol> <li>Assign work to yourself using a GitHub issue</li> <li>Browse open issues</li> <li>Comment on an issue to indicate you're working on it</li> <li> <p>Create a new issue if your contribution doesn't have one</p> </li> <li> <p>Create a branch for your changes:</p> </li> <li> <p>Make your changes following the guidelines below</p> </li> <li> <p>Test locally using the Makefile:</p> </li> <li> <p>Submit a pull request when ready</p> </li> </ol>"},{"location":"contribute/#content-guidelines","title":"Content Guidelines","text":""},{"location":"contribute/#page-status-management","title":"Page Status Management","text":"<p>Mark your pages clearly with status indicators:</p> <p>Draft pages:</p> <p>Ready pages:</p>"},{"location":"contribute/#navigation-management","title":"Navigation Management","text":"<ul> <li>Add new pages to the appropriate section in <code>mkdocs.yml</code></li> <li>Use clear, descriptive navigation titles</li> <li>Organize content logically within the existing structure</li> <li>Comment on navigation changes in your pull request</li> </ul>"},{"location":"contribute/#writing-style","title":"Writing Style","text":"<ul> <li>Be practical: Focus on real-world, actionable guidance</li> <li>Be specific: Provide concrete examples and code snippets</li> <li>Be clear: Use simple language and avoid jargon when possible</li> <li>Be consistent: Follow existing patterns and formatting</li> </ul>"},{"location":"contribute/#content-structure","title":"Content Structure","text":"<ul> <li>Use clear headings and subheadings</li> <li>Include code examples where relevant</li> <li>Add links to official MCP documentation where appropriate</li> <li>Provide context for recommendations</li> </ul>"},{"location":"contribute/#technical-guidelines","title":"Technical Guidelines","text":""},{"location":"contribute/#file-organization","title":"File Organization","text":"<ul> <li>Place documentation in the appropriate <code>docs/</code> subdirectory</li> <li>Use kebab-case for file names (e.g., <code>mcp-best-practices.md</code>)</li> <li>Follow the existing directory structure</li> </ul>"},{"location":"contribute/#markdown-standards","title":"Markdown Standards","text":"<ul> <li>Use ATX-style headers (<code>#</code>, <code>##</code>, <code>###</code>)</li> <li>Include code language specifications in fenced code blocks</li> <li>Use relative links for internal documentation references</li> <li>Add alt text for images</li> </ul>"},{"location":"contribute/#code-examples","title":"Code Examples","text":"<ul> <li>Test all code examples before submitting</li> <li>Include language-specific examples where relevant</li> <li>Provide context and explanation for code snippets</li> <li>Follow the coding standards of the respective language</li> </ul>"},{"location":"contribute/#building-and-testing","title":"Building and Testing","text":""},{"location":"contribute/#local-development","title":"Local Development","text":""},{"location":"contribute/#available-make-targets","title":"Available Make Targets","text":"<ul> <li><code>make venv</code> - Create/recreate virtual environment</li> <li><code>make venv-update</code> - Update existing virtual environment</li> <li><code>make serve</code> - Start development server</li> <li><code>make build</code> - Build documentation</li> <li><code>make clean</code> - Remove generated files</li> <li><code>make deploy</code> - Deploy to GitHub Pages (maintainers only)</li> </ul>"},{"location":"contribute/#submitting-changes","title":"Submitting Changes","text":""},{"location":"contribute/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a descriptive PR title that summarizes your changes</li> <li>Fill out the PR description with:</li> <li>Summary of changes</li> <li>Related issue numbers</li> <li> <p>Any special testing instructions</p> </li> <li> <p>Ensure your PR:</p> </li> <li>Builds successfully locally</li> <li>Follows the contribution guidelines</li> <li>Includes appropriate documentation updates</li> <li>Has been tested with <code>make serve</code></li> </ol>"},{"location":"contribute/#review-process","title":"Review Process","text":"<ul> <li>All pull requests require review from maintainers</li> <li>Address feedback promptly and professionally</li> <li>Be prepared to make revisions based on review comments</li> <li>Maintain a collaborative and respectful tone</li> </ul>"},{"location":"contribute/#community-guidelines","title":"Community Guidelines","text":""},{"location":"contribute/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive in all interactions</li> <li>Focus on constructive feedback and collaboration</li> <li>Help newcomers and answer questions when possible</li> <li>Assume positive intent in communications</li> </ul>"},{"location":"contribute/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation questions: Open an issue with the <code>question</code> label</li> <li>Technical problems: Check existing issues or create a new one</li> <li>General discussion: Use GitHub Discussions when available</li> </ul>"},{"location":"contribute/#maintenance-and-releases","title":"Maintenance and Releases","text":""},{"location":"contribute/#website-updates","title":"Website Updates","text":"<ul> <li>Changes to the main branch automatically trigger documentation rebuilds</li> <li>Future automation is planned for streamlined deployment</li> <li>Maintainers handle production deployments</li> </ul>"},{"location":"contribute/#content-maintenance","title":"Content Maintenance","text":"<ul> <li>Regular reviews ensure content stays current with MCP developments</li> <li>Community contributions help identify outdated information</li> <li>Version updates are coordinated with MCP protocol releases</li> </ul>"},{"location":"contribute/#recognition","title":"Recognition","text":"<p>Contributors are recognized through:</p> <ul> <li>Attribution in commit messages and release notes</li> <li>GitHub contributor graphs and statistics</li> <li>Community acknowledgment in documentation</li> </ul>"},{"location":"best-practice/","title":"Best Practices","text":""},{"location":"best-practice/#mcp-best-practices-enterprise-guide","title":"MCP Best Practices \u2014 Enterprise Guide","text":"<p>This guide provides high\u2011level, vendor\u2011neutral guidance for building, deploying, and operating MCP servers in production. It emphasizes principles and patterns that scale in enterprise environments, focusing on security, reliability, and maintainability.</p>"},{"location":"best-practice/#what-is-mcp-and-why-it-matters","title":"What Is MCP (and why it matters)","text":"<p>The Model Context Protocol is an open standard that connects AI applications (clients) to the systems where context and actions live (servers). Instead of bespoke, per\u2011app integrations, MCP defines a consistent way to discover capabilities and invoke them safely:</p> <ul> <li>Servers expose tools, resources, and prompts with typed schemas and descriptions.</li> <li>Clients connect over stdio (local) or streamable HTTP (remote) to discover and call capabilities.</li> <li>The protocol enables secure, auditable action execution with clear contracts, making it the preferred standard for building AI tools at enterprise scale.</li> </ul> <p>In this guide, \"AI tools\" are implemented as MCP servers. Treat MCP as the default interface for agent\u2011accessible capabilities.</p>"},{"location":"best-practice/#mcp-core-concepts","title":"MCP Core Concepts","text":"<ul> <li>Tools: Executable actions with explicit input/output schemas, constraints, and side\u2011effect disclosures.</li> <li>Resources: Readable data sources (files, records, documents) the client can fetch for model context.</li> <li>Prompts: Pre\u2011defined interaction templates that standardize tasks and reduce prompt drift.</li> <li>Discovery: Clients enumerate available tools/resources/prompts and obtain schemas at connect time.</li> <li>Authorization: Servers enforce scopes/roles per tool, with optional approvals for high\u2011risk actions.</li> <li>Transports: stdio for local processes; streamable HTTP for remote services and scale\u2011out.</li> </ul>"},{"location":"best-practice/#design-principles","title":"Design Principles","text":"<ul> <li>Single responsibility: One clear domain and authentication boundary per server.</li> <li>Bounded toolsets: Focused tools with specific contracts; avoid \"kitchen\u2011sink\" servers.</li> <li>Contracts first: Strict input/output schemas, explicit side effects, documented errors.</li> <li>Additive change: Version schemas; prefer additive evolution; publish deprecations.</li> <li>Stateless by default: Keep execution stateless for scale and resiliency.</li> <li>Security by design: Integrate identity, authorization, and audit into the server\u2014not around it.</li> <li>Controlled autonomy: Offer precise, least-privilege tools with approval paths for high-impact actions.</li> </ul>"},{"location":"best-practice/#architecture-and-deployment","title":"Architecture and Deployment","text":""},{"location":"best-practice/#transport-and-topology","title":"Transport and Topology","text":"<ul> <li>stdio: Best for local, per-user integrations launched by a client. Strong default isolation; limited for centralized operations.</li> <li>Streamable HTTP: Best for remote, shared services and scale-out. Requires standard web hardening and production SRE practices.</li> <li>Direct vs. gateway: Direct connections are simple; gateway patterns centralize authN/Z, routing, catalogs, and policy enforcement for many servers.</li> </ul>"},{"location":"best-practice/#mcp-gateway-pattern","title":"MCP Gateway Pattern","text":"<p>Use an enterprise MCP Gateway when you need centralized security, control, and scale across many servers and tenants. The gateway becomes the single, policy\u2011enforced ingress for agent access to organizational capabilities.</p> <p>Gateway responsibilities: - Centralized control: Authentication, authorization, routing, rate limiting, quotas, and service discovery/catalog - Security boundary: Terminate TLS, enforce mTLS to backends, broker OAuth tokens/scopes, translate permissions per tool - Policy and guardrails: Apply policy\u2011as\u2011code (e.g., OPA) for tool allow/deny, environment gating, approval requirements - Multi\u2011tenancy: Per\u2011tenant isolation for configs, keys, logs, metrics, limits, and catalogs - Governance and audit: Standardized logging, request correlation, audit trails across all servers - Reliability and scale: HA, autoscaling, circuit breaking, retries with idempotency, backpressure</p> <p></p>"},{"location":"best-practice/#local-vs-remote-deployment","title":"Local vs Remote Deployment","text":"<ul> <li>Local (stdio): Per\u2011user, ephemeral processes; strong isolation, no inbound networking, direct access to local context. Best for developer tools and privacy\u2011sensitive workflows.</li> <li>Remote (HTTP): Shared, multi\u2011tenant services managed by platform teams; central policy, observability, and scaling. Best for enterprise integrations.</li> <li>Hybrid: Local servers for personal context + remote servers for enterprise systems, mediated by a gateway for unified policy.</li> </ul>"},{"location":"best-practice/#multi-tenancy-and-isolation","title":"Multi-tenancy and Isolation","text":"<ul> <li>Single-tenant by default: Simplifies auditing, secrets, and blast radius</li> <li>Explicit tenancy boundaries: Separate data paths, keys, and logs by tenant</li> <li>Workload isolation: Use containers with non-root users, read-only filesystems, minimal base images</li> </ul>"},{"location":"best-practice/#security-foundations","title":"Security Foundations","text":""},{"location":"best-practice/#identity-and-access","title":"Identity and Access","text":"<ul> <li>OAuth 2.0 per MCP specification: Implement authorization flows and token refresh; scope permissions per tool and per action (read vs. write)</li> <li>Least privilege: Default to read-only tools; enable write/edit tools behind explicit roles and policies</li> <li>Fine-grained authorization: Enforce per-tool, per-parameter authorization checks; require approvals for high-risk operations</li> </ul>"},{"location":"best-practice/#inputoutput-safety","title":"Input/Output Safety","text":"<ul> <li>Validate inputs: Enforce strong schemas, types, ranges, and patterns; reject on first failure</li> <li>Sanitize outputs: Prevent injection into downstream systems; clearly label side effects and references</li> <li>Guardrails and approvals: Add policy checks before execution and require user approval where warranted</li> </ul>"},{"location":"best-practice/#secrets-and-transport","title":"Secrets and Transport","text":"<ul> <li>Managed secrets: Store credentials in enterprise secret managers; never inline secrets in configs or code</li> <li>TLS everywhere: Encrypt HTTP transport; sign and verify containers and artifacts; use trusted registries only</li> <li>Network policy: Restrict egress/ingress; apply service-to-service authentication and explicit allowlists</li> </ul>"},{"location":"best-practice/#tooling-discipline","title":"Tooling Discipline","text":""},{"location":"best-practice/#tool-design","title":"Tool Design","text":"<ul> <li>Specific, actionable descriptions: State purpose, constraints, and side effects. Include usage guidance and follow-up steps</li> <li>Stable interfaces: Version tool schemas; prefer additive changes; announce deprecations with timelines</li> <li>Bounded capability: Avoid \"kitchen-sink\" tools; break into focused, testable actions</li> </ul>"},{"location":"best-practice/#toolset-management","title":"Toolset Management","text":"<ul> <li>Read-only mode: Support deployment with read-only tools by configuration</li> <li>Dynamic enablement: Enable/disable tools based on tenant, role, environment, or risk level</li> <li>Production filtering: Exclude destructive operations in production; gate sensitive tools behind approvals</li> </ul>"},{"location":"best-practice/#state-management","title":"State Management","text":"<ul> <li>Stateless by default: Keep execution stateless for scale and resiliency</li> <li>Externalize state: Use managed stores (cache, DB) with clear TTLs and PII handling; avoid hidden server memory</li> </ul>"},{"location":"best-practice/#long-running-and-side-effecting-operations","title":"Long-Running and Side-Effecting Operations","text":"<ul> <li>Asynchronous patterns: For operations exceeding request timeouts, return a handle and provide status/poll tools</li> <li>Idempotency keys: Require client-provided idempotency keys for create/update operations</li> <li>Compensating actions: Document and provide explicit rollback tools where feasible</li> </ul>"},{"location":"best-practice/#scalability-and-reliability","title":"Scalability and Reliability","text":"<ul> <li>Horizontal scale: Design for concurrent, short-lived requests; prefer idempotent operations and safe retries</li> <li>Rate limiting and backpressure: Apply per-tenant, per-tool limits; surface \"try later\" semantics; protect upstream systems</li> <li>Health, readiness, and circuit breakers: Publish health endpoints; trip on dependency failures; shed load gracefully</li> <li>Caching and batching: Cache read-heavy operations with TTL; batch compatible requests to reduce API usage and cost</li> <li>Compatibility and versioning: Version the server, tool schemas, and side-effect contracts; provide feature detection</li> </ul>"},{"location":"best-practice/#performance-practices","title":"Performance Practices","text":"<ul> <li>Concurrency model: Use async I/O for network-bound tools; bound worker pools for CPU tasks; avoid global locks</li> <li>Hot-path optimization: Pre-warm connections, cache tokens, and reuse HTTP clients with timeouts and retries</li> <li>Budgeting: Track token, API, and compute budgets per tenant; shed non-critical work under pressure</li> </ul>"},{"location":"best-practice/#observability-and-governance","title":"Observability and Governance","text":"<ul> <li>Structured audit trails: Capture who/what/when/why, including tool arguments (with redaction), decisions, and outcomes</li> <li>Metrics that matter: Track tool success rate, latency, error classes, approval deferrals, and policy denials</li> <li>Policy as code: Centralize guardrails (e.g., OPA) and apply consistently across environments</li> <li>Curated catalogs: Maintain an approved server catalog with ownership, versions, capabilities, security review dates, and compliance tags</li> </ul>"},{"location":"best-practice/#slos-and-runbooks","title":"SLOs and Runbooks","text":"<ul> <li>SLOs: Define success rate, p95 latency, and error budgets per critical tool</li> <li>Runbooks: Document common failures, dependency outages, rate-limit responses, and rollback steps</li> <li>Change windows: Coordinate releases with dependency owners; pin versions and provide rollbacks</li> </ul>"},{"location":"best-practice/#operations-and-tenancy","title":"Operations and Tenancy","text":"<ul> <li>Environments: Separate dev/stage/prod credentials, routes, policies, quotas; avoid cross\u2011env leakage</li> <li>Tenancy: Per\u2011tenant configs/logs/metrics/limits; tenant\u2011aware authZ; discovery reflects tenant/env differences</li> <li>Quotas &amp; budgets: Per\u2011tenant/tool limits; alerting; auto\u2011degrade non\u2011critical work when over budget</li> <li>Dependency protection: Bounded concurrency, backoff with jitter; strict validation of third\u2011party responses</li> </ul>"},{"location":"best-practice/#build-vs-reuse","title":"Build vs. Reuse","text":"<ul> <li>Prefer official/vendor servers: Start with vendor\u2011provided MCP servers for common SaaS and internal platforms</li> <li>Vet and catalog: Only adopt servers that are maintained, reviewed, versioned, and policy\u2011compliant</li> <li>Extend before rewrite: Contribute fixes upstream or wrap with gateway policies; build custom servers only when gaps are material</li> <li>Exit criteria: If a third\u2011party server falls behind (security, compatibility, maintenance), plan a controlled migration</li> </ul>"},{"location":"best-practice/#testing-and-quality","title":"Testing and Quality","text":"<ul> <li>Cross\u2011model evaluation: Validate tool discovery and execution across hosted and local models; monitor behavioral drift</li> <li>Security tests: Negative testing, authorization bypass attempts, input fuzzing, and rate-limit validation</li> <li>Load and chaos: Establish SLOs; test degradations, dependency outages, and retry/idempotency behavior</li> <li>Pre-release gates: Block releases on failing quality, security, or performance thresholds</li> <li>Contract tests: Maintain tool schema contract tests and golden responses for backward compatibility</li> </ul>"},{"location":"best-practice/#packaging-and-distribution","title":"Packaging and Distribution","text":""},{"location":"best-practice/#containerization-best-practices","title":"Containerization Best Practices","text":"<ul> <li>Minimal base images: Distroless/UBI minimal; remove compilers and shells at runtime; run as non\u2011root</li> <li>Health endpoints: Implement <code>/health</code> and <code>/ready</code>; wire liveness/readiness probes with sane thresholds</li> <li>Provenance: Generate SBOM (e.g., CycloneDX), sign images (cosign), and maintain attestations</li> <li>Dependency hygiene: Pin versions, use lock files, avoid transitive risk; automate vulnerability PRs</li> </ul>"},{"location":"best-practice/#supply-chain-security","title":"Supply Chain Security","text":"<ul> <li>SBOMs: Produce per\u2011build SBOMs and store with artifacts; fail builds on critical vulnerabilities</li> <li>Signing: Sign containers and manifests; verify at deploy; enforce signature policy in clusters</li> <li>Reproducibility: Deterministic builds, pinned bases, and cached layers; record build metadata</li> </ul>"},{"location":"best-practice/#language-and-sdk-choices","title":"Language and SDK Choices","text":"<ul> <li>Python: Fastest iteration, rich data/ML ecosystem, great async I/O for network\u2011bound tools. Mind GIL for CPU tasks and cold\u2011start time.</li> <li>Go: Single static binary, low memory footprint, strong concurrency model. Excellent for high\u2011throughput, low\u2011latency services.</li> <li>TypeScript/Node: Mature ecosystem for web/API tooling, first\u2011class async I/O, easy JSON handling. Good for API wrappers.</li> <li>SDK maturity: Official TypeScript and Python SDKs tend to lead; Go SDK is evolving. Prefer official SDKs; pin versions.</li> </ul> <p>Principle: Choose the language that best matches your operational model and integration profile. Optimize for maintainability, observability, and SLOs\u2014not theoretical speed.</p>"},{"location":"best-practice/#quick-build-checklist","title":"Quick Build Checklist","text":"<p>\u2705 Purpose and scope: Single, clearly defined server role and bounded toolset \u2705 SDK and spec: Official SDK where possible; document SDK/spec versions \u2705 Security: OAuth scopes, least-privilege tools, approvals for high-risk actions, secrets in a manager \u2705 Validation: Strong input schemas, output sanitization, error taxonomy and retries with idempotency \u2705 Operations: Health/readiness, rate limits, backpressure, circuit breakers, and basic SLOs \u2705 Observability: Structured audit logs, metrics (success/latency/errors), tracing/correlation IDs \u2705 Compatibility: Versioned tool schemas, deprecation policy, feature detection, contract tests \u2705 Packaging: Minimal signed container, non\u2011root runtime, reproducible builds \u2705 Docs: README with capabilities/tags, environment variables, runbooks, and changelog  </p>"},{"location":"best-practice/#production-readiness-checklist","title":"Production Readiness Checklist","text":"<p>\u2705 Identity and authorization implemented with least privilege and approvals for high-risk tools \u2705 Input validation, output sanitization, and policy guardrails in place \u2705 Audit logging, metrics, and alerts wired into enterprise observability \u2705 Rate limits, backpressure, health checks, and circuit breakers configured \u2705 Secrets in a managed store; containers minimal, signed, and non-root \u2705 Versioned APIs and tools with clear deprecation paths and compatibility tests \u2705 Documented SLOs, runbooks, incident response, and rollback procedures </p>"},{"location":"best-practice/#enterprise-adoption-patterns","title":"Enterprise Adoption Patterns","text":"<ul> <li>Host responsibilities: Client apps must show full tool descriptions, request approvals for risky actions, and prevent tool shadowing</li> <li>Environment segmentation: Distinct dev/stage/prod; different toolsets and policies per environment</li> <li>Change management: Deprecation policies, version pinning, rollback strategies, and migration guidance</li> </ul> <p>MCP servers succeed in the enterprise when they are treated as durable products: narrowly scoped, strongly governed, observable, and easy to evolve. Favor clarity, safety, and operability over breadth\u2014then scale capabilities through catalogs and consistent patterns rather than bespoke implementations.</p> <p>See also: Overview, Develop, Test, Package, Deploy, Operate, Secure, Use.</p>"},{"location":"deploy/","title":"Deploy","text":""},{"location":"deploy/#deploy","title":"Deploy","text":"<p>Deploy MCP servers behind a gateway on hardened container platforms with strong isolation and guardrails.</p>"},{"location":"deploy/#recommended-topology","title":"Recommended Topology","text":"<ul> <li>MCP Gateway as single pane of glass: centralized authN/Z, routing, quotas, catalogs, policy enforcement, and audit correlation.</li> <li>Separate environments (dev/stage/prod) with distinct credentials, routes, policies, and quotas; prevent cross\u2011environment leakage.</li> </ul>"},{"location":"deploy/#platform-guidance","title":"Platform Guidance","text":"<ul> <li>Kubernetes/OpenShift with:</li> <li>Hardened images (minimal base, non\u2011root), signed artifacts, SBOMs, and vulnerability scanning.</li> <li>Runtime sandboxing (gVisor, Kata Containers) and OS controls (seccomp, SELinux/AppArmor, cgroups).</li> <li>Network policies (least privilege egress/ingress), mTLS service\u2011to\u2011service, and managed secrets.</li> <li>Autoscaling based on SLOs; quotas per tenant; resource requests/limits enforced.</li> </ul>"},{"location":"deploy/#rollout-strategies","title":"Rollout Strategies","text":"<ul> <li>Canary and blue\u2011green with fast rollback and kill switches; monitor p95 latency, error rates, and policy denials during rollout.</li> <li>Shadow traffic where feasible to compare behavior before promotion.</li> </ul>"},{"location":"deploy/#packaging-and-supply-chain","title":"Packaging and Supply Chain","text":"<ul> <li>Package MCP servers as containers for production; sign and verify images; maintain SBOMs and provenance; use curated catalogs and verified registries only.</li> </ul>"},{"location":"deploy/#predeployment-readiness","title":"Pre\u2011Deployment Readiness","text":"<ul> <li>Tests passing; security scans complete; dependencies pinned and current; version tagged.</li> <li>Monitoring and alerting wired; dashboards ready; health/readiness endpoints validated.</li> <li>Configuration and secrets stored securely; network and DNS configured; change plan and rollback steps approved.</li> </ul>"},{"location":"develop/","title":"Develop","text":""},{"location":"develop/#develop","title":"Develop","text":"<p>Build MCP servers using clear contracts and disciplined patterns. Keep implementations simple and observable; avoid framework lock-in where possible.</p>"},{"location":"develop/#principles","title":"Principles","text":"<ul> <li>Single responsibility: one domain and authentication boundary per server.</li> <li>Contracts first: strict input/output schemas, explicit side effects, documented errors.</li> <li>Additive change: version contracts; prefer backward-compatible evolution with deprecations.</li> <li>Stateless by default: externalize state with TTLs and PII handling; provide async status for long-running work.</li> </ul>"},{"location":"develop/#workflow","title":"Workflow","text":"<ul> <li>Define outcomes and success metrics before coding; write tool/resource contracts first.</li> <li>Instrument from day one (structured logs, metrics, traces); add correlation IDs.</li> <li>Validate inputs rigorously; enforce least-privilege for tools and resources.</li> <li>Integrate with secrets managers; never embed credentials in code or configs.</li> </ul>"},{"location":"develop/#quality","title":"Quality","text":"<ul> <li>Unit tests for tool logic and contract enforcement; integration tests for protocol flows and discovery.</li> <li>Track regressions with evals on key tasks; compare candidate vs. baseline before promotion.</li> <li>Keep a changelog and release notes with impact levels (breaking, behavior-shifting, non-functional).</li> </ul>"},{"location":"develop/#handover","title":"Handover","text":"<ul> <li>Document server purpose, boundaries, capabilities, contracts, and error catalog.</li> <li>Provide operational notes: SLOs, health/readiness, limits/quotas, and runbooks.</li> <li>Publish version identifiers and SBOMs; store signed artifacts in trusted catalogs.</li> </ul>"},{"location":"develop/#see-also","title":"See Also","text":"<p>Test, Package, Deploy, Operate, Secure.</p>"},{"location":"operate/","title":"Operate","text":""},{"location":"operate/#operate-lifecycle-management","title":"Operate (Lifecycle &amp; Management)","text":"<p>Operate MCP servers with consistent lifecycle management, observability, and governance. This page combines operations and management into one high\u2011level guide.</p>"},{"location":"operate/#operational-excellence","title":"Operational Excellence","text":"<ul> <li>Observability: standardized logs, metrics, and tracing; correlate via request IDs and gateway.</li> <li>Automation: automate rollouts, scaling, and remediation; codify runbooks.</li> <li>Reliability: design for failure; use circuit breakers and graceful degradation.</li> <li>Performance: set SLOs; monitor and optimize continuously.</li> <li>Security: defense in depth at runtime (policies, approvals, least privilege).</li> </ul>"},{"location":"operate/#operational-readiness-preprod","title":"Operational Readiness (Pre\u2011Prod)","text":"<ul> <li>Dashboards and alerting in place; on\u2011call rotation and incident response defined.</li> <li>Logging, tracing, and metrics standardized (OpenTelemetry); correlation IDs across components.</li> <li>Backups and recovery tested for any externalized state.</li> <li>Capacity planning done; load/burst and dependency failure modes tested.</li> </ul>"},{"location":"operate/#monitoring-observability","title":"Monitoring &amp; Observability","text":"<ul> <li>Four signals: latency, traffic, errors, saturation; plus policy denials and approval deferrals.</li> <li>Key metrics: tool success rate, p95 latency, error classes, cost/quotas, dependency health.</li> <li>Health/readiness endpoints; dependency checks with timeouts and fallbacks.</li> </ul>"},{"location":"operate/#lifecycle-management","title":"Lifecycle Management","text":"<ul> <li>Curated catalog: only deploy approved servers; require SBOMs, provenance, signatures, and scans.</li> <li>Approval workflow: registration, promotion, ownership, SLOs recorded; audit trails by default.</li> <li>Multi\u2011tenancy: per\u2011tenant isolation for configs, logs, metrics, and limits; tenant\u2011aware authZ.</li> <li>Remote/external servers: govern through a gateway/proxy where possible; document constraints and SLAs.</li> </ul>"},{"location":"operate/#tooling-automation","title":"Tooling &amp; Automation","text":"<ul> <li>One operator/controller framework for all servers; avoid bespoke operators per team.</li> <li>Use Helm or operator frameworks but standardize org\u2011wide; version your ops configs.</li> <li>Runbooks: dependency outages, rate\u2011limit responses, rollback steps, and escalation mapped.</li> </ul>"},{"location":"operate/#slos-and-incident-response","title":"SLOs and Incident Response","text":"<ul> <li>Example baselines to tune: tool success rate \u2265 99.0% monthly; p95 \u2264 400 ms.</li> <li>Taxonomy: availability, latency, correctness (contract failures), security, quota/budget.</li> <li>Flow: detect \u2192 triage (blast radius) \u2192 mitigate (degrade/circuit break) \u2192 RCA \u2192 fix/rollback \u2192 catalog learnings.</li> </ul>"},{"location":"overview/","title":"Introduction","text":""},{"location":"overview/#mcp-overview","title":"MCP Overview","text":""},{"location":"overview/#what-mcp-is","title":"What MCP Is","text":"<p>The Model Context Protocol (MCP) standardizes how applications expose capabilities (tools, resources, and prompts) and how clients discover and invoke them over well\u2011defined transports. It creates a consistent contract between providers and consumers of capabilities so teams can scale integrations without bespoke adapters, hidden side effects, or inconsistent security models.</p>"},{"location":"overview/#why-mcp","title":"Why MCP","text":"<p>Adopting MCP gives organizations a durable interface for connecting AI applications to systems of record and action.</p> <ul> <li>Standardization: consistent, discoverable contracts across integrations</li> <li>Security and control: built-in patterns for authN/Z and policy enforcement</li> <li>Scale and flexibility: works locally (stdio) and remotely (streamable HTTP)</li> <li>Observability: structured telemetry for discovery and invocation flows</li> </ul>"},{"location":"overview/#core-building-blocks","title":"Core Building Blocks","text":"<p>At its core, MCP is a simple client\u2013server protocol with optional gateway mediation.</p> <ul> <li>Servers: expose tools (actions), resources (read-only context), and prompts (templates)</li> <li>Clients/Hosts: discover capabilities and invoke them safely</li> <li>Gateway (optional): centralizes authN/Z, routing, quotas, catalogs, and policy</li> <li>Transports: stdio for local per-user; streamable HTTP for shared, remote services</li> </ul>"},{"location":"overview/#when-to-use-mcp","title":"When to Use MCP","text":"<p>Choose MCP when you need repeatable, governed integrations rather than one\u2011off connectors.</p> <ul> <li>You need a consistent, policy-enforced interface for tools and context</li> <li>You operate many servers/tenants and require centralized governance</li> <li>You want portable integrations decoupled from specific runtime implementations</li> </ul>"},{"location":"overview/#success-factors","title":"Success Factors","text":"<ul> <li>Clear server responsibility and narrow tool scopes</li> <li>Contracts-first design (schemas, side effects, errors)</li> <li>Centralized platform controls where appropriate (gateway)</li> <li>Observability and SLOs established from day one</li> </ul>"},{"location":"overview/#what-mcp-is-not","title":"What MCP Is Not","text":"<ul> <li>Not an agent framework: MCP defines the interface between clients and capability providers; it doesn\u2019t prescribe planning or reasoning.</li> <li>Not a data lake or message bus: it\u2019s a control plane for capability discovery and invocation, not a storage or streaming substrate.</li> <li>Not a silver bullet: it won\u2019t fix unclear ownership, missing contracts, or absent governance by itself.</li> </ul>"},{"location":"overview/#adoption-path-typical","title":"Adoption Path (Typical)","text":"<ol> <li>Define a small, single\u2011purpose server with strict contracts.</li> <li>Add observability and SLOs; validate with tests and evals.</li> <li>Package as a container; sign artifacts and publish to a trusted catalog.</li> <li>Deploy behind a gateway; enforce policy and quotas; iterate with canaries.</li> <li>Expand capabilities gradually, keeping contracts and ownership clear.</li> </ol>"},{"location":"package/","title":"Package","text":""},{"location":"package/#package","title":"Package","text":"<p>Package MCP servers for reliable distribution and deployment. Emphasize supply chain integrity and operational readiness.</p>"},{"location":"package/#packaging-strategies","title":"Packaging Strategies","text":"<ul> <li>Language packages (PyPI/NPM/etc.) can support developer distribution; for production, prefer containers.</li> <li>Containers: OCI images via multi-stage with minimal base images; run as non-root.</li> <li>Binary distributions: only when required; ensure signing and update channels.</li> </ul>"},{"location":"package/#package-structure","title":"Package Structure","text":"<ul> <li>Recommended layout: src (code), tests, docs, configs, scripts, Containerfile, README, CHANGELOG.</li> </ul>"},{"location":"package/#production-containers-guidance","title":"Production Containers (Guidance)","text":"<ul> <li>Use minimal, well-maintained images; drop unnecessary capabilities; read-only file systems.</li> <li>Sign images; maintain SBOMs and provenance; enforce verification in clusters.</li> <li>Externally managed secrets; health and readiness probes; resource requests/limits.</li> </ul>"},{"location":"package/#supply-chain-controls","title":"Supply Chain Controls","text":"<ul> <li>Verified registries and curated catalogs; block untrusted sources.</li> <li>Reproducible builds where feasible; store artifacts with signatures.</li> </ul>"},{"location":"package/#distribution","title":"Distribution","text":"<ul> <li>Publish through trusted channels; include release notes and impact levels.</li> <li>Keep compatibility/support matrices; document upgrade paths and deprecations.</li> </ul>"},{"location":"package/#versioning-strategy","title":"Versioning Strategy","text":"<ul> <li>Semantic versioning for servers, SDKs, and contracts; document breaking changes clearly.</li> <li>Maintain a simple compatibility matrix and update with each release.</li> </ul>"},{"location":"package/#next-steps","title":"Next Steps","text":"<ul> <li>Validate packaging against organizational policies (signing, SBOMs, provenance).</li> <li>Prefer containers for production distribution; enforce non-root and minimal images.</li> </ul>"},{"location":"secure/","title":"Secure","text":""},{"location":"secure/#secure","title":"Secure","text":"<p>Security is a continuous discipline across design, build, deploy, and run. Combine platform-native controls with centralized governance.</p>"},{"location":"secure/#principles","title":"Principles","text":"<ul> <li>Defense in depth with least privilege for tools and actions.</li> <li>Centralize policy where possible (gateway/proxy) to avoid re\u2011implementing controls.</li> <li>Treat authentication, authorization, and audit as first\u2011class requirements.</li> </ul>"},{"location":"secure/#threats-controls-high-level","title":"Threats &amp; Controls (High-Level)","text":"<ul> <li>Input manipulation &amp; injection: strict schemas, validation, and output sanitization.</li> <li>Over\u2011privilege &amp; escalation: scoped tokens, approvals for high\u2011impact ops, runtime policy checks.</li> <li>Data leakage: data classification, minimization, redaction, and isolation.</li> <li>Supply chain risk: SBOMs, signing, provenance, trusted registries, vulnerability scanning.</li> <li>Drift &amp; misconfiguration: baseline configs, policy-as-code, continuous posture checks.</li> </ul>"},{"location":"secure/#identity-access","title":"Identity &amp; Access","text":"<ul> <li>Granular scopes per tool/action; time\u2011limited, auditable credentials.</li> <li>Support OIDC/OAuth2 patterns as per spec; prefer mTLS between services.</li> <li>Record who/what/when/why with immutable audit trails.</li> </ul>"},{"location":"secure/#runtime-protection","title":"Runtime Protection","text":"<ul> <li>Sandboxing (gVisor/Kata) and OS controls (seccomp, SELinux/AppArmor, cgroups).</li> <li>Network policy: least-privilege egress/ingress; mTLS; explicit allowlists.</li> <li>Circuit breakers and rate limits per tenant/tool; backoff with jitter.</li> </ul>"},{"location":"secure/#monitoring-response","title":"Monitoring &amp; Response","text":"<ul> <li>Dedicated security log stream; alerts for policy denials, unusual access, and data exfiltration patterns.</li> <li>Incident flow: detect \u2192 contain \u2192 investigate \u2192 remediate \u2192 recover \u2192 review.</li> </ul>"},{"location":"secure/#compliance","title":"Compliance","text":"<ul> <li>Align with organizational standards (SOC2/ISO/etc.); automate evidence capture.</li> <li>Apply continuous assurance, not point\u2011in\u2011time checks.</li> </ul>"},{"location":"secure/#next-steps","title":"Next Steps","text":"<ul> <li>Centralize controls through a gateway/proxy where possible to avoid duplicating security logic across servers.</li> <li>Align with organizational compliance standards and document continuous assurance practices.</li> </ul>"},{"location":"test/","title":"Test","text":""},{"location":"test/#test","title":"Test","text":"<p>Validate MCP servers for correctness, safety, and performance. Focus on behavior and contracts.</p>"},{"location":"test/#testing-pyramid-guidance","title":"Testing Pyramid (Guidance)","text":"<ul> <li>Unit (majority): fast, isolated validations of tool logic and contracts.</li> <li>Integration: protocol flows, discovery, and interactions with dependencies.</li> <li>End-to-end: gateway + host/client workflows with real configurations.</li> </ul>"},{"location":"test/#what-to-test","title":"What to Test","text":"<ul> <li>Critical paths: tool execution, resource access, error handling, input validation, authN/Z.</li> <li>Edge cases: empty/large inputs, invalid types, concurrency, dependency/network failures.</li> <li>Non-functional: latency and throughput targets, quotas, and backpressure.</li> </ul>"},{"location":"test/#coverage-targets-tune-to-context","title":"Coverage Targets (Tune to Context)","text":"<ul> <li>Overall coverage around 80%+; 100% for critical paths; high coverage for error handling and edge cases.</li> </ul>"},{"location":"test/#test-data-and-dependencies","title":"Test Data and Dependencies","text":"<ul> <li>Use realistic fixtures; avoid brittle tests.</li> <li>Mock external services where appropriate; include selective live-integration tests for critical dependencies.</li> </ul>"},{"location":"test/#continuous-integration","title":"Continuous Integration","text":"<ul> <li>Lint, test, and measure coverage on every change; publish artifacts and test reports.</li> <li>Track regressions via dashboards; block promotion if SLOs or quality gates fail.</li> </ul>"},{"location":"test/#pre-release-checklist","title":"Pre-Release Checklist","text":"<ul> <li>Unit/integration/E2E tests pass; security scans clean; performance benchmarks within SLOs.</li> <li>Documentation current; manual smoke tests done; rollback plan defined.</li> </ul>"},{"location":"use/","title":"Use","text":""},{"location":"use/#use","title":"Use","text":"<p>High-level guidance for how MCP servers are consumed by clients and hosts.</p>"},{"location":"use/#hosts-and-clients","title":"Hosts and Clients","text":"<ul> <li>Use supported MCP hosts (desktop, headless, IDEs) appropriate for your environment.</li> <li>Prefer gateway-mediated access for centralized authN/Z, routing, quotas, and policy.</li> </ul>"},{"location":"use/#integration-patterns","title":"Integration Patterns","text":"<ul> <li>Direct connection (stdio/http) for local, trusted use cases.</li> <li>Through a gateway for enterprise scenarios with many servers/tenants and shared controls.</li> </ul>"},{"location":"use/#authentication","title":"Authentication","text":"<ul> <li>Follow the spec for supported flows; avoid bespoke schemes. Keep tokens scoped, short\u2011lived, and auditable.</li> </ul>"},{"location":"use/#operational-considerations","title":"Operational Considerations","text":"<ul> <li>Provide clear discovery; document contracts and side effects.</li> <li>Publish SLOs and error catalogs; provide support contacts and runbooks.</li> </ul>"},{"location":"use/#good-citizen-guidance","title":"Good Citizen Guidance","text":"<ul> <li>Avoid long\u2011running client calls without async patterns.</li> <li>Respect rate limits and quotas; handle policy denials gracefully.</li> <li>Surface provenance and citations where appropriate for auditability.</li> </ul>"}]}